<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 14 Area Data and Spatial Autocorrelation | Spatial Data Science</title>
  <meta name="description" content="description_xx" />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 14 Area Data and Spatial Autocorrelation | Spatial Data Science" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="description_xx" />
  <meta name="github-repo" content="edzer/sdsr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 14 Area Data and Spatial Autocorrelation | Spatial Data Science" />
  
  <meta name="twitter:description" content="description_xx" />
  

<meta name="author" content="Edzer Pebesma, Roger Bivand" />


<meta name="date" content="2021-02-25" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="manipulating-attributes-summarise-aggregate-union-sample.html"/>
<link rel="next" href="spatial-regression.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/htmlwidgets-1.5.3/htmlwidgets.js"></script>
<link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-1.3.1/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<script src="libs/proj4-2.6.2/proj4.min.js"></script>
<script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script>
<link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-binding-2.0.4.1/leaflet.js"></script>
<script src="libs/leaflet-providers-1.9.0/leaflet-providers_1.9.0.js"></script>
<script src="libs/leaflet-providers-plugin-2.0.4.1/leaflet-providers-plugin.js"></script>
<script src="libs/FlatGeoBuf-3.3.3/fgb.js"></script>
<script src="libs/FlatGeoBuf-3.3.3/flatgeobuf-geojson.min.js"></script>
<script src="libs/chromajs-2.1.0/chroma.min.js"></script>
<link id="_-BIR74-1-attachment" rel="attachment" href="libs/_-BIR74-0.0.1/_-BIR74_layer.fgb"/>
<link href="libs/HomeButton-0.0.1/home-button.css" rel="stylesheet" />
<script src="libs/HomeButton-0.0.1/home-button.js"></script>
<script src="libs/HomeButton-0.0.1/easy-button-src.min.js"></script>
<script src="libs/clipboard-0.0.1/setClipboardText.js"></script>
<link href="libs/mapviewCSS-0.0.1/mapview-popup.css" rel="stylesheet" />
<link href="libs/mapviewCSS-0.0.1/mapview.css" rel="stylesheet" />

<script>
/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);
</script>
<script>
/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.7'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);
</script>
<script>
window.initializeCodeFolding = function(show) {

  // handlers for show-all and hide all
  $("#rmd-show-all-code").click(function() {
    // close the dropdown menu when an option is clicked
    $("#allCodeButton").dropdown("toggle");
    $('div.r-code-collapse').each(function() {
      $(this).collapse('show');
    });
  });
  $("#rmd-hide-all-code").click(function() {
    // close the dropdown menu when an option is clicked
    $("#allCodeButton").dropdown("toggle");
    $('div.r-code-collapse').each(function() {
      $(this).collapse('hide');
    });
  });

  // index for unique code element ids
  var currentIndex = 1;

  // select all R code blocks
  var rCodeBlocks = $('pre.sourceCode, pre.r, pre.python, pre.bash, pre.sql, pre.cpp, pre.stan');
  rCodeBlocks.each(function() {

    // if code block has been labeled with class `fold-show`, show the code on init!
    var classList = $(this).attr('class').split(/\s+/);
    for (var i = 0; i < classList.length; i++) {
    if (classList[i] === 'fold-show') {
        show = true;
      }
    }

    // create a collapsable div to wrap the code in
    var div = $('<div class="collapse r-code-collapse"></div>');
    if (show)
      div.addClass('in');
    var id = 'rcode-643E0F36' + currentIndex++;
    div.attr('id', id);
    $(this).before(div);
    $(this).detach().appendTo(div);

    // add a show code button right above
    var showCodeText = $('<span>' + (show ? 'Hide' : 'Code') + '</span>');
    var showCodeButton = $('<button type="button" class="btn btn-default btn-xs code-folding-btn pull-right"></button>');
    showCodeButton.append(showCodeText);
    showCodeButton
        .attr('data-toggle', 'collapse')
        .attr('data-target', '#' + id)
        .attr('aria-expanded', show)
        .attr('aria-controls', id);

    var buttonRow = $('<div class="row"></div>');
    var buttonCol = $('<div class="col-md-12"></div>');

    buttonCol.append(showCodeButton);
    buttonRow.append(buttonCol);

    div.before(buttonRow);

    // hack: return show to false, otherwise all next codeBlocks will be shown!
    show = false;

    // update state of button on show/hide
    div.on('hidden.bs.collapse', function () {
      showCodeText.text('Code');
    });
    div.on('show.bs.collapse', function () {
      showCodeText.text('Hide');
    });
  });

}
</script>
<script>
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.7'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);
</script>
<style type="text/css">
.code-folding-btn {
  margin-bottom: 4px;
}

.row { display: flex; }
.collapse { display: none; }
.in { display:block }
.pull-right > .dropdown-menu {
    right: 0;
    left: auto;
}

.dropdown-menu {
    position: absolute;
    top: 100%;
    left: 0;
    z-index: 1000;
    display: none;
    float: left;
    min-width: 160px;
    padding: 5px 0;
    margin: 2px 0 0;
    font-size: 14px;
    text-align: left;
    list-style: none;
    background-color: #fff;
    -webkit-background-clip: padding-box;
    background-clip: padding-box;
    border: 1px solid #ccc;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 4px;
    -webkit-box-shadow: 0 6px 12px rgba(0,0,0,.175);
    box-shadow: 0 6px 12px rgba(0,0,0,.175);
}

.open > .dropdown-menu {
    display: block;
    color: #ffffff;
    background-color: #ffffff;
    background-image: none;
    border-color: #92897e;
}

.dropdown-menu > li > a {
  display: block;
  padding: 3px 20px;
  clear: both;
  font-weight: 400;
  line-height: 1.42857143;
  color: #000000;
  white-space: nowrap;
}

.dropdown-menu > li > a:hover,
.dropdown-menu > li > a:focus {
  color: #ffffff;
  text-decoration: none;
  background-color: #e95420;
}

.dropdown-menu > .active > a,
.dropdown-menu > .active > a:hover,
.dropdown-menu > .active > a:focus {
  color: #ffffff;
  text-decoration: none;
  background-color: #e95420;
  outline: 0;
}
.dropdown-menu > .disabled > a,
.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  color: #aea79f;
}

.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  text-decoration: none;
  cursor: not-allowed;
  background-color: transparent;
  background-image: none;
  filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
}

.btn {
  display: inline-block;
  margin-bottom: 1;
  font-weight: normal;
  text-align: center;
  white-space: nowrap;
  vertical-align: middle;
  -ms-touch-action: manipulation;
      touch-action: manipulation;
  cursor: pointer;
  background-image: none;
  border: 1px solid transparent;
  padding: 4px 8px;
  font-size: 14px;
  line-height: 1.42857143;
  border-radius: 4px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.btn:focus,
.btn:active:focus,
.btn.active:focus,
.btn.focus,
.btn:active.focus,
.btn.active.focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
.btn:hover,
.btn:focus,
.btn.focus {
  color: #ffffff;
  text-decoration: none;
}
.btn:active,
.btn.active {
  background-image: none;
  outline: 0;
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn.disabled,
.btn[disabled],
fieldset[disabled] .btn {
  cursor: not-allowed;
  filter: alpha(opacity=65);
  opacity: 0.65;
  box-shadow: none;
}
a.btn.disabled,
fieldset[disabled] a.btn {
  pointer-events: none;
}
.btn-default {
  color: #ffffff;
  background-color: #aea79f; #important
  border-color: #aea79f;
}

.btn-default:focus,
.btn-default.focus {
  color: #ffffff;
  background-color: #978e83;
  border-color: #6f675e;
}

.btn-default:hover {
  color: #ffffff;
  background-color: #978e83;
  border-color: #92897e;
}
.btn-default:active,
.btn-default.active,
.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
  border-radius: 0;
}
.btn-group > .btn:first-child {
  margin-left: 0;
}
.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.btn-group > .btn:last-child:not(:first-child),
.btn-group > .dropdown-toggle:not(:first-child) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group > .btn-group {
  float: left;
}
.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group .dropdown-toggle:active,
.btn-group.open .dropdown-toggle {
  outline: 0;
}
.btn-group > .btn + .dropdown-toggle {
  padding-right: 8px;
  padding-left: 8px;
}
.btn-group > .btn-lg + .dropdown-toggle {
  padding-right: 12px;
  padding-left: 12px;
}
.btn-group.open .dropdown-toggle {
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn-group.open .dropdown-toggle.btn-link {
  box-shadow: none;
}

</style>
<script>
var str = '<div class="btn-group pull-right" style="position: fixed; right: 50px; top: 10px; z-index: 200"><button type="button" class="btn btn-default btn-xs dropdown-toggle" id="allCodeButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true" data-_extension-text-contrast=""><span>Code</span> <span class="caret"></span></button><ul class="dropdown-menu" style="min-width: 50px;"><li><a id="rmd-show-all-code" href="#">Show All Code</a></li><li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li></ul></div>';
document.write(str);
</script>
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "hide");
});
</script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Spatial Data Science</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="part"><span><b>I Spatial Data</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Getting Started</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#a-first-map"><i class="fa fa-check"></i><b>1.1</b> A first map</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#coordinate-reference-systems"><i class="fa fa-check"></i><b>1.2</b> Coordinate reference systems</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#raster-and-vector-data"><i class="fa fa-check"></i><b>1.3</b> Raster and vector data</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#raster-types"><i class="fa fa-check"></i><b>1.4</b> Raster types</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#time-series-arrays-data-cubes"><i class="fa fa-check"></i><b>1.5</b> Time series, arrays, data cubes</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#support"><i class="fa fa-check"></i><b>1.6</b> Support</a></li>
<li class="chapter" data-level="1.7" data-path="intro.html"><a href="intro.html#spatial-data-science-software"><i class="fa fa-check"></i><b>1.7</b> Spatial data science software</a></li>
<li class="chapter" data-level="1.8" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="cs.html"><a href="cs.html"><i class="fa fa-check"></i><b>2</b> Coordinates</a><ul>
<li class="chapter" data-level="2.1" data-path="cs.html"><a href="cs.html#units"><i class="fa fa-check"></i><b>2.1</b> Quantities and units</a></li>
<li class="chapter" data-level="2.2" data-path="cs.html"><a href="cs.html#ellipsoidal-coordinates"><i class="fa fa-check"></i><b>2.2</b> Ellipsoidal coordinates</a></li>
<li class="chapter" data-level="2.3" data-path="cs.html"><a href="cs.html#crs"><i class="fa fa-check"></i><b>2.3</b> Coordinate Reference Systems</a></li>
<li class="chapter" data-level="2.4" data-path="cs.html"><a href="cs.html#proj-and-mapping-accuracy"><i class="fa fa-check"></i><b>2.4</b> PROJ and mapping accuracy</a></li>
<li class="chapter" data-level="2.5" data-path="cs.html"><a href="cs.html#exercises-1"><i class="fa fa-check"></i><b>2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="geometries.html"><a href="geometries.html"><i class="fa fa-check"></i><b>3</b> Geometries</a><ul>
<li class="chapter" data-level="3.1" data-path="geometries.html"><a href="geometries.html#simple-feature-geometries"><i class="fa fa-check"></i><b>3.1</b> Simple feature geometries</a></li>
<li class="chapter" data-level="3.2" data-path="geometries.html"><a href="geometries.html#opgeom"><i class="fa fa-check"></i><b>3.2</b> Operations on geometries</a></li>
<li class="chapter" data-level="3.3" data-path="geometries.html"><a href="geometries.html#precision"><i class="fa fa-check"></i><b>3.3</b> Precision</a></li>
<li class="chapter" data-level="3.4" data-path="geometries.html"><a href="geometries.html#coverages"><i class="fa fa-check"></i><b>3.4</b> Coverages: tesselations and rasters</a></li>
<li class="chapter" data-level="3.5" data-path="geometries.html"><a href="geometries.html#networks"><i class="fa fa-check"></i><b>3.5</b> Networks</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="spherical.html"><a href="spherical.html"><i class="fa fa-check"></i><b>4</b> Spherical Geometries</a><ul>
<li class="chapter" data-level="4.1" data-path="spherical.html"><a href="spherical.html#straight-lines"><i class="fa fa-check"></i><b>4.1</b> Straight lines</a></li>
<li class="chapter" data-level="4.2" data-path="spherical.html"><a href="spherical.html#ring-direction"><i class="fa fa-check"></i><b>4.2</b> Ring direction</a></li>
<li class="chapter" data-level="4.3" data-path="spherical.html"><a href="spherical.html#full-polygon"><i class="fa fa-check"></i><b>4.3</b> Full polygon</a></li>
<li class="chapter" data-level="4.4" data-path="spherical.html"><a href="spherical.html#bounding-box-rectangle-and-cap"><i class="fa fa-check"></i><b>4.4</b> Bounding box, rectangle, and cap</a></li>
<li class="chapter" data-level="4.5" data-path="spherical.html"><a href="spherical.html#validity-on-the-sphere"><i class="fa fa-check"></i><b>4.5</b> Validity on the sphere</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="featureattributes.html"><a href="featureattributes.html"><i class="fa fa-check"></i><b>5</b> Attributes, Up- and Downscaling</a><ul>
<li class="chapter" data-level="5.1" data-path="featureattributes.html"><a href="featureattributes.html#agr"><i class="fa fa-check"></i><b>5.1</b> Attribute-geometry relationships</a></li>
<li class="chapter" data-level="5.2" data-path="featureattributes.html"><a href="featureattributes.html#spatial-join"><i class="fa fa-check"></i><b>5.2</b> Spatial join</a></li>
<li class="chapter" data-level="5.3" data-path="featureattributes.html"><a href="featureattributes.html#aggregating-and-summarising"><i class="fa fa-check"></i><b>5.3</b> Aggregating and Summarising</a></li>
<li class="chapter" data-level="5.4" data-path="featureattributes.html"><a href="featureattributes.html#area-weighted"><i class="fa fa-check"></i><b>5.4</b> Area-weighted interpolation</a></li>
<li class="chapter" data-level="5.5" data-path="featureattributes.html"><a href="featureattributes.html#exercises-2"><i class="fa fa-check"></i><b>5.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="raster.html"><a href="raster.html"><i class="fa fa-check"></i><b>6</b> Raster and vector datacubes</a><ul>
<li class="chapter" data-level="6.1" data-path="raster.html"><a href="raster.html#package-stars"><i class="fa fa-check"></i><b>6.1</b> Package <code>stars</code></a></li>
<li class="chapter" data-level="6.2" data-path="raster.html"><a href="raster.html#raster-data"><i class="fa fa-check"></i><b>6.2</b> Raster data</a></li>
<li class="chapter" data-level="6.3" data-path="raster.html"><a href="raster.html#datacubes"><i class="fa fa-check"></i><b>6.3</b> Vector Datacubes</a></li>
<li class="chapter" data-level="6.4" data-path="raster.html"><a href="raster.html#exercises-3"><i class="fa fa-check"></i><b>6.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="updownscaling.html"><a href="updownscaling.html"><i class="fa fa-check"></i><b>7</b> Up- and Downscaling</a></li>
<li class="part"><span><b>II R for Spatial Data Science</b></span></li>
<li class="chapter" data-level="8" data-path="plotting.html"><a href="plotting.html"><i class="fa fa-check"></i><b>8</b> Plotting spatial data</a><ul>
<li class="chapter" data-level="8.1" data-path="plotting.html"><a href="plotting.html#transform"><i class="fa fa-check"></i><b>8.1</b> Every plot is a projection</a></li>
<li class="chapter" data-level="8.2" data-path="plotting.html"><a href="plotting.html#plotting-points-lines-polygons-grid-cells"><i class="fa fa-check"></i><b>8.2</b> Plotting points, lines, polygons, grid cells</a></li>
<li class="chapter" data-level="8.3" data-path="plotting.html"><a href="plotting.html#classintervals"><i class="fa fa-check"></i><b>8.3</b> Color palettes and class intervals</a></li>
<li class="chapter" data-level="8.4" data-path="plotting.html"><a href="plotting.html#poles-and-datelines"><i class="fa fa-check"></i><b>8.4</b> Poles and datelines</a></li>
<li class="chapter" data-level="8.5" data-path="plotting.html"><a href="plotting.html#graticule"><i class="fa fa-check"></i><b>8.5</b> Graticules and other navigation aids</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="plot.html"><a href="plot.html"><i class="fa fa-check"></i><b>9</b> Base and grid plots</a><ul>
<li class="chapter" data-level="9.1" data-path="plot.html"><a href="plot.html#base-plots"><i class="fa fa-check"></i><b>9.1</b> Base plots</a></li>
<li class="chapter" data-level="9.2" data-path="plot.html"><a href="plot.html#combining-base-plots"><i class="fa fa-check"></i><b>9.2</b> Combining base plots</a></li>
<li class="chapter" data-level="9.3" data-path="plot.html"><a href="plot.html#grid-plots-and-viewports"><i class="fa fa-check"></i><b>9.3</b> Grid plots and viewports</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="ggplot2.html"><a href="ggplot2.html"><i class="fa fa-check"></i><b>10</b> ggplot2</a><ul>
<li class="chapter" data-level="10.1" data-path="ggplot2.html"><a href="ggplot2.html#geom_sf"><i class="fa fa-check"></i><b>10.1</b> <code>geom_sf</code></a></li>
<li class="chapter" data-level="10.2" data-path="ggplot2.html"><a href="ggplot2.html#geom_stars"><i class="fa fa-check"></i><b>10.2</b> <code>geom_stars</code></a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="interactive.html"><a href="interactive.html"><i class="fa fa-check"></i><b>11</b> Interactive Maps</a></li>
<li class="part"><span><b>III Models for Spatial Data</b></span></li>
<li class="chapter" data-level="12" data-path="pointpatterns.html"><a href="pointpatterns.html"><i class="fa fa-check"></i><b>12</b> Point Pattern Analysis</a></li>
<li class="chapter" data-level="13" data-path="manipulating-attributes-summarise-aggregate-union-sample.html"><a href="manipulating-attributes-summarise-aggregate-union-sample.html"><i class="fa fa-check"></i><b>13</b> Manipulating attributes: summarise, aggregate, union, sample</a></li>
<li class="chapter" data-level="14" data-path="area-data-and-spatial-autocorrelation.html"><a href="area-data-and-spatial-autocorrelation.html"><i class="fa fa-check"></i><b>14</b> Area Data and Spatial Autocorrelation</a><ul>
<li class="chapter" data-level="14.1" data-path="area-data-and-spatial-autocorrelation.html"><a href="area-data-and-spatial-autocorrelation.html#spatial-autocorrelation"><i class="fa fa-check"></i><b>14.1</b> Spatial autocorrelation</a></li>
<li class="chapter" data-level="14.2" data-path="area-data-and-spatial-autocorrelation.html"><a href="area-data-and-spatial-autocorrelation.html#spatial-weight-matrices"><i class="fa fa-check"></i><b>14.2</b> Spatial weight matrices</a></li>
<li class="chapter" data-level="14.3" data-path="area-data-and-spatial-autocorrelation.html"><a href="area-data-and-spatial-autocorrelation.html#measures-of-spatial-autocorrelation"><i class="fa fa-check"></i><b>14.3</b> Measures of spatial autocorrelation</a></li>
<li class="chapter" data-level="14.4" data-path="area-data-and-spatial-autocorrelation.html"><a href="area-data-and-spatial-autocorrelation.html#spatial-heterogeneity"><i class="fa fa-check"></i><b>14.4</b> Spatial heterogeneity</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="spatial-regression.html"><a href="spatial-regression.html"><i class="fa fa-check"></i><b>15</b> Spatial Regression</a><ul>
<li class="chapter" data-level="15.1" data-path="spatial-regression.html"><a href="spatial-regression.html#spatial-regression-with-spatial-weights"><i class="fa fa-check"></i><b>15.1</b> Spatial regression with spatial weights</a></li>
<li class="chapter" data-level="15.2" data-path="spatial-regression.html"><a href="spatial-regression.html#estimators"><i class="fa fa-check"></i><b>15.2</b> Estimators</a></li>
<li class="chapter" data-level="15.3" data-path="spatial-regression.html"><a href="spatial-regression.html#implementation-details"><i class="fa fa-check"></i><b>15.3</b> Implementation details</a></li>
<li class="chapter" data-level="15.4" data-path="spatial-regression.html"><a href="spatial-regression.html#markov-random-field-and-multilevel-models-with-spatial-weights"><i class="fa fa-check"></i><b>15.4</b> Markov random field and multilevel models with spatial weights</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="movement-data.html"><a href="movement-data.html"><i class="fa fa-check"></i><b>16</b> Movement data</a></li>
<li class="chapter" data-level="17" data-path="statistical-modelling-of-spatiotemporal-data.html"><a href="statistical-modelling-of-spatiotemporal-data.html"><i class="fa fa-check"></i><b>17</b> Statistical modelling of spatiotemporal data</a></li>
<li class="chapter" data-level="18" data-path="sp-and-raster.html"><a href="sp-and-raster.html"><i class="fa fa-check"></i><b>18</b> sp and raster</a><ul>
<li class="chapter" data-level="18.1" data-path="sp-and-raster.html"><a href="sp-and-raster.html#links-and-differences-between-sf-and-sp"><i class="fa fa-check"></i><b>18.1</b> links and differences between sf and sp</a></li>
<li class="chapter" data-level="18.2" data-path="sp-and-raster.html"><a href="sp-and-raster.html#migration-packages"><i class="fa fa-check"></i><b>18.2</b> migration packages</a></li>
<li class="chapter" data-level="18.3" data-path="sp-and-raster.html"><a href="sp-and-raster.html#raster-stars-and-sf"><i class="fa fa-check"></i><b>18.3</b> raster, stars and sf</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="r-basics.html"><a href="r-basics.html"><i class="fa fa-check"></i>R basics</a><ul>
<li class="chapter" data-level="18.4" data-path="r-basics.html"><a href="r-basics.html#pipes"><i class="fa fa-check"></i><b>18.4</b> Pipes</a></li>
<li class="chapter" data-level="18.5" data-path="r-basics.html"><a href="r-basics.html#data-structures"><i class="fa fa-check"></i><b>18.5</b> Data structures</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spatial Data Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="area-data-and-spatial-autocorrelation" class="section level1">
<h1><span class="header-section-number">Chapter 14</span> Area Data and Spatial Autocorrelation</h1>
<p>Areal units of observation are very often used when simultaneous observations are aggregated within non-overlapping boundaries. The boundaries may be those of administrative entities, and may be related to underlying spatial processes, such as commuting flows, but are usually arbitrary. If they do not match the underlying and unobserved spatial processes in one or more variables of interest, proximate areal units will contain parts of the underlying processes, engendering spatial autocorrelation. This is at least in part because the aggregated observations are driven by autocorrelated factors which may or may not themselves have been observed.</p>
<p>With support of data we mean the physical size (lenth, area, volume) associated with an individual observational unit (measurement). It is possible to represent the support of areal data by a point, despite the fact that the data have polygonal support. The centroid of the polygon may be taken as a representative point, or the centroid of the largest polygon in a multi-polygon object. When data with intrinsic point support are treated as areal data, the change of support goes the other way, from the known point to a non-overlapping tesselation such as a Voronoi diagram or Dirichlet tessellation or Thiessen polygons often through a Delaunay triangulation and using a Euclidean plane (projected coordinates). Here, different metrics may also be chosen, or distances measured on a network rather than on the plane. There is also a literature using weighted Voronoi diagrams in local spatial analysis <span class="citation">(see for example Boots and Okabe <a href="#ref-doi:10.1080/13658810601034267">2007</a>; Okabe et al. <a href="#ref-doi:10.1080/13658810701587891">2008</a>; She et al. <a href="#ref-SHE201570">2015</a>)</span>.</p>
<p>When the intrinsic support of the data is as points, but the underlying process is between proximate observations rather than driven chiefly by distance however measured between observations, the data may be aggregate counts or totals (polling stations, retail turnover) or represent a directly observed characteristic of the observation (opening hours of the polling station). Obviously, the risk of mis-representing the footprint of the underlying spatial processes remains in all of these cases, not least because the observations are taken as encompassing the entirety of the underlying process in the case of tesselation of the whole area of interest. This is distinct from the geostatistical setting in which observations are rather samples taken using some scheme within the area of interest. It is also partly distinct from the practice of taking areal sample plots within the area of interest but covering only a small proportion of the area, typically used in ecological and environmental research.</p>
<p>This chapter then considers a subset of the methods potentially available for exploring spatial autocorrelation in areal data, or data being handled as areal, where the spatial processes are considered as working through proximity understood in the first instance as contiguity, as a graph linking observations taken as neighbours. This graph is typically undirected and unweighted, but may be directed and/or weighted in certain settings, which then leads to further issues with regard to symmetry. In principle, proximity would be expected to operate symmetrically in space, that is that the influence of <span class="math inline">\(i\)</span> on <span class="math inline">\(j\)</span> and of <span class="math inline">\(j\)</span> on <span class="math inline">\(i\)</span> based on their relative positions should be equivalent. Edge effects are not considered in standard treatments.</p>
<div id="spatial-autocorrelation" class="section level2">
<h2><span class="header-section-number">14.1</span> Spatial autocorrelation</h2>
<p>When analysing areal data, it has long been recognised that, if present, spatial autocorrelation changes how we may infer, relative to the default position of independent observations. In the presence of spatial autocorrelation, we can predict the values of observation <span class="math inline">\(i\)</span> from the values observed at <span class="math inline">\(j \in N_i\)</span>, the set of its proximate neighbours. Early results <span class="citation">(Moran <a href="#ref-moran48">1948</a>; Geary <a href="#ref-geary:54">1954</a>)</span>, entered into research practice gradually, for example the social sciences <span class="citation">(Duncan, Cuzzort, and Duncan <a href="#ref-duncanetal61">1961</a>)</span>. These results were then collated and extended to yield a set of basic tools of analysis <span class="citation">(Cliff and Ord <a href="#ref-cliff+ord:73">1973</a>, <a href="#ref-cliff+ord:81">1981</a>)</span>.</p>
<p>Cliff and Ord <span class="citation">(<a href="#ref-cliff+ord:73">1973</a>)</span> generalised and extended the expression of the spatial weights matrix representation as part of the framework for establishing the distribution theory for join count, Moran’s <span class="math inline">\(I\)</span> and Geary’s <span class="math inline">\(C\)</span> statistics. This development of what have become known as global measures, returning a single value of autocorrelation for the total study area, has been supplemented by local measures returning values for each areal unit <span class="citation">(Getis and Ord <a href="#ref-getis+ord:92">1992</a>; Anselin <a href="#ref-anselin:95">1995</a>)</span>.</p>
</div>
<div id="spatial-weight-matrices" class="section level2">
<h2><span class="header-section-number">14.2</span> Spatial weight matrices</h2>
<p>Handling spatial autocorrelation using relationships to neighbours on a graph takes the graph as given, chosen by the analyst. This differs from the geostatistical approach in which the analyst chooses the binning of the empirical variogram and function used, and then the way the fitted variogram is fitted. Both involve a priori choices, but represent the underlying correlation in different ways <span class="citation">(Wall <a href="#ref-wall:04">2004</a>)</span>. In Bavaud <span class="citation">(<a href="#ref-bavaud:98">1998</a>)</span> and work citing his contribution, attempts have been made to place graph-based neighbours in a broader context.</p>
<p>One issue arising in the creation of objects representing neighbourhood relationships is that of no-neighbour areal units <span class="citation">(Bivand and Portnov <a href="#ref-bivand+portnov:04">2004</a>)</span>. Islands or units separated by rivers may not be recognised as neighbours when the units have areal support and when using topological relationships such as shared boundaries. In some settings, for example <code>mrf</code> (Markov Random Field) terms in <code>mgcv::gam()</code> and similar model fitting functions that require undirected connected graphs, a requirement is violated when there are disconnected subgraphs.</p>
<p>No-neighbour observations can also occur when a distance threshold is used between points, where the threshold is smaller than the maximum nearest neighbour distance. Shared boundary contiguities are not affected by using geographical, unprojected coordinates, but all point-based approaches use distance in one way or another, and need to calculate distances in an appropriate way.</p>
<p>The <strong>spdep</strong> package provides an <code>nb</code> class for neighbours, a list of length equal to the number of observations, with integer vector components. No-neighbours are encoded as an integer vector with a single element <code>0L</code>, and observations with neighbours as sorted integer vectors containing values in <code>1L:n</code> pointing to the neighbouring observations. This is a typical row-oriented sparse representation of neighbours. <strong>spdep</strong> provides many ways of constructing <code>nb</code> objects, and the representation and construction functions are widely used in other packages.</p>
<p><strong>spdep</strong> builds on the <code>nb</code> representation (undirected or directed graphs) with the <code>listw</code> object, a list with three components, an <code>nb</code> object, a matching list of numerical weights, and a single element character vector containing the single letter name of the way in which the weights were calculated. The most frequently used approach in the social sciences is calculating weights by row standardization, so that all the non-zero weights for one observation will be the inverse of the cardinality of its set of neighbours (<code>1/card(nb[[i]])</code>).</p>
<p>We will be using election data from the 2015 Polish Presidential election in this chapter, with 2495 municipalities and Warsaw boroughs, and complete count data from polling stations aggregated to these areal units. The data are an <strong>sf</strong> <code>sf</code> object:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb242-1" title="1"><span class="kw">library</span>(sf)</a></code></pre></div>
<div class="sourceCode" id="cb243"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb243-1" title="1"><span class="kw">data</span>(pol_pres15, <span class="dt">package=</span><span class="st">&quot;spDataLarge&quot;</span>)</a>
<a class="sourceLine" id="cb243-2" title="2"><span class="kw">head</span>(pol_pres15[, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">6</span>)])</a></code></pre></div>
<pre><code># Simple feature collection with 6 features and 3 fields
# geometry type:  MULTIPOLYGON
# dimension:      XY
# bbox:           xmin: 235000 ymin: 367000 xmax: 281000 ymax: 413000
# projected CRS:  ETRS89 / Poland CS92
#    TERYT                name       types                       geometry
# 1 020101         BOLESŁAWIEC       Urban MULTIPOLYGON (((261089 3855...
# 2 020102         BOLESŁAWIEC       Rural MULTIPOLYGON (((254150 3837...
# 3 020103            GROMADKA       Rural MULTIPOLYGON (((275346 3846...
# 4 020104        NOWOGRODZIEC Urban/rural MULTIPOLYGON (((251770 3770...
# 5 020105          OSIECZNICA       Rural MULTIPOLYGON (((263424 4060...
# 6 020106 WARTA BOLESŁAWIECKA       Rural MULTIPOLYGON (((267031 3870...</code></pre>
<div class="sourceCode" id="cb245"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb245-1" title="1"><span class="kw">library</span>(tmap)</a>
<a class="sourceLine" id="cb245-2" title="2"><span class="kw">tm_shape</span>(pol_pres15) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="st">&quot;types&quot;</span>)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:plotpolpres15"></span>
<img src="sds_files/figure-html/plotpolpres15-1.png" alt="Polish municipality types 2015" width="100%" />
<p class="caption">
Figure 14.1: Polish municipality types 2015
</p>
</div>
<p>Between early 2002 and April 2019, <strong>spdep</strong> contained functions for constructing and handling neighbour and spatial weights objects, tests for spatial autocorrelation, and model fitting functions. The latter have been split out into <strong>spatialreg</strong>, and will be discussed in the next chapter. <strong>spdep</strong> now accommodates objects represented using <strong>sf</strong> classes and <strong>sp</strong> classes directly, going beyond the explorations made in <a href="https://cran.r-project.org/web/packages/spdep/vignettes/nb_sf.html">this vignette</a>.</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb246-1" title="1"><span class="kw">library</span>(spdep)</a></code></pre></div>
<pre><code># Loading required package: sp</code></pre>
<pre><code># Loading required package: spData</code></pre>
<div id="contiguous-neighbours" class="section level3">
<h3><span class="header-section-number">14.2.1</span> Contiguous neighbours</h3>
<p>The <code>poly2nb()</code> function in <strong>spdep</strong> takes the boundary points making up the polygon boundaries in the object passed as the <code>pl=</code> argument, and for each observation checks whether at least one (<code>queen=TRUE</code>, default), or at least two (rook, <code>queen=FALSE</code>) points are within <code>snap=</code> distance units of each other. The distances are planar in the raw coordinate units, ignoring geographical projections. Once the required number of sufficiently close points is found, the search is stopped.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb249-1" title="1"><span class="kw">args</span>(poly2nb)</a></code></pre></div>
<pre><code># function (pl, row.names = NULL, snap = sqrt(.Machine$double.eps), 
#     queen = TRUE, useC = TRUE, foundInBox = NULL) 
# NULL</code></pre>
<p>The geometry column should be either of class <code>"sfc_MULTIPOLYGON"</code> or <code>"sfc_POLYGON"</code>, not <code>"sfc_GEOMETRY"</code>; if need be cast to <code>"MULTIPOLYGON"</code> if there are mixed <code>"POLYGON"</code> and <code>"MULTIPOLYGON"</code> objects.</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb251-1" title="1"><span class="kw">class</span>(<span class="kw">st_geometry</span>(pol_pres15))</a></code></pre></div>
<pre><code># [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot;</code></pre>
<div class="sourceCode" id="cb253"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb253-1" title="1"><span class="kw">table</span>(<span class="kw">sapply</span>(<span class="kw">st_geometry</span>(pol_pres15), <span class="cf">function</span>(x) <span class="kw">class</span>(x)[<span class="dv">2</span>]))</a></code></pre></div>
<pre><code># 
# MULTIPOLYGON 
#         2495</code></pre>
<div class="sourceCode" id="cb255"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb255-1" title="1"><span class="kw">system.time</span>(nb_q &lt;-<span class="st"> </span><span class="kw">poly2nb</span>(pol_pres15, <span class="dt">queen=</span><span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>#    user  system elapsed 
#   1.144   0.004   1.149</code></pre>
<div class="sourceCode" id="cb257"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb257-1" title="1">nb_q</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 14242 
# Percentage nonzero weights: 0.229 
# Average number of links: 5.71</code></pre>
<p>The <strong>rgeos</strong> <code>gUnarySTRtreeQuery()</code> function also reduces polygons to their boundary points before searching for overlapping “envelopes”, the bounding boxes of the derived multi-point objects. Here, pre-finding candidate contiguous neighbours only shaves off a little run time, but may be helpful with larger objects.</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb259-1" title="1"><span class="kw">system.time</span>({</a>
<a class="sourceLine" id="cb259-2" title="2">  fB &lt;-<span class="st"> </span>rgeos<span class="op">::</span><span class="kw">gUnarySTRtreeQuery</span>(<span class="kw">as</span>(pol_pres15, <span class="st">&quot;Spatial&quot;</span>))</a>
<a class="sourceLine" id="cb259-3" title="3">  nb_q1 &lt;-<span class="st"> </span><span class="kw">poly2nb</span>(pol_pres15, <span class="dt">queen=</span><span class="ot">TRUE</span>, <span class="dt">foundInBox=</span>fB)</a>
<a class="sourceLine" id="cb259-4" title="4">})</a></code></pre></div>
<pre><code># Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj
# = prefer_proj): Discarded datum Unknown based on GRS80 ellipsoid in Proj4
# definition</code></pre>
<pre><code># Warning in showSRID(SRS_string, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj
# = prefer_proj): Discarded datum European Terrestrial Reference System 1989 in
# Proj4 definition</code></pre>
<pre><code>#    user  system elapsed 
#   0.851   0.000   0.852</code></pre>
<div class="sourceCode" id="cb263"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb263-1" title="1"><span class="kw">all.equal</span>(nb_q, nb_q1, <span class="dt">check.attributes=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>We might consider using the contiguity of the polygon boundaries, the fifth element of the DE-9IM vector, setting the first element to FALSE, to find Queen neighbours using GEOS functions in <strong>sf</strong>, but it takes longer than simply treating the boundaries as points:</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb265-1" title="1">st_queen &lt;-<span class="st"> </span><span class="cf">function</span>(a, <span class="dt">b =</span> a) <span class="kw">st_relate</span>(a, b, <span class="dt">pattern =</span> <span class="st">&quot;F***T****&quot;</span>)</a>
<a class="sourceLine" id="cb265-2" title="2">as.nb.sgbp &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {</a>
<a class="sourceLine" id="cb265-3" title="3">  attrs &lt;-<span class="st"> </span><span class="kw">attributes</span>(x)</a>
<a class="sourceLine" id="cb265-4" title="4">  x &lt;-<span class="st"> </span><span class="kw">lapply</span>(x, <span class="cf">function</span>(i) { <span class="cf">if</span>(<span class="kw">length</span>(i) <span class="op">==</span><span class="st"> </span>0L) 0L <span class="cf">else</span> i } )</a>
<a class="sourceLine" id="cb265-5" title="5">  <span class="kw">attributes</span>(x) &lt;-<span class="st"> </span>attrs</a>
<a class="sourceLine" id="cb265-6" title="6">  <span class="kw">class</span>(x) &lt;-<span class="st"> &quot;nb&quot;</span></a>
<a class="sourceLine" id="cb265-7" title="7">  x</a>
<a class="sourceLine" id="cb265-8" title="8">}</a>
<a class="sourceLine" id="cb265-9" title="9"><span class="kw">system.time</span>(nb_sf_q &lt;-<span class="st"> </span><span class="kw">as.nb.sgbp</span>(<span class="kw">st_queen</span>(pol_pres15)))</a></code></pre></div>
<pre><code>#    user  system elapsed 
#    1.65    0.00    1.65</code></pre>
<div class="sourceCode" id="cb267"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb267-1" title="1"><span class="kw">all.equal</span>(nb_q, nb_sf_q, <span class="dt">check.attributes=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>The same effect as using <code>rgeos::gUnarySTRtreeQuery</code> can be obtained without the overhead of converting to the equivalent <strong>sp</strong> class and using <strong>rgeos</strong> to make the equivalent tree search using <strong>sf</strong>, by finding intersecting bounding boxes, removing self-intersections and duplicate intersections (contiguities are by definition symmetric, if <code>i</code> is a neighbour of <code>j</code>, then <code>j</code> is a neighbour of <code>i</code>).</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb269-1" title="1"><span class="kw">system.time</span>({</a>
<a class="sourceLine" id="cb269-2" title="2">  fB1 &lt;-<span class="st"> </span><span class="kw">st_intersects</span>(<span class="kw">st_as_sfc</span>(<span class="kw">lapply</span>(<span class="kw">st_geometry</span>(pol_pres15), <span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb269-3" title="3">    <span class="kw">st_as_sfc</span>(<span class="kw">st_bbox</span>(x))[[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb269-4" title="4">  })))</a>
<a class="sourceLine" id="cb269-5" title="5">  fB1a &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="kw">seq_along</span>(fB1), <span class="cf">function</span>(i) fB1[[i]][fB1[[i]] <span class="op">&gt;</span><span class="st"> </span>i])</a>
<a class="sourceLine" id="cb269-6" title="6">  fB1a &lt;-<span class="st"> </span>fB1a[<span class="op">-</span><span class="kw">length</span>(fB1a)]</a>
<a class="sourceLine" id="cb269-7" title="7">  nb_sf_q1 &lt;-<span class="st"> </span><span class="kw">poly2nb</span>(pol_pres15, <span class="dt">queen=</span><span class="ot">TRUE</span>, <span class="dt">foundInBox=</span>fB1a)</a>
<a class="sourceLine" id="cb269-8" title="8">})</a></code></pre></div>
<pre><code>#    user  system elapsed 
#   0.831   0.000   0.831</code></pre>
<div class="sourceCode" id="cb271"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb271-1" title="1"><span class="kw">all.equal</span>(nb_q, nb_sf_q1, <span class="dt">check.attributes=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>Much of the work involved in finding contiguous neighbours is spent on finding candidate neighbours with intersecting bounding boxes. Note that <code>nb</code> objects record both symmetric neighbour relationships, because these objects admit asymmetric relationships as well, but these duplications are not needed for object construction.</p>
<p>Most of the <strong>spdep</strong> functions for constructing neighbour objects take a <code>row.names=</code> argument, the value of which is stored as a <code>region.id</code> attribute. If not given, the values are taken from <code>row.names()</code> of the first argument. These can be used to check that the neighbours object is in the same order as data. If <code>nb</code> objects are subsetted, the indices change to continue to be within <code>1:length(subsetted_nb)</code>, but the <code>region.id</code> attribute values point back to the object from which it was constructed.</p>
<p>We can also check that this undirected graph is connected using the <code>n.comp.nb()</code> function:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb273-1" title="1"><span class="kw">n.comp.nb</span>(nb_q)<span class="op">$</span>nc</a></code></pre></div>
<pre><code># [1] 1</code></pre>
<p>Neighbour objects may be exported and imported in GAL format for exchange with other software, using <code>write.nb.gal()</code> and <code>read.gal()</code>:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb275-1" title="1">tf &lt;-<span class="st"> </span><span class="kw">tempfile</span>(<span class="dt">fileext=</span><span class="st">&quot;.gal&quot;</span>)</a>
<a class="sourceLine" id="cb275-2" title="2"><span class="kw">write.nb.gal</span>(nb_q, tf)</a></code></pre></div>
<p>Using <strong>reticulate</strong>, it is possible to interoperate with the PySAL family of Python packages, first <strong>libpysal</strong> providing the basic weights handling infrastructure. As we can see, the percentage of non-zero neighbours is the same in both software systems.</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb276-1" title="1"><span class="kw">library</span>(reticulate)</a>
<a class="sourceLine" id="cb276-2" title="2"><span class="kw">use_python</span>(<span class="dt">python=</span><span class="st">&#39;/usr/bin/python3&#39;</span>)</a>
<a class="sourceLine" id="cb276-3" title="3">np &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;numpy&quot;</span>)</a>
<a class="sourceLine" id="cb276-4" title="4">libpysal &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;libpysal&quot;</span>)</a>
<a class="sourceLine" id="cb276-5" title="5">nb_gal_ps &lt;-<span class="st"> </span>libpysal<span class="op">$</span>io<span class="op">$</span><span class="kw">open</span>(tf)<span class="op">$</span><span class="kw">read</span>()</a>
<a class="sourceLine" id="cb276-6" title="6">nb_gal_ps<span class="op">$</span>pct_nonzero</a></code></pre></div>
<pre><code># [1] 0.229</code></pre>
</div>
<div id="graph-based-neighbours" class="section level3">
<h3><span class="header-section-number">14.2.2</span> Graph-based neighbours</h3>
<p>If areal units are an appropriate representation, but only points have been observed, contiguity relationships may be approximated using graph-based neighbours. In this case, the imputed boundaries tesselate the plane such that points closer to one observation than any other fall within its polygon. The simplest form is by using triangulation, here using the <code>deldir()</code> function in the <strong>deldir</strong> package. Because the function returns from and to identifiers, it is easy to construct a long representation of a <code>listw</code> object, as used in the S-Plus SpatialStats module and the <code>sn2listw()</code> function internally to construct an <code>nb</code> object (ragged wide representation). Alternatives often fail to return sufficient information to permit the neighbours to be identified.</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb278-1" title="1"><span class="kw">args</span>(tri2nb)</a></code></pre></div>
<pre><code># function (coords, row.names = NULL) 
# NULL</code></pre>
<p>The <code>soi.graph()</code> function takes triangulated neighbours and prunes off neighbour relationships represented by unusually long edges, especially around the convex hull, but may render the output object asymmetric. Other graph-based approaches include <code>relativeneigh()</code> and <code>gabrielneigh()</code>.</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb280-1" title="1"><span class="kw">args</span>(soi.graph)</a></code></pre></div>
<pre><code># function (tri.nb, coords, quadsegs = 10) 
# NULL</code></pre>
<p>The output of these functions is then converted to the <code>nb</code> representation using <code>graph2nb()</code>, with the possible use of the <code>sym=</code> argument to coerce to symmetry.</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb282-1" title="1"><span class="kw">args</span>(graph2nb)</a></code></pre></div>
<pre><code># function (gob, row.names = NULL, sym = FALSE) 
# NULL</code></pre>
<p>We take the centroids of the largest component polygon for each observation as the point representation; population-weighted centroids might have been a better choice if they were available:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb284-1" title="1">coords &lt;-<span class="st"> </span><span class="kw">st_centroid</span>(<span class="kw">st_geometry</span>(pol_pres15), <span class="dt">of_largest_polygon=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb284-2" title="2"><span class="kw">suppressMessages</span>(nb_tri &lt;-<span class="st"> </span><span class="kw">tri2nb</span>(coords))</a>
<a class="sourceLine" id="cb284-3" title="3">nb_tri</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 14930 
# Percentage nonzero weights: 0.24 
# Average number of links: 5.98</code></pre>
<p>The average number of neighbours is similar to the Queen boundary contiguity case, but if we look at the distribution of edge lengths using <code>nbdists()</code>, we can see that although the upper quartile is about 15 km, the maximum is almost 300 km, an edge along much of one side of the convex hull. The short minimum distance is also of interest, as many centroids of urban municipalities are very close to the centroids of their surrounding rural counterparts.</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb286-1" title="1"><span class="kw">summary</span>(<span class="kw">unlist</span>(<span class="kw">nbdists</span>(nb_tri, coords)))</a></code></pre></div>
<pre><code>#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#     247    9847   12151   13485   14994  296974</code></pre>
<p>Using the <code>card()</code> function to return a vector of neighbour counts by observation, we see that there are relatively many such surrounded urban municipalities with only one neighbour.</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb288-1" title="1"><span class="kw">table</span>(pol_pres15<span class="op">$</span>types, <span class="kw">card</span>(nb_q))</a></code></pre></div>
<pre><code>#                 
#                    1   2   3   4   5   6   7   8   9  10  11  12  13
#   Rural            0   5  41 183 413 465 271 105  55  16   8   0   1
#   Urban           70  58  55  34  22  25  15  13   6   0   3   1   1
#   Urban/rural      2   2  15  36 109 173 162  80  23   8   1   0   0
#   Warsaw Borough   0   0   0   2   3   6   4   3   0   0   0   0   0</code></pre>
<p>For obvious reasons, triangulated units seldom have few neighbours, not only because they are located on the convex hull:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb290-1" title="1"><span class="kw">table</span>(pol_pres15<span class="op">$</span>types, <span class="kw">card</span>(nb_tri))</a></code></pre></div>
<pre><code>#                 
#                    3   4   5   6   7   8   9  10  11
#   Rural            2  57 455 632 328  75  12   2   0
#   Urban            1  41 118  93  33  11   5   1   0
#   Urban/rural      0  22 116 251 158  52  10   0   2
#   Warsaw Borough   0   1   5   6   5   1   0   0   0</code></pre>
<p>Triangulated neighbours also yield a connected graph:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb292-1" title="1"><span class="kw">n.comp.nb</span>(nb_tri)<span class="op">$</span>nc</a></code></pre></div>
<pre><code># [1] 1</code></pre>
<p>The sphere of influence graph trims a neighbour object such as <code>nb_tri</code> to remove edges that seem long in relation to typical neighbours <span class="citation">(Avis and Horton <a href="#ref-avis+horton:1985">1985</a>)</span>.</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb294-1" title="1">nb_soi &lt;-<span class="st"> </span><span class="kw">graph2nb</span>(<span class="kw">soi.graph</span>(nb_tri, coords))</a>
<a class="sourceLine" id="cb294-2" title="2">nb_soi</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 12792 
# Percentage nonzero weights: 0.205 
# Average number of links: 5.13</code></pre>
<p>Unpicking the triangulated neighbours does however remove the connected character of the underlying graph:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb296-1" title="1">n_comp &lt;-<span class="st"> </span><span class="kw">n.comp.nb</span>(nb_soi)</a>
<a class="sourceLine" id="cb296-2" title="2">n_comp<span class="op">$</span>nc</a></code></pre></div>
<pre><code># [1] 16</code></pre>
<p>The SoI algorithm has stripped out longer edges leading to urban and rural municipalities where their centroids are very close to each other, giving 15 pairs of neighours unconnected to the main graph:</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb298-1" title="1"><span class="kw">table</span>(n_comp<span class="op">$</span>comp.id)</a></code></pre></div>
<pre><code># 
#    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 
# 2465    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2</code></pre>
<p>The largest length edges along the convex hull have been removed, but “holes” have appeared where the unconnected pairs of neighbours have appeared. The differences between <code>nb_tri</code> and <code>nb_soi</code> are shown in orange in the figure.</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb300-1" title="1"><span class="kw">summary</span>(<span class="kw">unlist</span>(<span class="kw">nbdists</span>(nb_soi, coords)))</a></code></pre></div>
<pre><code>#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#     247    9507   11651   11880   14142   30005</code></pre>
<div class="sourceCode" id="cb302"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb302-1" title="1">opar &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)<span class="op">+</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb302-2" title="2"><span class="kw">plot</span>(<span class="kw">st_geometry</span>(pol_pres15), <span class="dt">border=</span><span class="st">&quot;grey&quot;</span>, <span class="dt">lwd=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb302-3" title="3"><span class="kw">plot</span>(nb_soi, <span class="dt">coords=</span><span class="kw">st_coordinates</span>(coords), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">points=</span><span class="ot">FALSE</span>, <span class="dt">lwd=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb302-4" title="4"><span class="kw">plot</span>(<span class="kw">diffnb</span>(nb_tri, nb_soi), <span class="dt">coords=</span><span class="kw">st_coordinates</span>(coords), <span class="dt">col=</span><span class="st">&quot;orange&quot;</span>,</a>
<a class="sourceLine" id="cb302-5" title="5">     <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">points=</span><span class="ot">FALSE</span>, <span class="dt">lwd=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb302-6" title="6"><span class="kw">par</span>(opar)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:plotnbdiff"></span>
<img src="sds_files/figure-html/plotnbdiff-1.png" alt="Triangulated (orange + black) and sphere of influence neighbours (black)" width="100%" />
<p class="caption">
Figure 14.2: Triangulated (orange + black) and sphere of influence neighbours (black)
</p>
</div>
</div>
<div id="distance-based-neighbours" class="section level3">
<h3><span class="header-section-number">14.2.3</span> Distance-based neighbours</h3>
<p>Distance-based neighbours can be constructed using <code>dnearneigh()</code>, with a distance band with lower <code>d1=</code> and upper <code>d2=</code> bounds controlled by the <code>bounds=</code> argument. If unprojected coordinates are used and either specified in the coordinates object <code>x</code> or with <code>x</code> as a two column matrix and <code>longlat=TRUE</code>, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb303-1" title="1"><span class="kw">args</span>(dnearneigh)</a></code></pre></div>
<pre><code># function (x, d1, d2, row.names = NULL, longlat = NULL, bounds = c(&quot;GT&quot;, 
#     &quot;LE&quot;)) 
# NULL</code></pre>
<p>The <code>knearneigh()</code> function for <span class="math inline">\(k\)</span>-nearest neighbours returns a <code>knn</code> object, converted to an <code>nb</code> object using <code>knn2nb()</code>. It can also use great circle distances, not least because nearest neighbours may differ when uprojected coordinates are treated as planar. <code>k=</code> should be a small number. For projected coordinates, the <strong>RANN</strong> package is used to compute nearest neighbours more efficiently. Note that <code>nb</code> objects constructed in this way are most unlikely to be symmetric, hence <code>knn2nb()</code> has a <code>sym=</code> argument to permit the imposition of symmetry, which will mean that all units have at least <code>k=</code> neighbours, not that all units will have exactly <code>k=</code> neighbours.</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb305-1" title="1"><span class="kw">args</span>(knearneigh)</a></code></pre></div>
<pre><code># function (x, k = 1, longlat = NULL, RANN = TRUE) 
# NULL</code></pre>
<div class="sourceCode" id="cb307"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb307-1" title="1"><span class="kw">args</span>(knn2nb)</a></code></pre></div>
<pre><code># function (knn, row.names = NULL, sym = FALSE) 
# NULL</code></pre>
<p>The <code>nbdists()</code> function returns the length of neighbour relationship edges in the units of the coordinates if the coordinates are projected, in km otherwise.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb309-1" title="1"><span class="kw">args</span>(nbdists)</a></code></pre></div>
<pre><code># function (nb, coords, longlat = NULL) 
# NULL</code></pre>
<p>In order to set the upper limit for distance bands, one may first find the maximum first nearest neighbour distance, using <code>unlist()</code> to remove the list structure of the returned object.</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb311-1" title="1">k1 &lt;-<span class="st"> </span><span class="kw">knn2nb</span>(<span class="kw">knearneigh</span>(coords))</a>
<a class="sourceLine" id="cb311-2" title="2">k1dists &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">nbdists</span>(k1, coords))</a>
<a class="sourceLine" id="cb311-3" title="3"><span class="kw">summary</span>(k1dists)</a></code></pre></div>
<pre><code>#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#     247    6663    8538    8275   10124   17979</code></pre>
<p>Here the largest first nearest neighbour distance is just under 18 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb313-1" title="1">nb_d18 &lt;-<span class="st"> </span><span class="kw">dnearneigh</span>(coords, <span class="dv">0</span>, <span class="dv">18000</span>)</a>
<a class="sourceLine" id="cb313-2" title="2">nb_d18</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 20358 
# Percentage nonzero weights: 0.327 
# Average number of links: 8.16</code></pre>
<p>However, even though there are no no-neighbour observations (their presence is reported by the print method for <code>nb</code> objects), the graph is not connected, as a pair of observations are each others’ only neighbours.</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb315-1" title="1">n_comp &lt;-<span class="st"> </span><span class="kw">n.comp.nb</span>(nb_d18)</a>
<a class="sourceLine" id="cb315-2" title="2">n_comp<span class="op">$</span>nc</a></code></pre></div>
<pre><code># [1] 2</code></pre>
<div class="sourceCode" id="cb317"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb317-1" title="1"><span class="kw">table</span>(n_comp<span class="op">$</span>comp.id)</a></code></pre></div>
<pre><code># 
#    1    2 
# 2493    2</code></pre>
<p>Adding 300 m to the threshold gives us a neighbour object with no no-neighbour units, and all units can be reached from all others across the graph.</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb319-1" title="1">nb_d183 &lt;-<span class="st"> </span><span class="kw">dnearneigh</span>(coords, <span class="dv">0</span>, <span class="dv">18300</span>)</a>
<a class="sourceLine" id="cb319-2" title="2">nb_d183</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 21086 
# Percentage nonzero weights: 0.339 
# Average number of links: 8.45</code></pre>
<div class="sourceCode" id="cb321"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb321-1" title="1">n_comp &lt;-<span class="st"> </span><span class="kw">n.comp.nb</span>(nb_d183)</a>
<a class="sourceLine" id="cb321-2" title="2">n_comp<span class="op">$</span>nc</a></code></pre></div>
<pre><code># [1] 1</code></pre>
<p>One characteristic of distance-based neighbours is that more densely settled areas, with units which are smaller in terms of area (Warsaw boroughs are much smaller on average, but have almost 30 neighbours). Having many neighbours smoothes the neighbour relationship across more neighbours:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb323-1" title="1"><span class="kw">table</span>(pol_pres15<span class="op">$</span>types, <span class="kw">card</span>(nb_d183))</a></code></pre></div>
<pre><code>#                 
#                    1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
#   Rural            5  18  51  87 117 156 193 227 222 166 114  62  43  29  21
#   Urban            3   6   9  12  28  27  29  21  35  30  20  12  17  11   5
#   Urban/rural     10  30  28  47  55  62  94  89  60  45  35  10  15   7   6
#   Warsaw Borough   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
#                 
#                   16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
#   Rural           12  13   9   7   7   0   1   0   1   2   0   0   0   0   0
#   Urban            3   8   5  12   5   1   0   0   2   0   1   1   0   0   0
#   Urban/rural      3   7   3   1   1   1   0   2   0   0   0   0   0   0   0
#   Warsaw Borough   0   0   0   0   0   0   0   0   1   2   2   5   3   1   2
#                 
#                   31
#   Rural            0
#   Urban            0
#   Urban/rural      0
#   Warsaw Borough   2</code></pre>
<div class="sourceCode" id="cb325"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb325-1" title="1">arha &lt;-<span class="st"> </span>units<span class="op">::</span><span class="kw">set_units</span>(<span class="kw">st_area</span>(pol_pres15), hectare)</a>
<a class="sourceLine" id="cb325-2" title="2"><span class="kw">aggregate</span>(arha, <span class="kw">list</span>(pol_pres15<span class="op">$</span>types), mean)</a></code></pre></div>
<pre><code>#          Group.1               x
# 1          Rural 12500 [hectare]
# 2          Urban  4497 [hectare]
# 3    Urban/rural 16850 [hectare]
# 4 Warsaw Borough  2886 [hectare]</code></pre>
<p>For use later, we also construct a neighbour object with no-neighbour units, using a threshold of 16 km:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb327-1" title="1">nb_d16 &lt;-<span class="st"> </span><span class="kw">dnearneigh</span>(coords, <span class="dv">0</span>, <span class="dv">16000</span>)</a>
<a class="sourceLine" id="cb327-2" title="2">nb_d16</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 15850 
# Percentage nonzero weights: 0.255 
# Average number of links: 6.35 
# 7 regions with no links:
# 569 1371 1522 2374 2385 2473 2474</code></pre>
<p>It is possible to control the numbers of neighbours directly using <span class="math inline">\(k\)</span>-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry:</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb329-1" title="1">knn_k6 &lt;-<span class="st"> </span><span class="kw">knearneigh</span>(coords, <span class="dt">k=</span><span class="dv">6</span>)</a>
<a class="sourceLine" id="cb329-2" title="2"><span class="kw">knn2nb</span>(knn_k6)</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 14970 
# Percentage nonzero weights: 0.24 
# Average number of links: 6 
# Non-symmetric neighbours list</code></pre>
<div class="sourceCode" id="cb331"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb331-1" title="1">nb_k6s &lt;-<span class="st"> </span><span class="kw">knn2nb</span>(knn_k6, <span class="dt">sym=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb331-2" title="2">nb_k6s</a></code></pre></div>
<pre><code># Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 16810 
# Percentage nonzero weights: 0.27 
# Average number of links: 6.74</code></pre>
<p>Here the size of <code>k=</code> is sufficient to ensure connectedness, although the graph is not planar as edges cross at locations other than nodes, which is not the case for contiguous or graph-based neighbours.</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb333-1" title="1">n_comp &lt;-<span class="st"> </span><span class="kw">n.comp.nb</span>(nb_k6s)</a>
<a class="sourceLine" id="cb333-2" title="2">n_comp<span class="op">$</span>nc</a></code></pre></div>
<pre><code># [1] 1</code></pre>
</div>
<div id="weights-specification" class="section level3">
<h3><span class="header-section-number">14.2.4</span> Weights specification</h3>
<p>Once neighbour objects are available, further choices need to made in specifying the weights objects. The <code>nb2listw()</code> function is used to create a <code>listw</code> weights object with an <code>nb</code> object, a matching list of weights vectors, and a style specification. Because handling no-neighbour observations now begins to matter, the <code>zero.policy=</code> argument is introduced. By default, this is <code>FALSE</code>, indicating that no-neighbour observations will cause an error, as the spatially lagged value for an observation with no neighbours is not available. By convention, zero is substituted for the lagged value, as the cross product of a vector of zero-valued weights and a data vector, hence the name of <code>zero.policy</code>.</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb335-1" title="1"><span class="kw">args</span>(nb2listw)</a></code></pre></div>
<pre><code># function (neighbours, glist = NULL, style = &quot;W&quot;, zero.policy = NULL) 
# NULL</code></pre>
<p>We will be using the helper function <code>spweights.constants()</code> below to show some consequences of varing style choices. It returns constants for a <code>listw</code> object, <span class="math inline">\(n\)</span> is the number of observations, <code>n1</code> to <code>n3</code> are <span class="math inline">\(n-1, \ldots\)</span>, <code>nn</code> is <span class="math inline">\(n^2\)</span> and <span class="math inline">\(S_0\)</span>, <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> are constants, <span class="math inline">\(S_0\)</span> being the sum of the weights. There is a full discussion of the constants in Bivand and Wong <span class="citation">(<a href="#ref-Bivand2018">2018</a>)</span>.</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb337-1" title="1"><span class="kw">args</span>(spweights.constants)</a></code></pre></div>
<pre><code># function (listw, zero.policy = NULL, adjust.n = TRUE) 
# NULL</code></pre>
<p>The <code>"B"</code> binary style gives a weight of unity to each neighbour relationship, and typically upweights units with no boundaries on the edge of the study area.</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb339-1" title="1">lw_q_B &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(nb_q, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>)</a>
<a class="sourceLine" id="cb339-2" title="2"><span class="kw">unlist</span>(<span class="kw">spweights.constants</span>(lw_q_B))</a></code></pre></div>
<pre><code>#       n      n1      n2      n3      nn      S0      S1      S2 
#    2495    2494    2493    2492 6225025   14242   28484  357280</code></pre>
<p>The <code>"W"</code> row-standardized style upweights units around the edge of the study area that necessarily have fewer neighbours. This style first gives a weight of unity to each neighbour relationship, then divides these weights by the per unit sums of weights. Naturally this leads to division by zero where there are no neighbours, a not-a-number result, unless the chosen policy is to permit no-neighbour observations. We can see that <span class="math inline">\(S_0\)</span> is now equal to <span class="math inline">\(n\)</span>.</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb341-1" title="1">lw_q_W &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(nb_q, <span class="dt">style=</span><span class="st">&quot;W&quot;</span>)</a>
<a class="sourceLine" id="cb341-2" title="2"><span class="kw">unlist</span>(<span class="kw">spweights.constants</span>(lw_q_W))[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">6</span><span class="op">:</span><span class="dv">8</span>)]</a></code></pre></div>
<pre><code>#     n    S0    S1    S2 
#  2495  2495   958 10406</code></pre>
<p>An <code>"S"</code> style attempts to balance the tendencies of the <code>"B"</code> and <code>"W"</code> styles to downweight or upweight units on the edge of the study area <span class="citation">(Tiefelsdorf, Griffith, and Boots <a href="#ref-tiefelsdorfatal:99">1999</a>)</span>. Other styles are variants of <code>"B"</code>, <code>"C"</code> sets the weights such that they sum (<span class="math inline">\(S_0\)</span>) to <span class="math inline">\(n\)</span>, and <code>"U"</code> to unity. The main change in the <code>"S"</code> style is to <span class="math inline">\(S_1\)</span> for this configuration of contiguities.</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb343-1" title="1">lw_q_S &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(nb_q, <span class="dt">style=</span><span class="st">&quot;S&quot;</span>)</a>
<a class="sourceLine" id="cb343-2" title="2"><span class="kw">unlist</span>(<span class="kw">spweights.constants</span>(lw_q_S))[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">6</span><span class="op">:</span><span class="dv">8</span>)]</a></code></pre></div>
<pre><code>#     n    S0    S1    S2 
#  2495  2495   886 10646</code></pre>
<p>Inverse distance weights are used in a number of scientific fields. Some use dense inverse distance matrices, but many of the inverse distances are close to zero, so have little practical contribution, especially as the spatial process matrix is itself dense. Inverse distance weights may be constructed by taking the lengths of edges, changing units to avoid most weights being too large or small (here from m to km), taking the inverse, and passing through the <code>glist=</code> argument to <code>nb2listw()</code>:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb345-1" title="1">gwts &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="kw">nbdists</span>(nb_d183, coords), <span class="cf">function</span>(x) <span class="dv">1</span><span class="op">/</span>(x<span class="op">/</span><span class="dv">1000</span>))</a>
<a class="sourceLine" id="cb345-2" title="2">lw_d183_idw_B &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(nb_d183, <span class="dt">glist=</span>gwts, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>)</a>
<a class="sourceLine" id="cb345-3" title="3"><span class="kw">unlist</span>(<span class="kw">spweights.constants</span>(lw_d183_idw_B))[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">6</span><span class="op">:</span><span class="dv">8</span>)]</a></code></pre></div>
<pre><code>#    n   S0   S1   S2 
# 2495 1841  534 7265</code></pre>
<p>No-neighbour handling is by default to prevent the construction of a weights object, making the analyst take a position on how to proceed.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb347-1" title="1"><span class="kw">try</span>(lw_d16_B &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(nb_d16, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>))</a></code></pre></div>
<pre><code># Error in nb2listw(nb_d16, style = &quot;B&quot;) : Empty neighbour sets found</code></pre>
<p>Use can be made of the <code>zero.policy=</code> argument to many functions used with <code>nb</code> and <code>listw</code> objects.</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb349-1" title="1">lw_d16_B &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(nb_d16, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb349-2" title="2"><span class="kw">unlist</span>(<span class="kw">spweights.constants</span>(lw_d16_B,  <span class="dt">zero.policy=</span><span class="ot">TRUE</span>))[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">6</span><span class="op">:</span><span class="dv">8</span>)]</a></code></pre></div>
<pre><code>#      n     S0     S1     S2 
#   2488  15850  31700 506480</code></pre>
<p>It is also possible to store the chosen zero policy for the running session using <code>set.ZeroPolicyOption()</code>; the function returns the value it held before being set. If the <code>zero.policy=</code> argument takes its default value of <code>NULL</code>, the stored option value is used, initialized to <code>FALSE</code> at the beginning of the session.</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb351-1" title="1">zO &lt;-<span class="st"> </span><span class="kw">set.ZeroPolicyOption</span>(<span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb351-2" title="2">lw_d16_B &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(nb_d16, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>)</a>
<a class="sourceLine" id="cb351-3" title="3"><span class="kw">unlist</span>(<span class="kw">spweights.constants</span>(lw_d16_B))[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">6</span><span class="op">:</span><span class="dv">8</span>)]</a></code></pre></div>
<pre><code>#      n     S0     S1     S2 
#   2488  15850  31700 506480</code></pre>
<div class="sourceCode" id="cb353"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb353-1" title="1"><span class="kw">invisible</span>(<span class="kw">set.ZeroPolicyOption</span>(zO))</a></code></pre></div>
<p>Note that by default the <code>adjust.n=</code> argument is set by default to <code>TRUE</code>, subtracting the count of no-neighbour observations from the observation count, so <span class="math inline">\(n\)</span> is smaller with possible consequences for inference. The complete count can be retrieved by changing the argument.</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb354-1" title="1"><span class="kw">unlist</span>(<span class="kw">spweights.constants</span>(lw_d16_B,  <span class="dt">zero.policy=</span><span class="ot">TRUE</span>, <span class="dt">adjust.n=</span><span class="ot">FALSE</span>))[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">6</span><span class="op">:</span><span class="dv">8</span>)]</a></code></pre></div>
<pre><code>#      n     S0     S1     S2 
#   2495  15850  31700 506480</code></pre>
</div>
</div>
<div id="measures-of-spatial-autocorrelation" class="section level2">
<h2><span class="header-section-number">14.3</span> Measures of spatial autocorrelation</h2>
<p>Measures of spatial autcorrelation unfortunately pick up other mis-specifications in the way that we model data <span class="citation">(Waller and Gotway <a href="#ref-WallerGotway:2004">2004</a>; McMillen <a href="#ref-McMillen:2003">2003</a>)</span>. For reference, Moran’s <span class="math inline">\(I\)</span> is given as <span class="citation">(Cliff and Ord <a href="#ref-cliff+ord:81">1981</a>, 17)</span>:</p>
<p><span class="math display">\[
I = \frac{n \sum_{(2)} w_{ij} z_i z_j}{S_0 \sum_{i=1}^{n} z_i^2}
\]</span>
where <span class="math inline">\(x_i, i=1, \ldots, n\)</span> are <span class="math inline">\(n\)</span> observations on the numeric variable of interest, <span class="math inline">\(z_i = x_i - \bar{x}\)</span>, <span class="math inline">\(\bar{x} = \sum_{i=1}^{n} x_i / n\)</span>, <span class="math inline">\(\sum_{(2)} = \stackrel{\sum_{i=1}^{n} \sum_{j=1}^{n}}{i \neq j}\)</span>, <span class="math inline">\(w_{ij}\)</span> are the spatial weights, and <span class="math inline">\(S_0 = \sum_{(2)} w_{ij}\)</span>.
First we test a random variable using the Moran test, here under the normality assumption (argument <code>randomisation=FALSE</code>, default <code>TRUE</code>):</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb356-1" title="1"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb356-2" title="2">x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">nrow</span>(pol_pres15))</a>
<a class="sourceLine" id="cb356-3" title="3">mt &lt;-<span class="st"> </span><span class="kw">moran.test</span>(x, lw_q_B, <span class="dt">randomisation=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<p>Inference is made on the statistic <span class="math inline">\(Z(I) = \frac{I - E(I)}{\sqrt{\mathrm{Var}(I)}}\)</span>, the z-value compared with the Normal distribution for <span class="math inline">\(E(I)\)</span> and <span class="math inline">\(\mathrm{Var}(I)\)</span> for the chosen assumptions; this <code>x</code> does not show spatial autocorrelation with these spatial weights:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb357-1" title="1">glance_htest &lt;-<span class="st"> </span><span class="cf">function</span>(ht) <span class="kw">c</span>(ht<span class="op">$</span>estimate, <span class="st">&quot;Std deviate&quot;</span>=<span class="kw">unname</span>(ht<span class="op">$</span>statistic), <span class="st">&quot;p.value=&quot;</span>=<span class="kw">unname</span>(ht<span class="op">$</span>p.value))</a>
<a class="sourceLine" id="cb357-2" title="2">broom_ok &lt;-<span class="st"> </span><span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb357-3" title="3"><span class="cf">if</span> (<span class="kw">names</span>(broom<span class="op">::</span><span class="kw">tidy</span>(mt))[<span class="dv">1</span>] <span class="op">==</span><span class="st"> &quot;Moran I statistic&quot;</span>) broom_ok &lt;-<span class="st"> </span><span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb357-4" title="4"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(mt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(mt)</a></code></pre></div>
<pre><code># Moran I statistic       Expectation          Variance       Std deviate 
#         -0.004772         -0.000401          0.000140         -0.369320 
#          p.value= 
#          0.644056</code></pre>
<p>The test however fails to detect a missing trend in the data as a missing variable problem, finding spatial autocorrelation instead:</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb359-1" title="1">beta &lt;-<span class="st"> </span><span class="fl">0.5e-02</span></a>
<a class="sourceLine" id="cb359-2" title="2">t &lt;-<span class="st"> </span><span class="kw">st_coordinates</span>(coords)[,<span class="dv">1</span>]<span class="op">/</span><span class="dv">1000</span></a>
<a class="sourceLine" id="cb359-3" title="3">x_t &lt;-<span class="st"> </span>x <span class="op">+</span><span class="st"> </span>beta<span class="op">*</span>t</a>
<a class="sourceLine" id="cb359-4" title="4">mt &lt;-<span class="st"> </span><span class="kw">moran.test</span>(x_t, lw_q_B, <span class="dt">randomisation=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb359-5" title="5"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(mt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(mt)</a></code></pre></div>
<pre><code># Moran I statistic       Expectation          Variance       Std deviate 
#          3.56e-01         -4.01e-04          1.40e-04          3.01e+01 
#          p.value= 
#         2.63e-199</code></pre>
<p>If we test the residuals of a linear model including the trend, the apparent spatial autocorrelation disappears:</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb361-1" title="1">lmt &lt;-<span class="st"> </span><span class="kw">lm.morantest</span>(<span class="kw">lm</span>(x_t <span class="op">~</span><span class="st"> </span>t), lw_q_B)</a>
<a class="sourceLine" id="cb361-2" title="2"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(lmt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(lmt)</a></code></pre></div>
<pre><code># Observed Moran I      Expectation         Variance      Std deviate 
#        -0.004777        -0.000789         0.000140        -0.337306 
#         p.value= 
#         0.632057</code></pre>
<p>A comparison of implementations of measures of spatial autocorrelation shows that a wide range of measures is available in R in a number of packages, chiefly in the <strong>spdep</strong> package, and that differences from other implementations can be attributed to design decisions <span class="citation">(Bivand and Wong <a href="#ref-Bivand2018">2018</a>)</span>. The <strong>spdep</strong> package also includes the only implementations of exact and Saddlepoint approximations to global and local Moran’s I for regression residuals <span class="citation">(Tiefelsdorf <a href="#ref-tiefelsdorf:02">2002</a>; Bivand, Müller, and Reder <a href="#ref-bivandetal:09">2009</a>)</span>.</p>
<div id="global-measures" class="section level3">
<h3><span class="header-section-number">14.3.1</span> Global measures</h3>
<p>We will begin by examining join count statistics, where <code>joincount.test()</code> takes a <code>factor</code> vector of values <code>fx=</code> and a <code>listw</code> object, and returns a list of <code>htest</code> (hypothesis test) objects defined in the <strong>stats</strong> package, one <code>htest</code> object for each level of the <code>fx=</code> argument. The observed counts are of neighbours with the same factor levels, known as same-colour joins.</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb363-1" title="1"><span class="kw">args</span>(joincount.test)</a></code></pre></div>
<pre><code># function (fx, listw, zero.policy = NULL, alternative = &quot;greater&quot;, 
#     sampling = &quot;nonfree&quot;, spChk = NULL, adjust.n = TRUE) 
# NULL</code></pre>
<p>The function takes an <code>alternative=</code> argument for hypothesis testing, a <code>sampling=</code> argument showing the basis for the construction of the variance of the measure, where the default <code>"nonfree"</code> choice corresponds to analytical permutation; the <code>spChk=</code> argument is retained for backward compatibility. For reference, the counts of factor levels for the type of municipality or Warsaw borough are:</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb365-1" title="1"><span class="kw">table</span>(pol_pres15<span class="op">$</span>types)</a></code></pre></div>
<pre><code># 
#          Rural          Urban    Urban/rural Warsaw Borough 
#           1563            303            611             18</code></pre>
<p>Since there are four levels, we re-arrange the list of <code>htest</code> objects to give a matrix of estimated results. The observed same-colour join counts are tabulated with their expectations based on the counts of levels of the input factor, so that few joins would be expected between for example Warsaw boroughs, because there are very few of them. The variance calculation uses the underlying constants of the chosen <code>listw</code> object and the counts of levels of the input factor. The z-value is obtained in the usual way by dividing the difference between the observed and expected join counts by the square root of the variance.</p>
<p>The global tests in <strong>spdep</strong> return <code>htest</code> objects with a <code>print()</code> method in the <strong>stats</strong> package. To save space here, we’ll use a glance function if the <code>broom::tidy()</code> method has not been updated to use estimate names.</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb367-1" title="1">jcl &lt;-<span class="st"> </span><span class="kw">joincount.test</span>(pol_pres15<span class="op">$</span>types, <span class="dt">listw=</span>lw_q_B)</a>
<a class="sourceLine" id="cb367-2" title="2"><span class="cf">if</span> (broom_ok) {</a>
<a class="sourceLine" id="cb367-3" title="3">nm &lt;-<span class="st"> </span>tibble<span class="op">::</span><span class="kw">enframe</span>(<span class="kw">sapply</span>(jcl, <span class="cf">function</span>(t) {</a>
<a class="sourceLine" id="cb367-4" title="4">  nm &lt;-<span class="st"> </span><span class="kw">substring</span>(<span class="kw">names</span>(t<span class="op">$</span>statistic), <span class="dv">18</span>)</a>
<a class="sourceLine" id="cb367-5" title="5">  <span class="kw">paste0</span>(nm, <span class="st">&quot;:&quot;</span>, nm)</a>
<a class="sourceLine" id="cb367-6" title="6">}))</a>
<a class="sourceLine" id="cb367-7" title="7">mat &lt;-<span class="st"> </span><span class="kw">cbind</span>(nm, <span class="kw">do.call</span>(<span class="st">&quot;rbind&quot;</span>, (<span class="kw">lapply</span>(jcl, broom<span class="op">::</span>tidy))))</a>
<a class="sourceLine" id="cb367-8" title="8"><span class="kw">names</span>(mat)[<span class="dv">3</span>] &lt;-<span class="st"> &quot;Joincount&quot;</span></a>
<a class="sourceLine" id="cb367-9" title="9"><span class="kw">names</span>(mat)[<span class="dv">6</span>] &lt;-<span class="st"> &quot;Std.deviate&quot;</span></a>
<a class="sourceLine" id="cb367-10" title="10"><span class="kw">names</span>(mat)[<span class="dv">2</span>] &lt;-<span class="st"> &quot;&quot;</span></a>
<a class="sourceLine" id="cb367-11" title="11">mat[,<span class="dv">2</span><span class="op">:</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb367-12" title="12">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb367-13" title="13">mat &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">sapply</span>(jcl, glance_htest))</a>
<a class="sourceLine" id="cb367-14" title="14"><span class="kw">colnames</span>(mat)[<span class="dv">1</span>] &lt;-<span class="st"> &quot;Joincount&quot;</span></a>
<a class="sourceLine" id="cb367-15" title="15"><span class="kw">rownames</span>(mat) &lt;-<span class="st"> </span><span class="kw">sapply</span>(jcl, <span class="cf">function</span>(t) {  </a>
<a class="sourceLine" id="cb367-16" title="16">  nm &lt;-<span class="st"> </span><span class="kw">substring</span>(<span class="kw">names</span>(t<span class="op">$</span>statistic), <span class="dv">18</span>)</a>
<a class="sourceLine" id="cb367-17" title="17">  <span class="kw">paste0</span>(nm, <span class="st">&quot;:&quot;</span>, nm)</a>
<a class="sourceLine" id="cb367-18" title="18">})</a>
<a class="sourceLine" id="cb367-19" title="19">mat</a>
<a class="sourceLine" id="cb367-20" title="20">}</a></code></pre></div>
<pre><code>#                               Joincount Expectation Variance Std deviate
# Rural:Rural                        3087     2793.92 1126.534       8.732
# Urban:Urban                         110      104.72   93.299       0.547
# Urban/rural:Urban/rural             656      426.53  331.759      12.599
# Warsaw Borough:Warsaw Borough        41        0.35    0.347      68.965
#                               p.value=
# Rural:Rural                   1.25e-18
# Urban:Urban                   2.92e-01
# Urban/rural:Urban/rural       1.07e-36
# Warsaw Borough:Warsaw Borough 0.00e+00</code></pre>
<p>The join count test was subsequently adapted for multi-colour join counts <span class="citation">(Upton and Fingleton <a href="#ref-upton+fingleton:85">1985</a>)</span>. The implementation as <code>joincount.mult()</code> in <strong>spdep</strong> returns a table based on nonfree sampling, and does not report p-values.</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb369-1" title="1"><span class="kw">args</span>(joincount.multi)</a></code></pre></div>
<pre><code># function (fx, listw, zero.policy = FALSE, spChk = NULL, adjust.n = TRUE) 
# NULL</code></pre>
<p>The first four lines of results for same-colour join counts are the same as those from <code>jointcount.test()</code> above, also under nonfree sampling. The remaining lines report results for multi-colour join counts on the same basis, and finally the “Jtot” statistic summarising the totality of join counts for the variable and <code>listw</code> object chosen.</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb371-1" title="1"><span class="kw">joincount.multi</span>(pol_pres15<span class="op">$</span>types, <span class="dt">listw=</span>lw_q_B)</a></code></pre></div>
<pre><code>#                               Joincount Expected Variance z-value
# Rural:Rural                    3087.000 2793.920 1126.534    8.73
# Urban:Urban                     110.000  104.719   93.299    0.55
# Urban/rural:Urban/rural         656.000  426.526  331.759   12.60
# Warsaw Borough:Warsaw Borough    41.000    0.350    0.347   68.96
# Urban:Rural                     668.000 1083.941  708.209  -15.63
# Urban/rural:Rural              2359.000 2185.769 1267.131    4.87
# Urban/rural:Urban               171.000  423.729  352.190  -13.47
# Warsaw Borough:Rural             12.000   64.393   46.460   -7.69
# Warsaw Borough:Urban              9.000   12.483   11.758   -1.02
# Warsaw Borough:Urban/rural        8.000   25.172   22.354   -3.63
# Jtot                           3227.000 3795.486 1496.398  -14.70</code></pre>
<p>So far, we have used binary weights, so the sum of join counts multiplied by the weight on that join remains integer. If we change to row standardised weights, where the weights are not unity in all cases, the counts, expectations and variances change, but there are few major changes in the z-values.</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb373-1" title="1"><span class="kw">joincount.multi</span>(pol_pres15<span class="op">$</span>types, <span class="dt">listw=</span>lw_q_W)</a></code></pre></div>
<pre><code>#                               Joincount Expected Variance z-value
# Rural:Rural                    521.6476 489.4559  22.8856    6.73
# Urban:Urban                     20.9023  18.3452   2.8822    1.51
# Urban/rural:Urban/rural        106.1765  74.7213   9.3498   10.29
# Warsaw Borough:Warsaw Borough    6.7363   0.0613   0.0116   61.89
# Urban:Rural                    165.2283 189.8913  18.2987   -5.77
# Urban/rural:Rural              389.6002 382.9162  36.1501    1.11
# Urban/rural:Urban               32.5048  74.2314  10.6416  -12.79
# Warsaw Borough:Rural             1.8554  11.2807   1.1075   -8.96
# Warsaw Borough:Urban             1.6171   2.1868   0.3775   -0.93
# Warsaw Borough:Urban/rural       1.2315   4.4098   0.6810   -3.85
# Jtot                           592.0373 664.9162  43.1245  -11.10</code></pre>
<p>Using an inverse distance based <code>listw</code> object does, however, change the z-values markedly, because closer centroids are upweighted relatively strongly:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb375-1" title="1"><span class="kw">joincount.multi</span>(pol_pres15<span class="op">$</span>types, <span class="dt">listw=</span>lw_d183_idw_B)</a></code></pre></div>
<pre><code>#                               Joincount Expected Variance z-value
# Rural:Rural                    3.46e+02 3.61e+02 4.93e+01   -2.10
# Urban:Urban                    2.90e+01 1.35e+01 2.23e+00   10.39
# Urban/rural:Urban/rural        4.65e+01 5.51e+01 9.61e+00   -2.79
# Warsaw Borough:Warsaw Borough  1.68e+01 4.53e-02 6.61e-03  206.38
# Urban:Rural                    2.02e+02 1.40e+02 2.36e+01   12.73
# Urban/rural:Rural              2.25e+02 2.83e+02 3.59e+01   -9.59
# Urban/rural:Urban              3.65e+01 5.48e+01 8.86e+00   -6.14
# Warsaw Borough:Rural           5.65e+00 8.33e+00 1.73e+00   -2.04
# Warsaw Borough:Urban           9.18e+00 1.61e+00 2.54e-01   15.01
# Warsaw Borough:Urban/rural     3.27e+00 3.25e+00 5.52e-01    0.02
# Jtot                           4.82e+02 4.91e+02 4.16e+01   -1.38</code></pre>
<p>The implementation of Moran’s <span class="math inline">\(I\)</span> in <strong>spdep</strong> in the <code>moran.test()</code> function has similar arguments to those of <code>joincount.test()</code>, but <code>sampling=</code> is replaced by <code>randomisation=</code> to indicate the underlying analytical approach used for calculating the variance of the measure. It is also possible to use ranks rather than numerical values <span class="citation">(Cliff and Ord <a href="#ref-cliff+ord:81">1981</a>, 46)</span>. The <code>drop.EI2=</code> agrument may be used to reproduce results where the final component of the variance term is omitted.</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb377-1" title="1"><span class="kw">args</span>(moran.test)</a></code></pre></div>
<pre><code># function (x, listw, randomisation = TRUE, zero.policy = NULL, 
#     alternative = &quot;greater&quot;, rank = FALSE, na.action = na.fail, 
#     spChk = NULL, adjust.n = TRUE, drop.EI2 = FALSE) 
# NULL</code></pre>
<p>The default for the <code>randomisation=</code> argument is <code>TRUE</code>, but here we will simply show that the test under normality is the same as a test of least squares residuals with only the intercept used in the mean model. The spelling of randomisation is that of Cliff and Ord <span class="citation">(<a href="#ref-cliff+ord:73">1973</a>)</span>.</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb379-1" title="1">mt &lt;-<span class="st"> </span><span class="kw">moran.test</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B, <span class="dt">randomisation=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb379-2" title="2"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(mt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(mt)</a></code></pre></div>
<pre><code># Moran I statistic       Expectation          Variance       Std deviate 
#          0.691434         -0.000401          0.000140         58.461349 
#          p.value= 
#          0.000000</code></pre>
<p>The <code>lm.morantest()</code> function also takes a <code>resfun=</code> argument to set the function used to extract the residuals used for testing, and clearly lets us model other salient features of the response variable <span class="citation">(Cliff and Ord <a href="#ref-cliff+ord:81">1981</a>, 203)</span>.</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb381-1" title="1"><span class="kw">args</span>(lm.morantest)</a></code></pre></div>
<pre><code># function (model, listw, zero.policy = NULL, alternative = &quot;greater&quot;, 
#     spChk = NULL, resfun = weighted.residuals, naSubset = TRUE) 
# NULL</code></pre>
<p>To compare with the standard test, we are only using the intercept here, and as can be seen, the results are the same.</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb383-1" title="1">ols &lt;-<span class="st"> </span><span class="kw">lm</span>(I_turnout <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, pol_pres15)</a>
<a class="sourceLine" id="cb383-2" title="2">lmt &lt;-<span class="st"> </span><span class="kw">lm.morantest</span>(ols, <span class="dt">listw=</span>lw_q_B)</a>
<a class="sourceLine" id="cb383-3" title="3"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(lmt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(lmt)</a></code></pre></div>
<pre><code># Observed Moran I      Expectation         Variance      Std deviate 
#         0.691434        -0.000401         0.000140        58.461349 
#         p.value= 
#         0.000000</code></pre>
<p>Following the elaboration of the global Moran’s I test for least squares residuals, further work was done to develop an exact test <span class="citation">(Tiefelsdorf and Boots <a href="#ref-TiefelsdorfBoots1995">1995</a>, <a href="#ref-TiefelsdorfBoots1997">1997</a>; Hepple <a href="#ref-Hepple1998">1998</a>)</span>. The <code>lm.morantest.sad()</code> function implements a Saddlepoint approximation, and <code>lm.morantest.exact()</code> the exact test, using dense matrix calculations unsuitable for large <span class="math inline">\(n\)</span> <span class="citation">(Tiefelsdorf <a href="#ref-tiefelsdorf:02">2002</a>; Bivand, Müller, and Reder <a href="#ref-bivandetal:09">2009</a>)</span>. The additional arguments are used in the computation of the exact standard deviate.</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb385-1" title="1"><span class="kw">args</span>(lm.morantest.exact)</a></code></pre></div>
<pre><code># function (model, listw, zero.policy = NULL, alternative = &quot;greater&quot;, 
#     spChk = NULL, resfun = weighted.residuals, zero.tol = 1e-07, 
#     Omega = NULL, save.M = NULL, save.U = NULL, useTP = FALSE, 
#     truncErr = 1e-06, zeroTreat = 0.1) 
# NULL</code></pre>
<p>We can easily see that the exact standard deviate is an order of magnitude smaller for this response, mean model and spatial weights specification, compared to the standard deviate based on the variance calculated using the normality assumption.</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb387-1" title="1"><span class="kw">suppressWarnings</span>(lmte &lt;-<span class="st"> </span><span class="kw">lm.morantest.exact</span>(ols, <span class="dt">listw=</span>lw_q_B))</a>
<a class="sourceLine" id="cb387-2" title="2"><span class="kw">names</span>(lmte<span class="op">$</span>estimate) &lt;-<span class="st"> &quot;Moran I statistic&quot;</span></a>
<a class="sourceLine" id="cb387-3" title="3"><span class="kw">class</span>(lmte) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">class</span>(lmte), <span class="st">&quot;htest&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb388"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb388-1" title="1"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(lmte)[,<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(lmte)</a></code></pre></div>
<pre><code># Moran I statistic       Std deviate          p.value= 
#          6.91e-01          5.83e+00          2.74e-09</code></pre>
<p>The only difference between tests under normality and randomisation is that an extra term is added if the kurtosis of the variable of interest indicates a flatter or more peaked distribution, where the measure used is the classical measure of kurtosis.</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb390-1" title="1"><span class="kw">all.equal</span>(<span class="dv">3</span><span class="op">+</span>e1071<span class="op">::</span><span class="kw">kurtosis</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">type=</span><span class="dv">1</span>),</a>
<a class="sourceLine" id="cb390-2" title="2">          <span class="kw">moran</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B, <span class="dt">n=</span><span class="kw">nrow</span>(pol_pres15),</a>
<a class="sourceLine" id="cb390-3" title="3">                <span class="dt">S0=</span><span class="kw">Szero</span>(lw_q_B))<span class="op">$</span>K)</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>Under the default randomisation assumption of analytical randomisation, the results are largely unchanged.</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb392-1" title="1">mtr &lt;-<span class="st"> </span><span class="kw">moran.test</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B)</a>
<a class="sourceLine" id="cb392-2" title="2"><span class="cf">if</span> (broom_ok) (tmtr &lt;-<span class="st"> </span>broom<span class="op">::</span><span class="kw">tidy</span>(mtr)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]) <span class="cf">else</span> (tmtr &lt;-<span class="st"> </span><span class="kw">glance_htest</span>(mtr))</a></code></pre></div>
<pre><code># Moran I statistic       Expectation          Variance       Std deviate 
#          0.691434         -0.000401          0.000140         58.459835 
#          p.value= 
#          0.000000</code></pre>
<p>The PySAL <strong>esda</strong> package contains the <code>Moran</code> function reporting the same results, here under randomisation. The function returns results under normality, randomisation and by permutation simulation. Similar compatisons may be made for other global measures; for details see Bivand and Wong <span class="citation">(<a href="#ref-Bivand2018">2018</a>)</span>.</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb394-1" title="1">esda &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;esda&quot;</span>)</a>
<a class="sourceLine" id="cb394-2" title="2">np<span class="op">$</span>random<span class="op">$</span><span class="kw">seed</span>(1L)</a>
<a class="sourceLine" id="cb394-3" title="3">mi &lt;-<span class="st"> </span>esda<span class="op">$</span><span class="kw">Moran</span>(pol_pres15<span class="op">$</span>I_turnout, nb_gal_ps, <span class="dt">transformation=</span><span class="st">&quot;B&quot;</span>,</a>
<a class="sourceLine" id="cb394-4" title="4">                 <span class="dt">permutations=</span>999L, <span class="dt">two_tailed=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb394-5" title="5"><span class="kw">all.equal</span>(<span class="kw">c</span>(mi<span class="op">$</span>I, mi<span class="op">$</span>EI, mi<span class="op">$</span>VI_rand, mi<span class="op">$</span>z_rand, mi<span class="op">$</span>p_rand), <span class="kw">unname</span>(<span class="kw">unlist</span>(<span class="kw">c</span>(tmtr))))</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>Of course, from the very beginning, interest was shown in Monte Carlo testing, also known as a Hope-type test and as a permutation bootstrap. By default, <code>moran.mc()</code> retrurns a <code>"htest"</code> object, but may simply use <code>boot::boot()</code> internally and return a <code>"boot"</code> object when <code>return_boot=TRUE</code>.</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb396-1" title="1"><span class="kw">args</span>(moran.mc)</a></code></pre></div>
<pre><code># function (x, listw, nsim, zero.policy = NULL, alternative = &quot;greater&quot;, 
#     na.action = na.fail, spChk = NULL, return_boot = FALSE, adjust.n = TRUE) 
# NULL</code></pre>
<p>In addition the number of simulations of the variable of interest by permutation, that is shuffling the values across the observations at random, needs to be given as <code>nsim=</code>.</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb398-1" title="1"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb398-2" title="2">mmc &lt;-<span class="st"> </span><span class="kw">moran.mc</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B, <span class="dt">nsim=</span><span class="dv">999</span>, <span class="dt">return_boot =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>The bootstrap permutation retains the outcomes of each of the random permutations, reporting the observed value of the statistic, here Moran’s <span class="math inline">\(I\)</span>, the difference between this value and the mean of the simulations under randomisation (equivalent to <span class="math inline">\(E(I)\)</span>), and the standard deviation of the simulations under randomisation.</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb399-1" title="1">glance_boot &lt;-<span class="st"> </span><span class="cf">function</span>(bt) <span class="kw">c</span>(<span class="dt">original=</span>bt<span class="op">$</span>t0, <span class="dt">bias=</span><span class="kw">mean</span>(bt<span class="op">$</span>t)<span class="op">-</span>bt<span class="op">$</span>t0,</a>
<a class="sourceLine" id="cb399-2" title="2">                              <span class="dt">std.error=</span><span class="kw">sd</span>(bt<span class="op">$</span>t),</a>
<a class="sourceLine" id="cb399-3" title="3">                              <span class="dt">zvalue=</span>(bt<span class="op">$</span>t0<span class="op">-</span><span class="kw">mean</span>(bt<span class="op">$</span>t))<span class="op">/</span><span class="kw">sd</span>(bt<span class="op">$</span>t))</a>
<a class="sourceLine" id="cb399-4" title="4"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(mmc) <span class="cf">else</span> <span class="kw">glance_boot</span>(mmc)</a></code></pre></div>
<pre><code>#  original      bias std.error    zvalue 
#     0.691    -0.691     0.012    57.592</code></pre>
<p>We can extract the equivalent results from the object returned by the PySAL <code>Moran()</code> object, which uses the NumPy random number generator:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb401-1" title="1"><span class="kw">c</span>(<span class="dt">statistic=</span>mi<span class="op">$</span>I, <span class="dt">bias=</span>mi<span class="op">$</span>EI_sim<span class="op">-</span>mi<span class="op">$</span>I, <span class="dt">std.error=</span>mi<span class="op">$</span>seI_sim)</a></code></pre></div>
<pre><code># statistic      bias std.error 
#    0.6914   -0.6922    0.0123</code></pre>
<p>If we compare the Monte Carlo and analytical variances of <span class="math inline">\(I\)</span> under randomisation, we typically see few differences, arguably rendering Monte Carlo testing unnecessary.</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb403-1" title="1"><span class="kw">c</span>(<span class="st">&quot;Permutation bootstrap&quot;</span>=<span class="kw">var</span>(mmc<span class="op">$</span>t), </a>
<a class="sourceLine" id="cb403-2" title="2">  <span class="st">&quot;Analytical randomisation&quot;</span>=<span class="kw">unname</span>(mtr<span class="op">$</span>estimate[<span class="dv">3</span>]))</a></code></pre></div>
<pre><code>#    Permutation bootstrap Analytical randomisation 
#                 0.000144                 0.000140</code></pre>
<p>There is also a permutation bootstrap approach to the approximate profile likelihood estimator (APLE) measure <span class="citation">(Li, Calder, and Cressie <a href="#ref-Lietal07">2007</a>, <a href="#ref-Lietal12">2012</a>)</span> using row-standardised weights, in which the variable of interest must be centred on zero first:</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb405-1" title="1">apmc &lt;-<span class="st"> </span><span class="kw">aple.mc</span>(<span class="kw">c</span>(<span class="kw">scale</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">scale=</span><span class="ot">FALSE</span>)), <span class="dt">listw=</span>lw_q_W,</a>
<a class="sourceLine" id="cb405-2" title="2">                <span class="dt">nsim=</span><span class="dv">999</span>)</a>
<a class="sourceLine" id="cb405-3" title="3"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(apmc) <span class="cf">else</span> <span class="kw">glance_boot</span>(apmc)</a></code></pre></div>
<pre><code>#  original      bias std.error    zvalue 
#    0.7852   -0.7847    0.0326   24.0760</code></pre>
<p>Geary’s global <span class="math inline">\(C\)</span> is implemented in <code>geary.test()</code> largely following the same argument structure as <code>moran.test()</code>. Geary’s global <span class="math inline">\(C\)</span> measure is given as <span class="citation">(Cliff and Ord <a href="#ref-cliff+ord:81">1981</a>, 17)</span>:</p>
<p><span class="math display">\[
C = \left( \frac{(n-1)}{2 S_0} \right) \frac{\sum_{(2)} w_{ij}(x_i-x_j)^2}{\sum_{i=1}^{n} z_i^2}
\]</span>
using the same definitions as for Moran’s <span class="math inline">\(I\)</span>.</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb407-1" title="1"><span class="kw">args</span>(geary.test)</a></code></pre></div>
<pre><code># function (x, listw, randomisation = TRUE, zero.policy = NULL, 
#     alternative = &quot;greater&quot;, spChk = NULL, adjust.n = TRUE) 
# NULL</code></pre>
<p>Because <span class="math inline">\(C\)</span> is based on the similarity of neighbouring values, small values of <span class="math inline">\(C\)</span> indicate small differences, here much smaller than the expected standardised difference of unity.</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb409-1" title="1">gt &lt;-<span class="st"> </span><span class="kw">geary.test</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B)</a>
<a class="sourceLine" id="cb409-2" title="2"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(gt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(gt)</a></code></pre></div>
<pre><code># Geary C statistic       Expectation          Variance       Std deviate 
#          3.04e-01          1.00e+00          2.14e-04          4.76e+01 
#          p.value= 
#          0.00e+00</code></pre>
<p>The Getis-Ord <span class="math inline">\(G\)</span> test includes extra arguments to accommodate differences between implementations, as Bivand and Wong <span class="citation">(<a href="#ref-Bivand2018">2018</a>)</span> found multiple divergences from the original definitions, often to omit no-neighbour observations generated when using distance band neighbours. It is given as <span class="citation">(Getis and Ord <a href="#ref-getis+ord:92">1992</a>, 194)</span>:</p>
<p><span class="math display">\[
G = \frac{\sum_{(2)} w_{ij} x_i x_j}{\sum_{(2)} x_i x_j}
\]</span>
using the same definitions as for Moran’s <span class="math inline">\(I\)</span>. For <span class="math inline">\(G_*\)</span>, the <span class="math inline">\(\sum_{(2)}\)</span> constraint is relaxed by including <span class="math inline">\(i\)</span> as a neighbour of itself (thereby also removing the no-neighbour problem, because all observations have at least one neighbour).</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb411-1" title="1"><span class="kw">args</span>(globalG.test)</a></code></pre></div>
<pre><code># function (x, listw, zero.policy = NULL, alternative = &quot;greater&quot;, 
#     spChk = NULL, adjust.n = TRUE, B1correct = TRUE, adjust.x = TRUE, 
#     Arc_all_x = FALSE) 
# NULL</code></pre>
<p>With contiguity neighbours, global <span class="math inline">\(G\)</span> yields a much smaller standard deviate than when using a 16 km distance band neighbour definition:</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb413-1" title="1">ggt &lt;-<span class="st"> </span><span class="kw">globalG.test</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B)</a>
<a class="sourceLine" id="cb413-2" title="2"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(ggt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(ggt)</a></code></pre></div>
<pre><code># Global G statistic        Expectation           Variance        Std deviate 
#           2.31e-03           2.29e-03           1.73e-11           5.08e+00 
#           p.value= 
#           1.88e-07</code></pre>
<p>Because this neighbour definition leaves a few observations without neighbours, we need to use the <code>zero.policy=</code> argument.</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb415-1" title="1">ggt &lt;-<span class="st"> </span><span class="kw">globalG.test</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_d16_B, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb415-2" title="2"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(ggt)[,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>] <span class="cf">else</span> <span class="kw">glance_htest</span>(ggt)</a></code></pre></div>
<pre><code># Global G statistic        Expectation           Variance        Std deviate 
#           2.79e-03           2.56e-03           5.51e-11           3.05e+01 
#           p.value= 
#          2.31e-204</code></pre>
<p>The Mantel test is implemented without its analytical variance as <code>sp.mantel.mc()</code>, rather using permutation bootstrap like <code>moran.mc()</code>. It takes a <code>type=</code> argument, which can be set to <code>"moran"</code>, <code>"geary"</code> or <code>"sokal"</code>. The output is scaled differently, but gives similar inferences.</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb417-1" title="1"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb417-2" title="2">mamc &lt;-<span class="st"> </span><span class="kw">sp.mantel.mc</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B, <span class="dt">nsim=</span><span class="dv">999</span>, </a>
<a class="sourceLine" id="cb417-3" title="3">                     <span class="dt">type=</span><span class="st">&quot;moran&quot;</span>, <span class="dt">return_boot =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb417-4" title="4"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(mamc) <span class="cf">else</span> <span class="kw">glance_boot</span>(mamc)</a></code></pre></div>
<pre><code>#  original      bias std.error    zvalue 
#    9843.5   -9844.3     170.9      57.6</code></pre>
<p>Finally, the empirical Bayes Moran’s <span class="math inline">\(I\)</span> takes account of the denominator in assessing spatial autocorrelation in rates data <span class="citation">(Assunção and Reis <a href="#ref-assuncao+reis:99">1999</a>)</span>. Until now, we have considered the proportion of valid votes cast in relation to the numbers entitled to vote by spatial entity, but using <code>EBImoran.mc()</code> we can try to accommodate uncertainty in extreme rates in entities with small numbers entitled to vote. There is, however, little impact on the outcome in this case.</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb419-1" title="1"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb419-2" title="2"><span class="kw">suppressMessages</span>(ebimc &lt;-<span class="st"> </span><span class="kw">EBImoran.mc</span>(<span class="dt">n=</span>pol_pres15<span class="op">$</span>I_valid_votes,</a>
<a class="sourceLine" id="cb419-3" title="3">                                      <span class="dt">x=</span>pol_pres15<span class="op">$</span>I_entitled_to_vote,</a>
<a class="sourceLine" id="cb419-4" title="4">                                      <span class="dt">listw=</span>lw_q_B, <span class="dt">nsim=</span><span class="dv">999</span>, <span class="dt">return_boot=</span><span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb419-5" title="5"><span class="cf">if</span> (broom_ok) broom<span class="op">::</span><span class="kw">tidy</span>(ebimc) <span class="cf">else</span> <span class="kw">glance_boot</span>(ebimc)</a></code></pre></div>
<pre><code>#  original      bias std.error    zvalue 
#     0.693    -0.693     0.012    57.742</code></pre>
<p>A similar measure may also be achieved using global empirical Bayes estimators with <code>EBest()</code> to calculate a numerical vector of empirical Bayes estimates, but both are only limited ways of handling mis-specification in the mean model.</p>
<p>Global measures of spatial autocorrelation using spatial weights objects based on graphs of neighbours are, as we have seen, rather blunt tools, which for interpretation depend critically on a reasoned mean model of the variable in question. If the mean model is just the intercept, the global measures will respond to all kinds of mis-specification, not only spatial autocorrelation. A key source of mis-specification will typically also include the choice of entities for aggregation of data.</p>
</div>
<div id="local-measures" class="section level3">
<h3><span class="header-section-number">14.3.2</span> Local measures</h3>
<p>Building on insights from the weaknesses of global measures, local indicators of spatial association began to appear in the first half of the 1990s <span class="citation">(Anselin <a href="#ref-anselin:95">1995</a>; Getis and Ord <a href="#ref-getis+ord:92">1992</a>, <a href="#ref-getis+ord:96">1996</a>)</span>. In addition, the Moran plot was introduced, plotting the values of the variable of interest against their spatially lagged values, typically using row-standardised weights to make the axes more directly comparable <span class="citation">(Anselin <a href="#ref-anselin:96">1996</a>)</span>. The <code>moran.plot()</code> function also returns an influence measures object used to label observations exerting more than propotional influence on the slope of the line representing global Moran’s <span class="math inline">\(I\)</span>. In this case, we can see that there are many spatial entities exerting such influence. These pairs of observed and lagged observed values make up in aggregate the global measure, but can also be explored in detail. The quadrants of the Moran plot also show low-low pairs in the lower left quadrant, high-high in the upper right quadrant, and fewer low-high and high-low pairs in the upper left and lower right quadrants.</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb421-1" title="1">infl_W &lt;-<span class="st"> </span><span class="kw">moran.plot</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_W, </a>
<a class="sourceLine" id="cb421-2" title="2">                     <span class="dt">labels=</span>pol_pres15<span class="op">$</span>TERYT, <span class="dt">cex=</span><span class="dv">1</span>, <span class="dt">pch=</span><span class="st">&quot;.&quot;</span>, </a>
<a class="sourceLine" id="cb421-3" title="3">                     <span class="dt">xlab=</span><span class="st">&quot;I round turnout&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;lagged turnout&quot;</span>,</a>
<a class="sourceLine" id="cb421-4" title="4">                     <span class="dt">return_df =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:moranplot"></span>
<img src="sds_files/figure-html/moranplot-1.png" alt="Moran plot of I round turnout, row standardised weights" width="100%" />
<p class="caption">
Figure 14.3: Moran plot of I round turnout, row standardised weights
</p>
</div>
<p>If we extract the hat value influence measure from the returned object, a map suggests that some edge entities exert more than proportional influence, as do entities in or near larger urban areas.</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb422-1" title="1">pol_pres15<span class="op">$</span>hat_value &lt;-<span class="st"> </span>infl_W<span class="op">$</span>infmat[,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb422-2" title="2"><span class="kw">tm_shape</span>(pol_pres15) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="st">&quot;hat_value&quot;</span>)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:moranhat"></span>
<img src="sds_files/figure-html/moranhat-1.png" alt="Moran plot hat values, row standardised neighbours" width="100%" />
<p class="caption">
Figure 14.4: Moran plot hat values, row standardised neighbours
</p>
</div>
<p>Bivand and Wong <span class="citation">(<a href="#ref-Bivand2018">2018</a>)</span> discuss issues impacting the use of local indicators, such as local Moran’s <span class="math inline">\(I\)</span> and local Getis-Ord <span class="math inline">\(G\)</span>. Some issues affect the calculation of the local indicators, others inference from their values. Because <span class="math inline">\(n\)</span> statistics may be being calculated from the same number of observations, there are multiple comparison problems that need to be addressed. Although the apparent detection of hotspots from values of local indicators has been quite widely adopted, it remains fraught with difficulty because adjustment of the inferential basis to accommodate multiple comparisons is not often chosen, and as in the global case, mis-specification also remains a source of confusion. Further, interpreting local spatial autocorrelation in the presence of global spatial autocorrelation is challenging <span class="citation">(Ord and Getis <a href="#ref-ord+getis:01">2001</a>; Tiefelsdorf <a href="#ref-tiefelsdorf:02">2002</a>; Bivand, Müller, and Reder <a href="#ref-bivandetal:09">2009</a>)</span>. The <code>mlvar=</code> and <code>adjust.x=</code> arguments to <code>localmoran()</code> are discussed in Bivand and Wong <span class="citation">(<a href="#ref-Bivand2018">2018</a>)</span>, and permit matching with other implementations. The <code>p.adjust.method=</code> argument uses an untested speculation that adjustment should only take into account the cardinality of the neighbour set of each observation when adjusting for multiple comparisons; using <code>stats::p.adjust()</code> is preferable.</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb423-1" title="1"><span class="kw">args</span>(localmoran)</a></code></pre></div>
<pre><code># function (x, listw, zero.policy = NULL, na.action = na.fail, 
#     alternative = &quot;greater&quot;, p.adjust.method = &quot;none&quot;, mlvar = TRUE, 
#     spChk = NULL, adjust.x = FALSE) 
# NULL</code></pre>
<p>Taking <code>"two.sided"</code> p-values because these local indicators when summed and divided by the sum of the spatial weights, and thus positive and negative local spatial autocorrelation may be present, we obtain:</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb425-1" title="1">locm &lt;-<span class="st"> </span><span class="kw">localmoran</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B, <span class="dt">alternative=</span><span class="st">&quot;two.sided&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb426"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb426-1" title="1"><span class="kw">all.equal</span>(<span class="kw">sum</span>(locm[,<span class="dv">1</span>])<span class="op">/</span><span class="kw">Szero</span>(lw_q_B), </a>
<a class="sourceLine" id="cb426-2" title="2">          <span class="kw">unname</span>(<span class="kw">moran.test</span>(pol_pres15<span class="op">$</span>I_turnout, lw_q_B)<span class="op">$</span>estimate[<span class="dv">1</span>]))</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>Using <code>stats::p.adjust()</code> to adjust for multiple comparisons, we see that
almost 29% of the local measures have p-values &lt; 0.05 if no adjustment is applied, but only 12% using Bonferroni correction.</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb428-1" title="1">pvs &lt;-<span class="st"> </span><span class="kw">cbind</span>(locm[,<span class="dv">5</span>], <span class="kw">p.adjust</span>(locm[,<span class="dv">5</span>], <span class="st">&quot;bonferroni&quot;</span>), </a>
<a class="sourceLine" id="cb428-2" title="2">             <span class="kw">p.adjust</span>(locm[,<span class="dv">5</span>],<span class="st">&quot;fdr&quot;</span>), <span class="kw">p.adjust</span>(locm[,<span class="dv">5</span>], <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb428-3" title="3"><span class="kw">colnames</span>(pvs) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb429"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb429-1" title="1"><span class="kw">apply</span>(pvs, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        715        297        576        424</code></pre>
<p>The <code>localmoran.sad()</code> and <code>localmoran.exact()</code> functions take a fitted linear model, a <code>select=</code> argument to specify which observations to test (choosing only one removes the need to adjust for multiple comparisons), arguments like <code>nb2listw()</code> to build single observation star graphs of neighbours and their weights, and arguments needed for numerical estimation internally. They return lists of objects like <code>"htest"</code> objects, which may be coerced to <code>data.frame</code> objects.</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb431-1" title="1"><span class="kw">args</span>(localmoran.sad)</a></code></pre></div>
<pre><code># function (model, select, nb, glist = NULL, style = &quot;W&quot;, zero.policy = NULL, 
#     alternative = &quot;greater&quot;, spChk = NULL, resfun = weighted.residuals, 
#     save.Vi = FALSE, tol = .Machine$double.eps^0.5, maxiter = 1000, 
#     tol.bounds = 1e-04, save.M = FALSE, Omega = NULL) 
# NULL</code></pre>
<p>If we use <code>localmoran.sad()</code> to make saddlepoint approximations of the standard deviates of the local measures, and make the same corrections, we drop from 26% of the p-values &lt; 0.05 with no correction to under 2% using Bonferroni correction:</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb433-1" title="1">locms &lt;-<span class="st"> </span><span class="kw">localmoran.sad</span>(ols, <span class="dt">nb=</span>nb_q, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>, <span class="dt">alternative=</span><span class="st">&quot;two.sided&quot;</span>)</a>
<a class="sourceLine" id="cb433-2" title="2">locms &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(locms)</a>
<a class="sourceLine" id="cb433-3" title="3">pvss &lt;-<span class="st"> </span><span class="kw">cbind</span>(locms[,<span class="dv">5</span>], <span class="kw">p.adjust</span>(locms[,<span class="dv">5</span>], <span class="st">&quot;bonferroni&quot;</span>), </a>
<a class="sourceLine" id="cb433-4" title="4">              <span class="kw">p.adjust</span>(locms[,<span class="dv">5</span>], <span class="st">&quot;fdr&quot;</span>), <span class="kw">p.adjust</span>(locms[,<span class="dv">5</span>], <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb433-5" title="5"><span class="kw">colnames</span>(pvss) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb434"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb434-1" title="1"><span class="kw">apply</span>(pvss, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        646         44        314         87</code></pre>
<p>Should we think it appropriate to take possible global spatial autocorrelation into account, we may fit a spatial regression model first. We can find the interval for the line search for the spatial coefficient <span class="math inline">\(\lambda\)</span> from the inverse of the extreme eigenvalues of the spatial weights, here using <code>spatialreg::lextrB()</code>:</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb436-1" title="1">ints &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="kw">c</span>(spatialreg<span class="op">::</span><span class="kw">lextrB</span>(lw_q_B))</a>
<a class="sourceLine" id="cb436-2" title="2">ints</a></code></pre></div>
<pre><code># lambda_n lambda_1 
#   -0.293    0.157</code></pre>
<p>From the output of a simultaneous autoregressive spatial error model, we see that the coefficient is close to its upper bound:</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb438-1" title="1">SEM &lt;-<span class="st"> </span>spatialreg<span class="op">::</span><span class="kw">errorsarlm</span>(I_turnout <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data=</span>pol_pres15, <span class="dt">listw=</span>lw_q_B,</a>
<a class="sourceLine" id="cb438-2" title="2">                              <span class="dt">method=</span><span class="st">&quot;Matrix&quot;</span>, <span class="dt">interval=</span>ints)</a></code></pre></div>
<div class="sourceCode" id="cb439"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb439-1" title="1">spatialreg<span class="op">::</span><span class="kw">coef.sarlm</span>(SEM)</a></code></pre></div>
<pre><code>#      lambda (Intercept) 
#       0.139       0.459</code></pre>
<p>The spatial error model is clearly a better description of the data than a mean model with just the intercept using a likelihood ratio test for comparison:</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb441-1" title="1">spatialreg<span class="op">::</span><span class="kw">LR1.sarlm</span>(SEM)</a></code></pre></div>
<pre><code># 
#   Likelihood Ratio diagnostics for spatial dependence
# 
# data:  
# Likelihood ratio = 2111, df = 1, p-value &lt;2e-16
# sample estimates:
# Log likelihood of spatial error model           Log likelihood of OLS fit y 
#                                  4386                                  3330</code></pre>
<p>Reconstructing a linear model after filtering out the global spatial autocorrelation <span class="math inline">\((I - \lambda W)\)</span> as <code>lm.target</code>, we can also construct <span class="math inline">\((I - \lambda W)^{-1}\)</span> representing the global spatial process as input to the <code>Omega=</code> argument. This is used internally to re-balance the matrix products of the per-observation star weights matrices, so involves substantial amounts of numerical linear algebra, including solving a dense matrix eigeneproblem, for each chosen observation. So if we take global autocorrelation into account, in this case the no-adjustment count of observations with p-values &lt; 0.05 is under 7%, and using Bonferroni correction, we drop to 0.2%.</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb443-1" title="1">lm.target &lt;-<span class="st"> </span><span class="kw">lm</span>(SEM<span class="op">$</span>tary <span class="op">~</span><span class="st"> </span>SEM<span class="op">$</span>tarX <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb443-2" title="2">Omega &lt;-<span class="st"> </span><span class="kw">invIrW</span>(lw_q_B, <span class="dt">rho=</span>SEM<span class="op">$</span>lambda)</a>
<a class="sourceLine" id="cb443-3" title="3">locmsO &lt;-<span class="st"> </span><span class="kw">localmoran.sad</span>(lm.target, <span class="dt">nb=</span>nb_q, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>, <span class="dt">alternative=</span><span class="st">&quot;two.sided&quot;</span>,</a>
<a class="sourceLine" id="cb443-4" title="4">                         <span class="dt">Omega=</span>Omega)</a>
<a class="sourceLine" id="cb443-5" title="5">locmsO &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(locmsO)</a>
<a class="sourceLine" id="cb443-6" title="6">pvssO &lt;-<span class="st"> </span><span class="kw">cbind</span>(locmsO[,<span class="dv">5</span>], <span class="kw">p.adjust</span>(locmsO[,<span class="dv">5</span>], <span class="st">&quot;bonferroni&quot;</span>),</a>
<a class="sourceLine" id="cb443-7" title="7">               <span class="kw">p.adjust</span>(locmsO[,<span class="dv">5</span>], <span class="st">&quot;fdr&quot;</span>), <span class="kw">p.adjust</span>(locmsO[,<span class="dv">5</span>], <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb443-8" title="8"><span class="kw">colnames</span>(pvssO) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb444"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb444-1" title="1"><span class="kw">apply</span>(pvssO, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        167          5         13          4</code></pre>
<p>In the global measure case, bootstrap permutations could be used as an alternative to analytical methods for possible inference. In the local case, conditional permutation may be used, retaining the value at observation <span class="math inline">\(i\)</span> and randomly sampling from the remaining <span class="math inline">\(n-1\)</span> values to find randomised values at neighbours.</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb446-1" title="1">x &lt;-<span class="st"> </span>pol_pres15<span class="op">$</span>I_turnout</a>
<a class="sourceLine" id="cb446-2" title="2">lw &lt;-<span class="st"> </span>lw_q_B</a>
<a class="sourceLine" id="cb446-3" title="3">xx &lt;-<span class="st"> </span><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb446-4" title="4">z &lt;-<span class="st"> </span>x <span class="op">-</span><span class="st"> </span>xx</a>
<a class="sourceLine" id="cb446-5" title="5">s2 &lt;-<span class="st"> </span><span class="kw">sum</span>(z<span class="op">^</span><span class="dv">2</span>)<span class="op">/</span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb446-6" title="6">crd &lt;-<span class="st"> </span><span class="kw">card</span>(lw<span class="op">$</span>neighbours)</a>
<a class="sourceLine" id="cb446-7" title="7">nsim &lt;-<span class="st"> </span><span class="dv">999</span></a>
<a class="sourceLine" id="cb446-8" title="8">res_p &lt;-<span class="st"> </span><span class="kw">numeric</span>(nsim)</a>
<a class="sourceLine" id="cb446-9" title="9">mns &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))</a>
<a class="sourceLine" id="cb446-10" title="10">sds &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))</a>
<a class="sourceLine" id="cb446-11" title="11"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb446-12" title="12"><span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq</span>(<span class="dt">along=</span>x)) {</a>
<a class="sourceLine" id="cb446-13" title="13">  wtsi &lt;-<span class="st"> </span>lw<span class="op">$</span>weights[[i]]</a>
<a class="sourceLine" id="cb446-14" title="14">  zi &lt;-<span class="st"> </span>z[i]</a>
<a class="sourceLine" id="cb446-15" title="15">  z_i &lt;-<span class="st"> </span>z[<span class="op">-</span>i]</a>
<a class="sourceLine" id="cb446-16" title="16">  crdi &lt;-<span class="st"> </span>crd[i]</a>
<a class="sourceLine" id="cb446-17" title="17">  <span class="cf">if</span> (crdi <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb446-18" title="18">    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nsim) {</a>
<a class="sourceLine" id="cb446-19" title="19">      sz_i &lt;-<span class="st"> </span><span class="kw">sample</span>(z_i, <span class="dt">size=</span>crdi)</a>
<a class="sourceLine" id="cb446-20" title="20">      lz_i &lt;-<span class="st"> </span><span class="kw">sum</span>(sz_i<span class="op">*</span>wtsi)</a>
<a class="sourceLine" id="cb446-21" title="21">      res_p[j] &lt;-<span class="st"> </span>(zi<span class="op">/</span>s2)<span class="op">*</span>lz_i</a>
<a class="sourceLine" id="cb446-22" title="22">    }</a>
<a class="sourceLine" id="cb446-23" title="23">    mns[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(res_p)</a>
<a class="sourceLine" id="cb446-24" title="24">    sds[i] &lt;-<span class="st"> </span><span class="kw">sd</span>(res_p)</a>
<a class="sourceLine" id="cb446-25" title="25">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb446-26" title="26">    mns[i] &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb446-27" title="27">    sds[i] &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb446-28" title="28">  }</a>
<a class="sourceLine" id="cb446-29" title="29">}</a></code></pre></div>
<p>This approach is not provided as a function in <strong>spdep</strong>. The outcome is that almost 32% of observations have two sided p-values &lt; 0.05 without multiple comparison correction, and under 3% with Bonferroni correction. Since it is not advisable to use conditional permutation with regression residuals in the presence of spatial autocorrelation, <code>localmoran.sad()</code> and <code>localmoran.exact()</code> provide ways of calculating more robust standard deviates with the added flexibility of a possibly richer mean model.</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb447-1" title="1">perm_Zi &lt;-<span class="st"> </span>(locm[,<span class="dv">1</span>] <span class="op">-</span><span class="st"> </span>mns)<span class="op">/</span>sds</a>
<a class="sourceLine" id="cb447-2" title="2">pv &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(perm_Zi), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb447-3" title="3">pvsp &lt;-<span class="st"> </span><span class="kw">cbind</span>(pv, <span class="kw">p.adjust</span>(pv, <span class="st">&quot;bonferroni&quot;</span>), <span class="kw">p.adjust</span>(pv, <span class="st">&quot;fdr&quot;</span>), </a>
<a class="sourceLine" id="cb447-4" title="4">              <span class="kw">p.adjust</span>(pv, <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb447-5" title="5"><span class="kw">colnames</span>(pvsp) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a>
<a class="sourceLine" id="cb447-6" title="6"><span class="kw">apply</span>(pvsp, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        789         68        477        160</code></pre>
<p>In order to compare the results from <code>localmoran()</code> with the PySAL function in <strong>esda</strong>, we need first to re-run dividing by <span class="math inline">\(n-1\)</span> instead of <span class="math inline">\(n\)</span> in parts of the calculation, by setting the argument <code>mlvar=FALSE</code>.</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb449-1" title="1">locm_nml &lt;-<span class="st"> </span><span class="kw">localmoran</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B, </a>
<a class="sourceLine" id="cb449-2" title="2">                       <span class="dt">alternative=</span><span class="st">&quot;two.sided&quot;</span>, <span class="dt">mlvar=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<p>Once this is done, the local estimates of Moran’s <span class="math inline">\(I\)</span> agree within machine precision.</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb450-1" title="1">np<span class="op">$</span>random<span class="op">$</span><span class="kw">seed</span>(1L)</a>
<a class="sourceLine" id="cb450-2" title="2">loc_I_ps &lt;-<span class="st"> </span>esda<span class="op">$</span><span class="kw">Moran_Local</span>(pol_pres15<span class="op">$</span>I_turnout, nb_gal_ps, <span class="dt">transformation=</span><span class="st">&quot;B&quot;</span>, <span class="dt">permutations=</span>999L)</a>
<a class="sourceLine" id="cb450-3" title="3"><span class="kw">all.equal</span>(<span class="kw">unname</span>(locm_nml[,<span class="dv">1</span>]), <span class="kw">c</span>(loc_I_ps<span class="op">$</span>Is))</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>The PySAL outcomes after adjusting for multiple comparisons are also similar to those shown above:</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb452-1" title="1">pv &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(loc_I_ps<span class="op">$</span>z_sim), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb452-2" title="2">pvsp &lt;-<span class="st"> </span><span class="kw">cbind</span>(pv, <span class="kw">p.adjust</span>(pv, <span class="st">&quot;bonferroni&quot;</span>), <span class="kw">p.adjust</span>(pv, <span class="st">&quot;fdr&quot;</span>), </a>
<a class="sourceLine" id="cb452-3" title="3">              <span class="kw">p.adjust</span>(pv, <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb452-4" title="4"><span class="kw">colnames</span>(pvsp) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a>
<a class="sourceLine" id="cb452-5" title="5"><span class="kw">apply</span>(pvsp, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        795         74        475        159</code></pre>
<p>The figure shows the breadth of the density distribution of the standard deviates calculated using the analytical randomisation approach, compared with those of Saddlepoint approximation with and without the accommodation of global spatial autocorrelation, and with conditional permutation.</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb454-1" title="1">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">std_deviate=</span><span class="kw">c</span>(locm[,<span class="dv">4</span>], locms[,<span class="dv">4</span>], locmsO[,<span class="dv">4</span>], perm_Zi,</a>
<a class="sourceLine" id="cb454-2" title="2">        loc_I_ps<span class="op">$</span>z_sim), <span class="dt">method=</span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;Analytical randomisation&quot;</span>, </a>
<a class="sourceLine" id="cb454-3" title="3">        <span class="st">&quot;Saddlepoint approximation&quot;</span>, <span class="st">&quot;Saddlepoint approximation (Omega)&quot;</span>, </a>
<a class="sourceLine" id="cb454-4" title="4">        <span class="st">&quot;Conditional permutation&quot;</span>, <span class="st">&quot;Conditional permutation (PySAL)&quot;</span>), <span class="dt">each=</span><span class="dv">2495</span>))</a>
<a class="sourceLine" id="cb454-5" title="5"><span class="kw">library</span>(ggplot2)</a>
<a class="sourceLine" id="cb454-6" title="6"><span class="kw">ggplot</span>(df) <span class="op">+</span><span class="st"> </span><span class="kw">geom_density</span>(<span class="kw">aes</span>(<span class="dt">x=</span>std_deviate, <span class="dt">fill=</span>method), <span class="dt">alpha=</span><span class="fl">0.2</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb454-7" title="7"><span class="st">  </span><span class="kw">xlim</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">6</span>, <span class="dv">12</span>))</a></code></pre></div>
<pre><code># Warning: Removed 26 rows containing non-finite values (stat_density).</code></pre>
<div class="figure" style="text-align: center"><span id="fig:localmoranZi"></span>
<img src="sds_files/figure-html/localmoranZi-1.png" alt="Local Moran's I standard deviates by method" width="100%" />
<p class="caption">
Figure 14.5: Local Moran’s I standard deviates by method
</p>
</div>
<p>The figure and the tabulated summaries of the standard deviates by method show that in this case the conditional permutations shift the medians and third quartiles of the distributions rightwards compared to the analytical standard deviates, yielding larger numbers of apparently “significantly” locally autocorelated areal units than, say, the Saddlepoint approximation.</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb456-1" title="1"><span class="kw">print</span>(<span class="kw">do.call</span>(<span class="st">&quot;rbind&quot;</span>, <span class="kw">tapply</span>(df<span class="op">$</span>std_deviate, <span class="kw">list</span>(df<span class="op">$</span>method), summary)), </a>
<a class="sourceLine" id="cb456-2" title="2">      <span class="dt">digits=</span><span class="dv">3</span>)</a></code></pre></div>
<pre><code>#                                    Min. 1st Qu. Median   Mean 3rd Qu.  Max.
# Analytical randomisation          -3.90  0.0701  0.691  1.629  2.3183 22.47
# Conditional permutation           -3.07  0.2656  1.235  1.305  2.2613  7.52
# Conditional permutation (PySAL)   -3.10  0.2715  1.242  1.312  2.2773  7.76
# Saddlepoint approximation         -2.66  0.1213  0.950  1.159  2.0047  6.67
# Saddlepoint approximation (Omega) -5.66 -0.8934 -0.379 -0.462  0.0361  2.89</code></pre>
<p>Taking global spatial autocorrelation into account leaves most of the areal units with “significant” local residual spatial autocorrelation below zero, indicating negative dependencies probably associated with urban/rural contrasts. The figure shows the dominance of positive local autocorrelation before the removal of global autocorrelation, and the speckled appearance of the local indocators after its removal using Omega, the global process model.</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb458-1" title="1">pol_pres15<span class="op">$</span>loc_I_SA &lt;-<span class="st"> </span>locms[,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb458-2" title="2">pol_pres15<span class="op">$</span>loc_I_Omega &lt;-<span class="st"> </span>locmsO[,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb458-3" title="3"><span class="kw">tm_shape</span>(pol_pres15) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="kw">c</span>(<span class="st">&quot;loc_I_SA&quot;</span>, <span class="st">&quot;loc_I_Omega&quot;</span>), <span class="dt">midpoint=</span><span class="dv">0</span>, <span class="dt">title=</span><span class="st">&quot;Std. deviate&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_facets</span>(<span class="dt">free.scales=</span><span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_borders</span>(<span class="dt">lwd=</span><span class="fl">0.3</span>, <span class="dt">alpha=</span><span class="fl">0.4</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_layout</span>(<span class="dt">panel.labels=</span><span class="kw">c</span>(<span class="st">&quot;Saddlepoint approximation&quot;</span>, <span class="st">&quot;Omega&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:localmoranZimap"></span>
<img src="sds_files/figure-html/localmoranZimap-1.png" alt="Local Moran's I standard deviates" width="100%" />
<p class="caption">
Figure 14.6: Local Moran’s I standard deviates
</p>
</div>
<p>The local Getis-Ord <span class="math inline">\(G\)</span> measure is reported as a standard deviate, and may also take the <span class="math inline">\(G^*\)</span> form where self-neighbours are inserted into the neighbour object using <code>include.self()</code>. The observed and expected values of local <span class="math inline">\(G\)</span> with their analytical variances may also be returned if <code>return_internals=TRUE</code>. The <code>GeoDa=</code> argument changes summation behaviour when no-neighbour observations are present, dropping values of <code>x</code> from sums.</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb459-1" title="1"><span class="kw">args</span>(localG)</a></code></pre></div>
<pre><code># function (x, listw, zero.policy = NULL, spChk = NULL, return_internals = FALSE, 
#     GeoDa = FALSE) 
# NULL</code></pre>
<div class="sourceCode" id="cb461"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb461-1" title="1">locG &lt;-<span class="st"> </span><span class="kw">localG</span>(pol_pres15<span class="op">$</span>I_turnout, lw_q_B, <span class="dt">return_internals=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p>Once again we face the problem of multiple comparisons, with the count of areal unit p-values &lt; 0.05 being reduced by an order of magnitude when employing Bonferroni correction:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb462-1" title="1">pv &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(<span class="kw">c</span>(locG)), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb462-2" title="2">pvsp &lt;-<span class="st"> </span><span class="kw">cbind</span>(pv, <span class="kw">p.adjust</span>(pv, <span class="st">&quot;bonferroni&quot;</span>), <span class="kw">p.adjust</span>(pv, <span class="st">&quot;fdr&quot;</span>), </a>
<a class="sourceLine" id="cb462-3" title="3">              <span class="kw">p.adjust</span>(pv, <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb462-4" title="4"><span class="kw">colnames</span>(pvsp) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a>
<a class="sourceLine" id="cb462-5" title="5"><span class="kw">apply</span>(pvsp, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        789         69        468        156</code></pre>
<p>The PySAL <strong>esda</strong> <code>G_Local()</code> function returns the same basic values, resulting in the same local standard deviates:</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb464-1" title="1">np<span class="op">$</span>random<span class="op">$</span><span class="kw">seed</span>(1L)</a>
<a class="sourceLine" id="cb464-2" title="2">loc_G_ps &lt;-<span class="st"> </span>esda<span class="op">$</span><span class="kw">G_Local</span>(pol_pres15<span class="op">$</span>I_turnout, nb_gal_ps, <span class="dt">transform=</span><span class="st">&quot;B&quot;</span>, <span class="dt">permutations=</span>999L)</a>
<a class="sourceLine" id="cb464-3" title="3"><span class="kw">all.equal</span>(<span class="kw">c</span>(locG), <span class="kw">c</span>(loc_G_ps<span class="op">$</span>Zs))</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>Code for conditional permutation is not included in <strong>spdep</strong>, but is not difficult to construct:</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb466-1" title="1">x &lt;-<span class="st"> </span>pol_pres15<span class="op">$</span>I_turnout</a>
<a class="sourceLine" id="cb466-2" title="2">lw &lt;-<span class="st"> </span>lw_q_B</a>
<a class="sourceLine" id="cb466-3" title="3">crd &lt;-<span class="st"> </span><span class="kw">card</span>(lw<span class="op">$</span>neighbours)</a>
<a class="sourceLine" id="cb466-4" title="4">nsim &lt;-<span class="st"> </span><span class="dv">999</span></a>
<a class="sourceLine" id="cb466-5" title="5">res &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">nrow=</span><span class="kw">length</span>(x), <span class="dt">ncol=</span>nsim)</a>
<a class="sourceLine" id="cb466-6" title="6"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb466-7" title="7">x_star &lt;-<span class="st"> </span><span class="kw">sum</span>(x[crd <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>])</a>
<a class="sourceLine" id="cb466-8" title="8"><span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq</span>(<span class="dt">along=</span>x)) {</a>
<a class="sourceLine" id="cb466-9" title="9">  wtsi &lt;-<span class="st"> </span>lw<span class="op">$</span>weights[[i]]</a>
<a class="sourceLine" id="cb466-10" title="10">  xi &lt;-<span class="st"> </span>x[i]</a>
<a class="sourceLine" id="cb466-11" title="11">  x_i &lt;-<span class="st"> </span>x[<span class="op">-</span>i]</a>
<a class="sourceLine" id="cb466-12" title="12">  crdi &lt;-<span class="st"> </span>crd[i]</a>
<a class="sourceLine" id="cb466-13" title="13">  <span class="cf">if</span> (crdi <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb466-14" title="14">    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nsim) {</a>
<a class="sourceLine" id="cb466-15" title="15">      sx_i &lt;-<span class="st"> </span><span class="kw">sample</span>(x_i, <span class="dt">size=</span>crdi)</a>
<a class="sourceLine" id="cb466-16" title="16">      lx_i &lt;-<span class="st"> </span><span class="kw">sum</span>(sx_i<span class="op">*</span>wtsi)</a>
<a class="sourceLine" id="cb466-17" title="17">      res[i, j] &lt;-<span class="st"> </span>lx_i<span class="op">/</span>(x_star<span class="op">-</span>xi)</a>
<a class="sourceLine" id="cb466-18" title="18">    }</a>
<a class="sourceLine" id="cb466-19" title="19">  }</a>
<a class="sourceLine" id="cb466-20" title="20">}</a></code></pre></div>
<p>If we follow <code>esda$G_Local()</code> and construct the permutation standard deviates from the average and standard deviation of the complete set of simulated local <span class="math inline">\(G\)</span> values, it seems that the distribution of values is much closer to zero; the R case:</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb467-1" title="1">G_obs &lt;-<span class="st"> </span><span class="kw">attr</span>(locG, <span class="st">&quot;internals&quot;</span>)[,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb467-2" title="2">G_Zi &lt;-<span class="st"> </span>(G_obs <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(res))<span class="op">/</span><span class="kw">sd</span>(res) <span class="co"># code follows PySAL esda$G_Local()</span></a>
<a class="sourceLine" id="cb467-3" title="3">pv &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(<span class="kw">c</span>(G_Zi)), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb467-4" title="4">pvsp &lt;-<span class="st"> </span><span class="kw">cbind</span>(pv, <span class="kw">p.adjust</span>(pv, <span class="st">&quot;bonferroni&quot;</span>), <span class="kw">p.adjust</span>(pv, <span class="st">&quot;fdr&quot;</span>), </a>
<a class="sourceLine" id="cb467-5" title="5">              <span class="kw">p.adjust</span>(pv, <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb467-6" title="6"><span class="kw">colnames</span>(pvsp) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a>
<a class="sourceLine" id="cb467-7" title="7"><span class="kw">apply</span>(pvsp, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        210          5          8          4</code></pre>
<p>and the PySAL case:</p>
<div class="sourceCode" id="cb469"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb469-1" title="1">pv &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(<span class="kw">c</span>(loc_G_ps<span class="op">$</span>z_sim)), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb469-2" title="2">pvsp &lt;-<span class="st"> </span><span class="kw">cbind</span>(pv, <span class="kw">p.adjust</span>(pv, <span class="st">&quot;bonferroni&quot;</span>), <span class="kw">p.adjust</span>(pv, <span class="st">&quot;fdr&quot;</span>), </a>
<a class="sourceLine" id="cb469-3" title="3">              <span class="kw">p.adjust</span>(pv, <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb469-4" title="4"><span class="kw">colnames</span>(pvsp) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a>
<a class="sourceLine" id="cb469-5" title="5"><span class="kw">apply</span>(pvsp, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        787         73        480        157</code></pre>
<p>If however we take the by entity local permutation outputs, averages and standard deviations by row of the simulation matrix, we get back to the relative proportions seen in the analytical standard deviates in the R case:</p>
<div class="sourceCode" id="cb471"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb471-1" title="1">G_Zi_<span class="dv">1</span> &lt;-<span class="st"> </span>(G_obs <span class="op">-</span><span class="st"> </span><span class="kw">apply</span>(res, <span class="dv">1</span>, mean))<span class="op">/</span><span class="kw">apply</span>(res, <span class="dv">1</span>, sd)</a>
<a class="sourceLine" id="cb471-2" title="2">pv &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(<span class="kw">c</span>(G_Zi_<span class="dv">1</span>)), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb471-3" title="3">pvsp &lt;-<span class="st"> </span><span class="kw">cbind</span>(pv, <span class="kw">p.adjust</span>(pv, <span class="st">&quot;bonferroni&quot;</span>), <span class="kw">p.adjust</span>(pv, <span class="st">&quot;fdr&quot;</span>), </a>
<a class="sourceLine" id="cb471-4" title="4">              <span class="kw">p.adjust</span>(pv, <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb471-5" title="5"><span class="kw">colnames</span>(pvsp) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a>
<a class="sourceLine" id="cb471-6" title="6"><span class="kw">apply</span>(pvsp, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        789         68        477        160</code></pre>
<p>and the PySAL case:</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb473-1" title="1">mns_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">apply</span>(loc_G_ps<span class="op">$</span>rGs, <span class="dv">1</span>, mean)</a>
<a class="sourceLine" id="cb473-2" title="2">sds_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">apply</span>(loc_G_ps<span class="op">$</span>rGs, <span class="dv">1</span>, sd)</a>
<a class="sourceLine" id="cb473-3" title="3">z_sim_<span class="dv">1</span> &lt;-<span class="st"> </span>(loc_G_ps<span class="op">$</span>Gs <span class="op">-</span><span class="st"> </span>mns_<span class="dv">1</span>) <span class="op">/</span><span class="st"> </span>sds_<span class="dv">1</span></a>
<a class="sourceLine" id="cb473-4" title="4">pv &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(z_sim_<span class="dv">1</span>), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb473-5" title="5">pvsp &lt;-<span class="st"> </span><span class="kw">cbind</span>(pv, <span class="kw">p.adjust</span>(pv, <span class="st">&quot;bonferroni&quot;</span>), <span class="kw">p.adjust</span>(pv, <span class="st">&quot;fdr&quot;</span>), </a>
<a class="sourceLine" id="cb473-6" title="6">              <span class="kw">p.adjust</span>(pv, <span class="st">&quot;BY&quot;</span>))</a>
<a class="sourceLine" id="cb473-7" title="7"><span class="kw">colnames</span>(pvsp) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;bonferroni&quot;</span>, <span class="st">&quot;fdr&quot;</span>, <span class="st">&quot;BY&quot;</span>)</a>
<a class="sourceLine" id="cb473-8" title="8"><span class="kw">apply</span>(pvsp, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>))</a></code></pre></div>
<pre><code>#       none bonferroni        fdr         BY 
#        787         73        478        157</code></pre>
<p>(<a href="https://github.com/pysal/esda/issues/53" class="uri">https://github.com/pysal/esda/issues/53</a>).</p>
<div class="sourceCode" id="cb475"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb475-1" title="1">pol_pres15<span class="op">$</span>loc_G_Zi_perm &lt;-<span class="st"> </span>G_Zi_<span class="dv">1</span></a>
<a class="sourceLine" id="cb475-2" title="2">pol_pres15<span class="op">$</span>loc_G_Zi &lt;-<span class="st"> </span><span class="kw">c</span>(locG)</a>
<a class="sourceLine" id="cb475-3" title="3"><span class="kw">tm_shape</span>(pol_pres15) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="kw">c</span>(<span class="st">&quot;loc_G_Zi&quot;</span>, <span class="st">&quot;loc_G_Zi_perm&quot;</span>), <span class="dt">midpoint=</span><span class="dv">0</span>, <span class="dt">title=</span><span class="st">&quot;Std. deviate&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_facets</span>(<span class="dt">free.scales=</span><span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_borders</span>(<span class="dt">lwd=</span><span class="fl">0.3</span>, <span class="dt">alpha=</span><span class="fl">0.4</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_layout</span>(<span class="dt">panel.labels=</span><span class="kw">c</span>(<span class="st">&quot;Analytical&quot;</span>, <span class="st">&quot;Permutation&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:localGimap"></span>
<img src="sds_files/figure-html/localGimap-1.png" alt="Local G standard deviates" width="100%" />
<p class="caption">
Figure 14.7: Local G standard deviates
</p>
</div>
</div>
</div>
<div id="spatial-heterogeneity" class="section level2">
<h2><span class="header-section-number">14.4</span> Spatial heterogeneity</h2>
<p>Over and above local and global spatial autocorrelation, areal data are affected by heterogeneity. In some cases, this heterogeneity may be modelled in the mean model through included covariates, or possibly using unstructured random effects, which may also reflect the differing scales of spatial process footprints. Here we will only mention two specifically spatial approaches, the local spatial heteroscedasticity (LOSH) statistic and Moran eigenvectors.</p>
<div id="local-spatial-heteroscedasticity-losh-statistic" class="section level3">
<h3><span class="header-section-number">14.4.1</span> Local spatial heteroscedasticity (LOSH) statistic</h3>
<p>Local spatial heteroscedasticity (LOSH) statistics were introduced fairly recently, and an implementation was contributed to <strong>spdep</strong> even more recently, so there is as yet little experience with the approach <span class="citation">(Ord and Getis <a href="#ref-ord+getis12">2012</a>)</span>. It has been extended to provide bootstrap p-values for the measures of heterogeneity <span class="citation">(Xu, Mei, and Yan <a href="#ref-xuetal14">2014</a>)</span>. The <code>a=</code> argument takes a default value of <span class="math inline">\(2\)</span>, giving a Chi-squared interpretation to output.</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb476-1" title="1"><span class="kw">args</span>(LOSH)</a></code></pre></div>
<pre><code># function (x, listw, a = 2, var_hi = TRUE, zero.policy = NULL, 
#     na.action = na.fail, spChk = NULL) 
# NULL</code></pre>
<div class="sourceCode" id="cb478"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb478-1" title="1">lh &lt;-<span class="st"> </span><span class="kw">LOSH</span>(pol_pres15<span class="op">$</span>I_turnout, <span class="dt">listw=</span>lw_q_B)</a></code></pre></div>
<p>It is also possible to map local spatially weighted mean values derived from the local measures, showing a smoothing effect</p>
<div class="sourceCode" id="cb479"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb479-1" title="1">pol_pres15<span class="op">$</span>x_bar_i &lt;-<span class="st"> </span>lh[,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb479-2" title="2"><span class="kw">tm_shape</span>(pol_pres15) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="kw">c</span>(<span class="st">&quot;I_turnout&quot;</span>, <span class="st">&quot;x_bar_i&quot;</span>), <span class="dt">title=</span><span class="st">&quot;Turnout&quot;</span>, <span class="dt">n=</span><span class="dv">6</span>, <span class="dt">style=</span><span class="st">&quot;fisher&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_facets</span>(<span class="dt">free.scales=</span><span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_borders</span>(<span class="dt">lwd=</span><span class="fl">0.3</span>, <span class="dt">alpha=</span><span class="fl">0.4</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_layout</span>(<span class="dt">panel.labels=</span><span class="kw">c</span>(<span class="st">&quot;Turnout&quot;</span>, <span class="st">&quot;Weighted means&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:localHimap"></span>
<img src="sds_files/figure-html/localHimap-1.png" alt="Local spatially weighted mean values" width="100%" />
<p class="caption">
Figure 14.8: Local spatially weighted mean values
</p>
</div>
<p>These approaches have been further extended but as yet without implementations in R <span class="citation">(Westerholt, Resch, and Zipf <a href="#ref-westerholtetal15">2015</a>; Westerholt et al. <a href="#ref-westerholtetal18">2018</a>)</span>.</p>
</div>
<div id="moran-eigenvectors" class="section level3">
<h3><span class="header-section-number">14.4.2</span> Moran eigenvectors</h3>
<p>There is a close connection between Moran’s <span class="math inline">\(I\)</span> and the eigenproblem of the doubly centred weights matrix, and again with the spatial pattern of a variable of interest and combinations of eigenvectors of the same matrix <span class="citation">(Griffith <a href="#ref-griffith03">2003</a>, <a href="#ref-griffith10">2010</a>; Chun and Griffith <a href="#ref-chun+griffith:13">2013</a>)</span>. There is a literature in numerical ecology using the term of principle coordinates of neighbour matrices for the same approach. The value of global Moran’s <span class="math inline">\(I\)</span> can be calculated using the <code>hat</code> matrix to centre the variable of interest in taking the cross products which yield Moran’s <span class="math inline">\(I\)</span>.</p>
<div class="sourceCode" id="cb480"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb480-1" title="1">n &lt;-<span class="st"> </span><span class="kw">nrow</span>(pol_pres15)</a>
<a class="sourceLine" id="cb480-2" title="2">ones &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, n)</a>
<a class="sourceLine" id="cb480-3" title="3">hat &lt;-<span class="st"> </span>(<span class="kw">diag</span>(n) <span class="op">-</span><span class="st"> </span><span class="kw">tcrossprod</span>(ones) <span class="op">/</span><span class="st"> </span>n)</a>
<a class="sourceLine" id="cb480-4" title="4">Cmat &lt;-<span class="st"> </span>hat <span class="op">%*%</span><span class="st"> </span><span class="kw">listw2mat</span>(lw_q_B) <span class="op">%*%</span><span class="st"> </span>hat</a>
<a class="sourceLine" id="cb480-5" title="5">x &lt;-<span class="st"> </span>pol_pres15<span class="op">$</span>I_turnout</a>
<a class="sourceLine" id="cb480-6" title="6">I_MCM &lt;-<span class="st"> </span><span class="kw">c</span>((n<span class="op">/</span><span class="kw">Szero</span>(lw_q_B) <span class="op">*</span><span class="st"> </span><span class="kw">crossprod</span>(x, Cmat <span class="op">%*%</span><span class="st"> </span>x)<span class="op">/</span><span class="kw">crossprod</span>(x, hat <span class="op">%*%</span><span class="st"> </span>x)))</a></code></pre></div>
<div class="sourceCode" id="cb481"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb481-1" title="1">I_MCM</a></code></pre></div>
<pre><code># [1] 0.691</code></pre>
<p>The solution to the eigenproblem of matrix product gives us the eigenvectors, providing key information about the linkage structure of the graph of neighbours.</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb483-1" title="1">EV &lt;-<span class="st"> </span><span class="kw">eigen</span>(Cmat)<span class="op">$</span>vectors</a></code></pre></div>
<div class="sourceCode" id="cb484"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb484-1" title="1">pol_pres15<span class="op">$</span>EV1 &lt;-<span class="st"> </span>EVa[,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb484-2" title="2">pol_pres15<span class="op">$</span>EV2 &lt;-<span class="st"> </span>EVa[,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb484-3" title="3">pol_pres15<span class="op">$</span>EV3 &lt;-<span class="st"> </span>EVa[,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb484-4" title="4">pol_pres15<span class="op">$</span>EV4 &lt;-<span class="st"> </span>EVa[,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb484-5" title="5"><span class="kw">tm_shape</span>(pol_pres15) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="kw">c</span>(<span class="st">&quot;EV1&quot;</span>, <span class="st">&quot;EV2&quot;</span>, <span class="st">&quot;EV3&quot;</span>, <span class="st">&quot;EV4&quot;</span>), <span class="dt">midpoint=</span><span class="dv">0</span>, <span class="dt">title=</span><span class="st">&quot;Eigenvectors&quot;</span>, <span class="dt">n=</span><span class="dv">6</span>, <span class="dt">style=</span><span class="st">&quot;fisher&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_facets</span>(<span class="dt">free.scales=</span><span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_borders</span>(<span class="dt">lwd=</span><span class="fl">0.3</span>, <span class="dt">alpha=</span><span class="fl">0.4</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_layout</span>(<span class="dt">panel.labels=</span><span class="kw">c</span>(<span class="st">&quot;EV 1&quot;</span>, <span class="st">&quot;EV 2&quot;</span>, <span class="st">&quot;EV 3&quot;</span>, <span class="st">&quot;EV 4&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:EVmap"></span>
<img src="sds_files/figure-html/EVmap-1.png" alt="First four eigenvectors" width="100%" />
<p class="caption">
Figure 14.9: First four eigenvectors
</p>
</div>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-anselin:95">
<p>Anselin, L. 1995. “Local indicators of spatial association - LISA.” <em>Geographical Analysis</em> 27 (2): 93–115.</p>
</div>
<div id="ref-anselin:96">
<p>Anselin, L. 1996. “The Moran Scatterplot as an ESDA Tool to Assess Local Instability in Spatial Association.” In <em>Spatial Analytical Perspectives on GIS</em>, edited by M. M. Fischer, H. J. Scholten, and D. Unwin, 111–25. London: Taylor &amp; Francis.</p>
</div>
<div id="ref-assuncao+reis:99">
<p>Assunção, R.M., and E. A. Reis. 1999. “A New Proposal to Adjust Moran’s <span class="math inline">\(I\)</span> for Population Density.” <em>Statistics in Medicine</em> 18: 2147–62.</p>
</div>
<div id="ref-avis+horton:1985">
<p>Avis, D., and J. Horton. 1985. “Remarks on the Sphere of Influence Graph.” In <em>Discrete Geometry and Convexity</em>, edited by J. E. Goodman, 323–27. New York: New York Academy of Sciences, New York.</p>
</div>
<div id="ref-bavaud:98">
<p>Bavaud, F. 1998. “Models for Spatial Weights: A Systematic Look.” <em>Geographical Analysis</em> 30: 153–71. <a href="https://doi.org/10.1111/j.1538-4632.1998.tb00394.x">https://doi.org/10.1111/j.1538-4632.1998.tb00394.x</a>.</p>
</div>
<div id="ref-Bivand2018">
<p>Bivand, Roger S., and David W. S. Wong. 2018. “Comparing Implementations of Global and Local Indicators of Spatial Association.” <em>TEST</em> 27 (3): 716–48. <a href="https://doi.org/10.1007/s11749-018-0599-x">https://doi.org/10.1007/s11749-018-0599-x</a>.</p>
</div>
<div id="ref-bivandetal:09">
<p>Bivand, R. S., W. Müller, and M. Reder. 2009. “Power Calculations for Global and Local Moran’s <span class="math inline">\(I\)</span>.” <em>Computational Statistics and Data Analysis</em> 53: 2859–72.</p>
</div>
<div id="ref-bivand+portnov:04">
<p>Bivand, R. S., and B. A. Portnov. 2004. “Exploring Spatial Data Analysis Techniques Using R: The Case of Observations with No Neighbours.” In <em>Advances in Spatial Econometrics: Methodology, Tools, Applications</em>, edited by L. Anselin, R. J. G. M. Florax, and S. J. Rey, 121–42. Berlin: Springer.</p>
</div>
<div id="ref-doi:10.1080/13658810601034267">
<p>Boots, B., and A. Okabe. 2007. “Local Statistical Spatial Analysis: Inventory and Prospect.” <em>International Journal of Geographical Information Science</em> 21 (4): 355–75. <a href="https://doi.org/10.1080/13658810601034267">https://doi.org/10.1080/13658810601034267</a>.</p>
</div>
<div id="ref-chun+griffith:13">
<p>Chun, Yongwan, and Daniel A. Griffith. 2013. <em>Spatial Statistics and Geostatistics: Theory and Applications for Geographic Information Science and Technology</em>. Thousand Oaks, CA: Sage.</p>
</div>
<div id="ref-cliff+ord:73">
<p>Cliff, A. D., and J. K. Ord. 1973. <em>Spatial Autocorrelation</em>. London: Pion.</p>
</div>
<div id="ref-cliff+ord:81">
<p>Cliff, A. 1981. <em>Spatial Processes</em>. London: Pion.</p>
</div>
<div id="ref-duncanetal61">
<p>Duncan, O. D., R. P. Cuzzort, and B. Duncan. 1961. <em>Statistical Geography: Problems in Analyzing Areal Data</em>. Glencoe, IL: Free Press.</p>
</div>
<div id="ref-geary:54">
<p>Geary, R. C. 1954. “The Contiguity Ratio and Statistical Mapping.” <em>The Incorporated Statistician</em> 5: 115–45.</p>
</div>
<div id="ref-getis+ord:92">
<p>Getis, A., and J. K. Ord. 1992. “The Analysis of Spatial Association by the Use of Distance Statistics.” <em>Geographical Analysis</em> 24 (2): 189–206.</p>
</div>
<div id="ref-getis+ord:96">
<p>Getis, A., and J. K. Ord. 1992. “The Analysis of Spatial Association by the Use of Distance Statistics.” <em>Geographical Analysis</em> 24 (2): 189–206.</p> 1996. “Local Spatial Statistics: An Overview.” In <em>Spatial Analysis: Modelling in a Gis Environment</em>, edited by P. Longley and M Batty, 261–77. Cambridge: GeoInformation International.</p>
</div>
<div id="ref-griffith10">
<p>Griffith, D. A. 2010. “Spatial Filtering.” In <em>Handbook of Applied Spatial Analysis</em>, edited by Manfred Fischer and Arthur Getis, 301–18. Heidelberg: Springer.</p>
</div>
<div id="ref-griffith03">
<p>Griffith, Daniel A. 2003. <em>Spatial Autocorrelation and Spatial Filtering</em>. New York: Springer.</p>
</div>
<div id="ref-Hepple1998">
<p>Hepple, L. W. 1998. “Exact Testing for Spatial Autocorrelation Among Regression Residuals.” <em>Environment and Planning A</em> 30: 85–108.</p>
</div>
<div id="ref-Lietal07">
<p>Li, Hongfei, Catherine A. Calder, and Noel Cressie. 2007. “Beyond Moran’s I: Testing for Spatial Dependence Based on the Spatial Autoregressive Model.” <em>Geographical Analysis</em> 39: 357–75.</p>
</div>
<div id="ref-Lietal12">
<p>Li, Hongfei, Catherine A. 2012. “One-Step Estimation of Spatial Dependence Parameters: Properties and Extensions of the APLE Statistic.” <em>Journal of Multivariate Analysis</em> 105: 68–84.</p>
</div>
<div id="ref-McMillen:2003">
<p>McMillen, Daniel P. 2003. “Spatial Autocorrelation or Model Misspecification?” <em>International Regional Science Review</em> 26: 208–17.</p>
</div>
<div id="ref-moran48">
<p>Moran, P. A. P. 1948. “The Interpretation of Statistical Maps.” <em>Journal of the Royal Statistical Society, Series B (Methodological)</em> 10 (2): 243–51.</p>
</div>
<div id="ref-doi:10.1080/13658810701587891">
<p>Okabe, A., T. Satoh, T. Furuta, A. Suzuki, and K. Okano. 2008. “Generalized Network Voronoi Diagrams: Concepts, Computational Methods, and Applications.” <em>International Journal of Geographical Information Science</em> 22 (9): 965–94. <a href="https://doi.org/10.1080/13658810701587891">https://doi.org/10.1080/13658810701587891</a>.</p>
</div>
<div id="ref-ord+getis:01">
<p>Ord, J. K., and A. Getis. 2001. “Testing for Local Spatial Autocorrelation in the Presence of Global Autocorrelation.” <em>Journal of Regional Science</em> 41 (3): 411–32.</p>
</div>
<div id="ref-ord+getis12">
<p>Ord, J. 2012. “Local Spatial Heteroscedasticity (LOSH).” <em>Annals of Regional Science</em> 48 (2): 529–39.</p>
</div>
<div id="ref-SHE201570">
<p>She, Bing, Xinyan Zhu, Xinyue Ye, Wei Guo, Kehua Su, and Jay Lee. 2015. “Weighted Network Voronoi Diagrams for Local Spatial Analysis.” <em>Computers, Environment and Urban Systems</em> 52: 70–80. <a href="https://doi.org/https://doi.org/10.1016/j.compenvurbsys.2015.03.005">https://doi.org/https://doi.org/10.1016/j.compenvurbsys.2015.03.005</a>.</p>
</div>
<div id="ref-tiefelsdorf:02">
<p>Tiefelsdorf, M. 2002. “The Saddlepoint Approximation of Moran’s I and Local Moran’s <span class="math inline">\({I}_i\)</span> Reference Distributions and Their Numerical Evaluation.” <em>Geographical Analysis</em> 34: 187–206.</p>
</div>
<div id="ref-TiefelsdorfBoots1995">
<p>Tiefelsdorf, M., and B. N. Boots. 1995. “The Exact Distribution of Moran’s I.” <em>Environment and Planning A</em> 27: 985–99.</p>
</div>
<div id="ref-TiefelsdorfBoots1997">
<p>Tiefelsdorf, M., and B. N. Boots. 1995. “The Exact Distribution of Moran’s I.” <em>Environment and Planning A</em> 27: 985–99.</p> 1997. “A Note on the Extremities of Local Moran’s I and Their Impact on Global Moran’s I.” <em>Geographical Analysis</em> 29: 248–57.</p>
</div>
<div id="ref-tiefelsdorfatal:99">
<p>Tiefelsdorf, M., D. A. Griffith, and B. Boots. 1999. “A Variance-Stabilizing Coding Scheme for Spatial Link Matrices.” <em>Environment and Planning A</em> 31: 165–80.</p>
</div>
<div id="ref-upton+fingleton:85">
<p>Upton, G., and B. Fingleton. 1985. <em>Spatial Data Analysis by Example: Point Pattern and Qualitative Data</em>. New York: Wiley.</p>
</div>
<div id="ref-wall:04">
<p>Wall, M. M. 2004. “A Close Look at the Spatial Structure Implied by the CAR and SAR Models.” <em>Journal of Statistical Planning and Inference</em> 121: 311–24.</p>
</div>
<div id="ref-WallerGotway:2004">
<p>Waller, Lance A., and Carol A. Gotway. 2004. <em>Applied Spatial Statistics for Public Health Data</em>. Hoboken, NJ: John Wiley &amp; Sons.</p>
</div>
<div id="ref-westerholtetal18">
<p>Westerholt, Rene, Bernd Resch, Franz-Benjamin Mocnik, and Dirk Hoffmeister. 2018. “A Statistical Test on the Local Effects of Spatially Structured Variance.” <em>International Journal of Geographical Information Science</em> 32 (3): 571–600. <a href="https://doi.org/10.1080/13658816.2017.1402914">https://doi.org/10.1080/13658816.2017.1402914</a>.</p>
</div>
<div id="ref-westerholtetal15">
<p>Westerholt, Rene, Bernd Resch, and Alexander Zipf. 2015. “A Local Scale-Sensitive Indicator of Spatial Autocorrelation for Assessing High- and Low-Value Clusters in Multiscale Datasets.” <em>International Journal of Geographical Information Science</em> 29 (5): 868–87. <a href="https://doi.org/10.1080/13658816.2014.1002499">https://doi.org/10.1080/13658816.2014.1002499</a>.</p>
</div>
<div id="ref-xuetal14">
<p>Xu, M., C. L. Mei, and N. Yan. 2014. “A Note on the Null Distribution of the Local Spatial Heteroscedasticity (LOSH) Statistic.” <em>Annals of Regional Science</em> 52 (3): 697–710.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="manipulating-attributes-summarise-aggregate-union-sample.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="spatial-regression.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": false
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/edzer/sdsr/edit/master/17-Areal.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
