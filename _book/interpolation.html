<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 16 Interpolation and Geostatistics | Spatial Data Science</title>
  <meta name="description" content="description_xx" />
  <meta name="generator" content="bookdown 0.10 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 16 Interpolation and Geostatistics | Spatial Data Science" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="description_xx" />
  <meta name="github-repo" content="edzer/sdsr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 16 Interpolation and Geostatistics | Spatial Data Science" />
  
  <meta name="twitter:description" content="description_xx" />
  

<meta name="author" content="Edzer Pebesma, Roger Bivand" />


<meta name="date" content="2019-06-19" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="up-and-downscaling.html">
<link rel="next" href="area-data-and-spatial-autcorrelation.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-1.3/htmlwidgets.js"></script>
<link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-1.3.1/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<script src="libs/Proj4Leaflet-1.0.1/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script>
<link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-binding-2.0.2/leaflet.js"></script>
<script src="libs/leaflet-providers-1.1.17/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-2.0.2/leaflet-providers-plugin.js"></script>
<link href="libs/HomeButton-0.0.1/home-button.css" rel="stylesheet" />
<script src="libs/HomeButton-0.0.1/home-button.js"></script>
<script src="libs/HomeButton-0.0.1/easy-button-src.min.js"></script>
<link href="libs/PopupTable-0.0.1/popup.css" rel="stylesheet" />


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Spatial Data Science</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="part"><span><b>I Spatial Data</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Getting Started</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#a-first-map"><i class="fa fa-check"></i><b>1.1</b> A first map</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#reading"><i class="fa fa-check"></i><b>1.2</b> Reading and writing</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.3</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="cs.html"><a href="cs.html"><i class="fa fa-check"></i><b>2</b> Coordinate systems</a><ul>
<li class="chapter" data-level="2.1" data-path="cs.html"><a href="cs.html#cartesian-and-geodetic-coordinates"><i class="fa fa-check"></i><b>2.1</b> Cartesian and geodetic coordinates</a></li>
<li class="chapter" data-level="2.2" data-path="cs.html"><a href="cs.html#ellipsoidal-coordinates"><i class="fa fa-check"></i><b>2.2</b> Ellipsoidal coordinates</a></li>
<li class="chapter" data-level="2.3" data-path="cs.html"><a href="cs.html#distances"><i class="fa fa-check"></i><b>2.3</b> Distances</a></li>
<li class="chapter" data-level="2.4" data-path="cs.html"><a href="cs.html#bounded-spaces"><i class="fa fa-check"></i><b>2.4</b> Bounded spaces</a></li>
<li class="chapter" data-level="2.5" data-path="cs.html"><a href="cs.html#time"><i class="fa fa-check"></i><b>2.5</b> Time</a></li>
<li class="chapter" data-level="2.6" data-path="cs.html"><a href="cs.html#exercises-1"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="geometries.html"><a href="geometries.html"><i class="fa fa-check"></i><b>3</b> Geometries</a><ul>
<li class="chapter" data-level="3.1" data-path="geometries.html"><a href="geometries.html#simple-feature-geometry-types"><i class="fa fa-check"></i><b>3.1</b> Simple feature geometry types</a></li>
<li class="chapter" data-level="3.2" data-path="geometries.html"><a href="geometries.html#simple-features-in-sf"><i class="fa fa-check"></i><b>3.2</b> Simple features in <code>sf</code></a></li>
<li class="chapter" data-level="3.3" data-path="geometries.html"><a href="geometries.html#geomraster"><i class="fa fa-check"></i><b>3.3</b> Tesselations: coverages, rasters</a></li>
<li class="chapter" data-level="3.4" data-path="geometries.html"><a href="geometries.html#networks"><i class="fa fa-check"></i><b>3.4</b> Networks</a></li>
<li class="chapter" data-level="3.5" data-path="geometries.html"><a href="geometries.html#geometries-on-the-sphere"><i class="fa fa-check"></i><b>3.5</b> Geometries on the sphere</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="raster.html"><a href="raster.html"><i class="fa fa-check"></i><b>4</b> Raster and vector datacubes</a><ul>
<li class="chapter" data-level="4.1" data-path="raster.html"><a href="raster.html#package-stars"><i class="fa fa-check"></i><b>4.1</b> Package <code>stars</code></a></li>
<li class="chapter" data-level="4.2" data-path="raster.html"><a href="raster.html#raster-data"><i class="fa fa-check"></i><b>4.2</b> Raster data</a></li>
<li class="chapter" data-level="4.3" data-path="raster.html"><a href="raster.html#datacubes"><i class="fa fa-check"></i><b>4.3</b> Vector Datacubes</a></li>
<li class="chapter" data-level="4.4" data-path="raster.html"><a href="raster.html#exercises-2"><i class="fa fa-check"></i><b>4.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="geommanip.html"><a href="geommanip.html"><i class="fa fa-check"></i><b>5</b> Manipulating Geometries</a><ul>
<li class="chapter" data-level="5.1" data-path="geommanip.html"><a href="geommanip.html#predicates"><i class="fa fa-check"></i><b>5.1</b> Predicates</a></li>
<li class="chapter" data-level="5.2" data-path="geommanip.html"><a href="geommanip.html#measures"><i class="fa fa-check"></i><b>5.2</b> Measures</a></li>
<li class="chapter" data-level="5.3" data-path="geommanip.html"><a href="geommanip.html#geometry-generating-functions"><i class="fa fa-check"></i><b>5.3</b> Geometry generating functions</a></li>
<li class="chapter" data-level="5.4" data-path="geommanip.html"><a href="geommanip.html#precision"><i class="fa fa-check"></i><b>5.4</b> Precision</a></li>
<li class="chapter" data-level="5.5" data-path="geommanip.html"><a href="geommanip.html#invalid"><i class="fa fa-check"></i><b>5.5</b> Generating invalid geometries</a></li>
<li class="chapter" data-level="5.6" data-path="geommanip.html"><a href="geommanip.html#longlat"><i class="fa fa-check"></i><b>5.6</b> Warnings for longitude/latitude geometries</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="featureattributes.html"><a href="featureattributes.html"><i class="fa fa-check"></i><b>6</b> Feature attributes</a><ul>
<li class="chapter" data-level="6.1" data-path="featureattributes.html"><a href="featureattributes.html#agr"><i class="fa fa-check"></i><b>6.1</b> Attribute-geometry relationships</a></li>
<li class="chapter" data-level="6.2" data-path="featureattributes.html"><a href="featureattributes.html#spatial-join"><i class="fa fa-check"></i><b>6.2</b> Spatial join</a></li>
<li class="chapter" data-level="6.3" data-path="featureattributes.html"><a href="featureattributes.html#aggregate-and-summarise"><i class="fa fa-check"></i><b>6.3</b> Aggregate and summarise</a></li>
<li class="chapter" data-level="6.4" data-path="featureattributes.html"><a href="featureattributes.html#intersections"><i class="fa fa-check"></i><b>6.4</b> Intersections</a></li>
<li class="chapter" data-level="6.5" data-path="featureattributes.html"><a href="featureattributes.html#area-weighted-interpolation"><i class="fa fa-check"></i><b>6.5</b> Area-weighted interpolation</a></li>
<li class="chapter" data-level="6.6" data-path="featureattributes.html"><a href="featureattributes.html#exercises-3"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="rs.html"><a href="rs.html"><i class="fa fa-check"></i><b>7</b> Reference Systems</a><ul>
<li class="chapter" data-level="7.1" data-path="rs.html"><a href="rs.html#units"><i class="fa fa-check"></i><b>7.1</b> Units of measurement</a></li>
<li class="chapter" data-level="7.2" data-path="rs.html"><a href="rs.html#temporal-reference-systems"><i class="fa fa-check"></i><b>7.2</b> Temporal Reference Systems</a></li>
<li class="chapter" data-level="7.3" data-path="rs.html"><a href="rs.html#crs"><i class="fa fa-check"></i><b>7.3</b> Coordinate Reference Systems</a></li>
</ul></li>
<li class="part"><span><b>II Maps</b></span></li>
<li class="chapter" data-level="8" data-path="plotting.html"><a href="plotting.html"><i class="fa fa-check"></i><b>8</b> Plotting spatial data</a><ul>
<li class="chapter" data-level="8.1" data-path="plotting.html"><a href="plotting.html#transform"><i class="fa fa-check"></i><b>8.1</b> Every plot is a projection</a></li>
<li class="chapter" data-level="8.2" data-path="plotting.html"><a href="plotting.html#plotting-points-lines-polygons-grid-cells"><i class="fa fa-check"></i><b>8.2</b> Plotting points, lines, polygons, grid cells</a></li>
<li class="chapter" data-level="8.3" data-path="plotting.html"><a href="plotting.html#class-intervals"><i class="fa fa-check"></i><b>8.3</b> Class intervals</a></li>
<li class="chapter" data-level="8.4" data-path="plotting.html"><a href="plotting.html#poles-and-datelines"><i class="fa fa-check"></i><b>8.4</b> Poles and datelines</a></li>
<li class="chapter" data-level="8.5" data-path="plotting.html"><a href="plotting.html#graticule"><i class="fa fa-check"></i><b>8.5</b> Graticules and other navigation aids</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="plot.html"><a href="plot.html"><i class="fa fa-check"></i><b>9</b> Base and grid plots</a><ul>
<li class="chapter" data-level="9.1" data-path="plot.html"><a href="plot.html#base-plots"><i class="fa fa-check"></i><b>9.1</b> Base plots</a></li>
<li class="chapter" data-level="9.2" data-path="plot.html"><a href="plot.html#combining-base-plots"><i class="fa fa-check"></i><b>9.2</b> Combining base plots</a></li>
<li class="chapter" data-level="9.3" data-path="plot.html"><a href="plot.html#grid-plots-and-viewports"><i class="fa fa-check"></i><b>9.3</b> Grid plots and viewports</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="ggplot2.html"><a href="ggplot2.html"><i class="fa fa-check"></i><b>10</b> ggplot2</a><ul>
<li class="chapter" data-level="10.1" data-path="ggplot2.html"><a href="ggplot2.html#geom_sf"><i class="fa fa-check"></i><b>10.1</b> <code>geom_sf</code></a></li>
<li class="chapter" data-level="10.2" data-path="ggplot2.html"><a href="ggplot2.html#geom_stars"><i class="fa fa-check"></i><b>10.2</b> <code>geom_stars</code></a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="interactive-maps.html"><a href="interactive-maps.html"><i class="fa fa-check"></i><b>11</b> Interactive Maps</a></li>
<li class="part"><span><b>III Spatial Analysis</b></span></li>
<li class="chapter" data-level="12" data-path="summarizing-geometries.html"><a href="summarizing-geometries.html"><i class="fa fa-check"></i><b>12</b> Summarizing Geometries</a></li>
<li class="chapter" data-level="13" data-path="pp.html"><a href="pp.html"><i class="fa fa-check"></i><b>13</b> Point Pattern Analysis</a></li>
<li class="chapter" data-level="14" data-path="manipulating-attributes-summarise-aggregate-union-sample.html"><a href="manipulating-attributes-summarise-aggregate-union-sample.html"><i class="fa fa-check"></i><b>14</b> Manipulating attributes: summarise, aggregate, union, sample</a></li>
<li class="chapter" data-level="15" data-path="up-and-downscaling.html"><a href="up-and-downscaling.html"><i class="fa fa-check"></i><b>15</b> Up- and Downscaling</a></li>
<li class="chapter" data-level="16" data-path="interpolation.html"><a href="interpolation.html"><i class="fa fa-check"></i><b>16</b> Interpolation and Geostatistics</a><ul>
<li class="chapter" data-level="16.1" data-path="interpolation.html"><a href="interpolation.html#preparing-the-air-quality-dataset"><i class="fa fa-check"></i><b>16.1</b> Preparing the air quality dataset</a></li>
<li class="chapter" data-level="16.2" data-path="interpolation.html"><a href="interpolation.html#sample-variogram"><i class="fa fa-check"></i><b>16.2</b> Sample variogram</a></li>
<li class="chapter" data-level="16.3" data-path="interpolation.html"><a href="interpolation.html#fitting-variogram-models"><i class="fa fa-check"></i><b>16.3</b> Fitting variogram models</a></li>
<li class="chapter" data-level="16.4" data-path="interpolation.html"><a href="interpolation.html#kriging"><i class="fa fa-check"></i><b>16.4</b> Kriging interpolation</a></li>
<li class="chapter" data-level="16.5" data-path="interpolation.html"><a href="interpolation.html#areal-means-block-kriging"><i class="fa fa-check"></i><b>16.5</b> Areal means: block kriging</a></li>
<li class="chapter" data-level="16.6" data-path="interpolation.html"><a href="interpolation.html#conditional-and-unconditional-simulation"><i class="fa fa-check"></i><b>16.6</b> Conditional and unconditional simulation</a></li>
<li class="chapter" data-level="16.7" data-path="interpolation.html"><a href="interpolation.html#trend-models"><i class="fa fa-check"></i><b>16.7</b> Trend models</a></li>
<li class="chapter" data-level="16.8" data-path="interpolation.html"><a href="interpolation.html#multivariable-geostatistics"><i class="fa fa-check"></i><b>16.8</b> Multivariable geostatistics</a></li>
<li class="chapter" data-level="16.9" data-path="interpolation.html"><a href="interpolation.html#spatiotemporal-interpolation"><i class="fa fa-check"></i><b>16.9</b> Spatiotemporal interpolation</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="area-data-and-spatial-autcorrelation.html"><a href="area-data-and-spatial-autcorrelation.html"><i class="fa fa-check"></i><b>17</b> Area Data and Spatial Autcorrelation</a><ul>
<li class="chapter" data-level="17.1" data-path="area-data-and-spatial-autcorrelation.html"><a href="area-data-and-spatial-autcorrelation.html#spatial-autocorrelation"><i class="fa fa-check"></i><b>17.1</b> Spatial autocorrelation</a></li>
<li class="chapter" data-level="17.2" data-path="area-data-and-spatial-autcorrelation.html"><a href="area-data-and-spatial-autcorrelation.html#spatial-weights-matrices"><i class="fa fa-check"></i><b>17.2</b> Spatial weights matrices</a></li>
<li class="chapter" data-level="17.3" data-path="area-data-and-spatial-autcorrelation.html"><a href="area-data-and-spatial-autcorrelation.html#measures-of-spatial-autocorrelation"><i class="fa fa-check"></i><b>17.3</b> Measures of spatial autocorrelation</a></li>
<li class="chapter" data-level="17.4" data-path="area-data-and-spatial-autcorrelation.html"><a href="area-data-and-spatial-autcorrelation.html#spatial-heterogeneity"><i class="fa fa-check"></i><b>17.4</b> Spatial heterogeneity</a></li>
</ul></li>
<li class="chapter" data-level="18" data-path="spatial-regression.html"><a href="spatial-regression.html"><i class="fa fa-check"></i><b>18</b> Spatial Regression</a><ul>
<li class="chapter" data-level="18.1" data-path="spatial-regression.html"><a href="spatial-regression.html#spatial-regression-with-spatial-weights"><i class="fa fa-check"></i><b>18.1</b> Spatial regression with spatial weights</a></li>
<li class="chapter" data-level="18.2" data-path="spatial-regression.html"><a href="spatial-regression.html#estimators"><i class="fa fa-check"></i><b>18.2</b> Estimators</a></li>
<li class="chapter" data-level="18.3" data-path="spatial-regression.html"><a href="spatial-regression.html#implementation-details"><i class="fa fa-check"></i><b>18.3</b> Implementation details</a></li>
<li class="chapter" data-level="18.4" data-path="spatial-regression.html"><a href="spatial-regression.html#markov-random-field-and-multilevel-models-with-spatial-weights"><i class="fa fa-check"></i><b>18.4</b> Markov random field and multilevel models with spatial weights</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="movement-data.html"><a href="movement-data.html"><i class="fa fa-check"></i><b>19</b> Movement data</a></li>
<li class="chapter" data-level="20" data-path="statistical-modelling-of-spatiotemporal-data.html"><a href="statistical-modelling-of-spatiotemporal-data.html"><i class="fa fa-check"></i><b>20</b> Statistical modelling of spatiotemporal data</a></li>
<li class="chapter" data-level="21" data-path="sp-and-raster.html"><a href="sp-and-raster.html"><i class="fa fa-check"></i><b>21</b> sp and raster</a><ul>
<li class="chapter" data-level="21.1" data-path="sp-and-raster.html"><a href="sp-and-raster.html#links-and-differences-between-sf-and-sp"><i class="fa fa-check"></i><b>21.1</b> links and differences between sf and sp</a></li>
<li class="chapter" data-level="21.2" data-path="sp-and-raster.html"><a href="sp-and-raster.html#migration-packages"><i class="fa fa-check"></i><b>21.2</b> migration packages</a></li>
<li class="chapter" data-level="21.3" data-path="sp-and-raster.html"><a href="sp-and-raster.html#raster-stars-and-sf"><i class="fa fa-check"></i><b>21.3</b> raster, stars and sf</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="r-data-structures.html"><a href="r-data-structures.html"><i class="fa fa-check"></i>R data structures</a><ul>
<li class="chapter" data-level="21.4" data-path="r-data-structures.html"><a href="r-data-structures.html#homogeneous-vectors"><i class="fa fa-check"></i><b>21.4</b> Homogeneous vectors</a></li>
<li class="chapter" data-level="21.5" data-path="r-data-structures.html"><a href="r-data-structures.html#heterogeneous-vectors-list"><i class="fa fa-check"></i><b>21.5</b> Heterogeneous vectors: list</a></li>
<li class="chapter" data-level="21.6" data-path="r-data-structures.html"><a href="r-data-structures.html#attributes"><i class="fa fa-check"></i><b>21.6</b> Attributes</a></li>
<li class="chapter" data-level="21.7" data-path="r-data-structures.html"><a href="r-data-structures.html#various-names-attributes"><i class="fa fa-check"></i><b>21.7</b> various names attributes</a></li>
<li class="chapter" data-level="21.8" data-path="r-data-structures.html"><a href="r-data-structures.html#using-structure"><i class="fa fa-check"></i><b>21.8</b> using structure</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spatial Data Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="interpolation" class="section level1">
<h1><span class="header-section-number">Chapter 16</span> Interpolation and Geostatistics</h1>
<p>Geostatistics is concerned with the modelling, prediction and simulation of spatially continuous phenomena. The typical problem is a missing value problem: we observe a property of a phenomenon <span class="math inline">\(Z(s)\)</span> at a limited number of sample locations <span class="math inline">\(s_i, i = 1,...,n\)</span>, and are interested in the property value at all locations <span class="math inline">\(s_0\)</span>, so we have to predict it for unobserved locations. This is also called <em>kriging</em>, or Gaussian process prediction. In case <span class="math inline">\(Z(s)\)</span> contains a white noise component <span class="math inline">\(\epsilon\)</span>, as in <span class="math inline">\(Z(s)=S(s)+\epsilon(s)\)</span>, an alternative but similar goal is to predict <span class="math inline">\(S(s)\)</span>, which may be called filtering or smoothing.</p>
<p>In this chapter we will show simple approaches for handling geostatistical data, will demonstrate simple interpolation methods, explore modelling spatial correlation, spatial prediction and simulation. We will use package <code>gstat</code> <span class="citation">(Pebesma and Graeler <a href="#ref-R-gstat">2019</a>, <span class="citation">Pebesma (<a href="#ref-gstatcg">2004</a>)</span>)</span>, which offers a fairly wide palette of models and options for geostatistical analysis.</p>
<div id="preparing-the-air-quality-dataset" class="section level2">
<h2><span class="header-section-number">16.1</span> Preparing the air quality dataset</h2>
<p>The dataset we work with is an air quality dataset obtained from the European Environmental Agency (EEA). European member states report air quality measurements to this Agency. So-called <em>validated</em> data are quality controlled by member states, and are reported on a yearly basis. They form the basis for policy compliancy evaluations.</p>
<p>The EEA’s <a href="https://www.eea.europa.eu/data-and-maps/data/aqereporting-8">air quality e-reporting</a> website gives access to the data reported by European member states. We decided to download hourly (time series) data, which is the data primarily measured. A web form helps convert simple selection criteria into an http request. The following URL</p>
<pre><code>https://fme.discomap.eea.europa.eu/fmedatastreaming/AirQualityDownload/AQData_Extract.fmw?CountryCode=DE&amp;CityName=&amp;Pollutant=8&amp;Year_from=2017&amp;Year_to=2017&amp;Station=&amp;Samplingpoint=&amp;Source=E1a&amp;Output=TEXT&amp;UpdateDate=</code></pre>
<p>was created to select all validated (<code>Source=E1a</code>) <span class="math inline">\(NO_2\)</span> (<code>Pollutant=8</code>) data for 2017 (<code>Year_from</code>, <code>Year_to</code>) from Germany (<code>CountryCode=DE</code>). It returns a text file with a set of URLs to CSV files, each containing the hourly values for the whole period for a single measurement station. These files were downloaded and converted to the right encoding using the <code>dos2unix</code> command line utility.</p>
<p>In the following, we will read all the files into a list,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">files =<span class="st"> </span><span class="kw">list.files</span>(<span class="st">&quot;aq&quot;</span>, <span class="dt">pattern =</span> <span class="st">&quot;*.csv&quot;</span>, <span class="dt">full.names =</span> <span class="ot">TRUE</span>)
r =<span class="st"> </span><span class="kw">lapply</span>(files[<span class="op">-</span><span class="dv">1</span>], <span class="cf">function</span>(f) <span class="kw">read.csv</span>(f))</code></pre></div>
<p>then convert the time variable into a <code>POSIXct</code> variable, and time order them</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.setenv</span>(<span class="dt">TZ =</span> <span class="st">&quot;UTC&quot;</span>) <span class="co"># make sure times are not interpreted as DST</span>
r =<span class="st"> </span><span class="kw">lapply</span>(r, <span class="cf">function</span>(f) {
        f<span class="op">$</span>t =<span class="st"> </span><span class="kw">as.POSIXct</span>(f<span class="op">$</span>DatetimeBegin) 
        f[<span class="kw">order</span>(f<span class="op">$</span>t), ] 
    }
) </code></pre></div>
<p>and we deselect smaller datasets that do not contain hourly data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r =<span class="st"> </span>r[<span class="kw">sapply</span>(r, nrow) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1000</span>]
<span class="kw">names</span>(r) =<span class="st">  </span><span class="kw">sapply</span>(r, <span class="cf">function</span>(f) <span class="kw">unique</span>(f<span class="op">$</span>AirQualityStationEoICode))
<span class="kw">length</span>(r) <span class="op">==</span><span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(<span class="kw">names</span>(r)))
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>and then combine all files using <code>xts::cbind</code>, so that they are matched based on time:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(xts)
r =<span class="st"> </span><span class="kw">lapply</span>(r, <span class="cf">function</span>(f) <span class="kw">xts</span>(f<span class="op">$</span>Concentration, f<span class="op">$</span>t))
aq =<span class="st"> </span><span class="kw">do.call</span>(cbind, r)</code></pre></div>
<p>We can now select those stations for which we have 75% of the hourly values measured, i.e. drop those with more than 25% hourly values missing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># remove stations with more than 75% missing values:</span>
sel =<span class="st"> </span><span class="kw">apply</span>(aq, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(<span class="kw">is.na</span>(x)) <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.75</span> <span class="op">*</span><span class="st"> </span><span class="dv">365</span> <span class="op">*</span><span class="st"> </span><span class="dv">24</span>)
aqsel =<span class="st"> </span>aq[, sel] <span class="co"># stations are in columns</span></code></pre></div>
<p>Next, the <a href="http://ftp.eea.europa.eu/www/AirBase_v8/AirBase_v8_statistics.zip">station metadata</a> was read and filtered for rural background stations in Germany by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">read.csv</span>(<span class="st">&quot;aq/AirBase_v8_stations.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>as_tibble  <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">filter</span>(country_iso_code <span class="op">==</span><span class="st"> &quot;DE&quot;</span>, station_type_of_area <span class="op">==</span><span class="st"> &quot;rural&quot;</span>, 
                 type_of_station <span class="op">==</span><span class="st"> &quot;Background&quot;</span>) -&gt;<span class="st"> </span>a2</code></pre></div>
<p>These stations contain coordinates, and an <code>sf</code> object with (static) station metadata is created by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf)
<span class="kw">library</span>(stars)
a2.sf =<span class="st"> </span><span class="kw">st_as_sf</span>(a2, <span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;station_longitude_deg&quot;</span>, <span class="st">&quot;station_latitude_deg&quot;</span>), <span class="dt">crs =</span> <span class="dv">4326</span>)</code></pre></div>
<p>We now subset the air quality data to stations that are of type rural background:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sel =<span class="st">  </span><span class="kw">colnames</span>(aqsel) <span class="op">%in%</span><span class="st"> </span>a2<span class="op">$</span>station_european_code
aqsel =<span class="st"> </span>aqsel[, sel]</code></pre></div>
<p>We can compute station means, and join these to stations locations by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tb =<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">NO2 =</span> <span class="kw">apply</span>(aqsel, <span class="dv">2</span>, mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), <span class="dt">station_european_code =</span> <span class="kw">colnames</span>(aqsel))
crs =<span class="st"> </span><span class="dv">32632</span>
<span class="kw">right_join</span>(a2.sf, tb) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_transform</span>(crs) -&gt;<span class="st"> </span>no2.sf 
<span class="co">#&gt; Joining, by = &quot;station_european_code&quot;</span>
<span class="co"># load German boundaries</span>
<span class="kw">data</span>(air, <span class="dt">package =</span> <span class="st">&quot;spacetime&quot;</span>)
de &lt;-<span class="st"> </span><span class="kw">st_transform</span>(<span class="kw">st_as_sf</span>(DE_NUTS1), crs)
<span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> de) <span class="op">+</span><span class="st">  </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> no2.sf, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">col =</span> NO2))</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-214-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="sample-variogram" class="section level2">
<h2><span class="header-section-number">16.2</span> Sample variogram</h2>
<p>In order to make spatial predictions using geostatistical methods, we first need to identify a model for the mean and for the spatial correlation. In the simplest model, <span class="math inline">\(Z(s) = m + e(s)\)</span>, the mean is an unknown constant <span class="math inline">\(m\)</span>, and in this case the spatial correlation can be modelled using the variogram, <span class="math inline">\(\gamma(h) = 0.5 E (Z(s)-Z(s+h))^2\)</span>. For processes with a finite variance <span class="math inline">\(C(0)\)</span>, the variogram is related to the covariogram or covariance function through <span class="math inline">\(\gamma(h) = C(0)-C(h)\)</span>.</p>
<p>The sample variogram is obtained by computing estimates of <span class="math inline">\(\gamma(h)\)</span> for distance intervals, <span class="math inline">\(h_i = [h_{i,0},h_{i,1}]\)</span>: <span class="math display">\[
\hat{\gamma}(h_i) = \frac{1}{2N(h_i)}\sum_{j=1}^{N(h_i)}(z(s_i)-z(s_i+h&#39;))^2, \ \ h_{i,0} \le h&#39; &lt; h_{i,1}
\]</span></p>
<p>with <span class="math inline">\(N(h_i)\)</span> the number of sample pairs available for distance interval <span class="math inline">\(h_i\)</span>. Function <code>gstat::variogram</code> computes sample variograms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gstat)
v =<span class="st"> </span><span class="kw">variogram</span>(NO2<span class="op">~</span><span class="dv">1</span>, no2.sf)
<span class="kw">plot</span>(v, <span class="dt">plot.numbers =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-215-1.png" width="672" style="display: block; margin: auto;" /> This chooses default maximum distance (<code>cutoff</code>: one third of the length of the bounding box diagonal) and (constant) interval widths (<code>width</code>: cutoff divided by 15). These defaults can be changed, e.g. by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gstat)
v0 =<span class="st"> </span><span class="kw">variogram</span>(NO2<span class="op">~</span><span class="dv">1</span>, no2.sf, <span class="dt">cutoff =</span> <span class="dv">100000</span>, <span class="dt">width =</span> <span class="dv">10000</span>)
<span class="kw">plot</span>(v0, <span class="dt">plot.numbers =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-216-1.png" width="672" style="display: block; margin: auto;" /> Note that the formula <code>NO2~1</code> is used to select the variable of interest from the data file (<code>NO2</code>), and to specify the mean model: <code>~1</code> refers to an intercept-only (unknown, constant mean) model.</p>
</div>
<div id="fitting-variogram-models" class="section level2">
<h2><span class="header-section-number">16.3</span> Fitting variogram models</h2>
<p>In order to progress toward spatial predictions, we need a variogram <em>model</em> <span class="math inline">\(\gamma(h)\)</span> for (potentially) all distances <span class="math inline">\(h\)</span>, rather than the set of estimates derived above: in case we would for instance connect these estimates with straight lines, or assume they reflect constant values over their respective distance intervals, this would lead to statisical models with non-positive covariance matrices, which is a complicated way of expressing that you are in a lot of trouble.</p>
<p>To avoid these troubles we fit parametric models <span class="math inline">\(\gamma(h)\)</span> to the estimates <span class="math inline">\(\hat{\gamma}(h_i)\)</span>, where we take <span class="math inline">\(h_i\)</span> as the mean value of all the <span class="math inline">\(h&#39;\)</span> values involved in estimating <span class="math inline">\(\hat{\gamma}(h_i)\)</span>. For this, when we fit a model like the exponential variogram,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v.m =<span class="st"> </span><span class="kw">fit.variogram</span>(v, <span class="kw">vgm</span>(<span class="dv">1</span>, <span class="st">&quot;Exp&quot;</span>, <span class="dv">50000</span>, <span class="dv">1</span>))
<span class="kw">plot</span>(v, v.m, <span class="dt">plot.numbers =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-217-1.png" width="672" style="display: block; margin: auto;" /> the fitting is done by minimizing <span class="math inline">\(\sum_{i=1}^{n}w_i(\gamma(h_i)-\hat{\gamma}(h_i))^2\)</span>, with <span class="math inline">\(w_i\)</span> by default equal to <span class="math inline">\(N(h_i)/h^2\)</span>, other fitting schemes are available through argument <code>fit.method</code>.</p>
</div>
<div id="kriging" class="section level2">
<h2><span class="header-section-number">16.4</span> Kriging interpolation</h2>
<p>Kriging involves the prediction of <span class="math inline">\(Z(s_0)\)</span> at arbitrary locations <span class="math inline">\(s_0\)</span>. Typically, when we interpolate a variable, we do that on points on a regular grid covering the target area. When we take the grid points such that they align with the points of our graphics device (screen), then nobody will notice as long as the graphic device is not resized.</p>
<p>We first create a <code>stars</code> object with a raster covering the target area, and NA’s outside it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># build a grid over Germany:</span>
bb =<span class="st"> </span><span class="kw">st_bbox</span>(de)
dx =<span class="st"> </span><span class="kw">seq</span>(bb[<span class="dv">1</span>], bb[<span class="dv">3</span>], <span class="dv">10000</span>)
dy =<span class="st"> </span><span class="kw">seq</span>(bb[<span class="dv">4</span>], bb[<span class="dv">2</span>], <span class="dv">-10000</span>) <span class="co"># decreases!</span>
<span class="kw">st_as_stars</span>(<span class="kw">matrix</span>(<span class="dv">0</span>, <span class="kw">length</span>(dx), <span class="kw">length</span>(dy))) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_set_dimensions</span>(<span class="dv">1</span>, dx) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_set_dimensions</span>(<span class="dv">2</span>, dy) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_set_dimensions</span>(<span class="dt">names =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_set_crs</span>(crs) -&gt;<span class="st"> </span>grd
i =<span class="st"> </span><span class="kw">st_intersects</span>(grd, de)
grd[[<span class="dv">1</span>]][<span class="kw">lengths</span>(i)<span class="op">==</span><span class="dv">0</span>] =<span class="st"> </span><span class="ot">NA</span>
grd
<span class="co">#&gt; stars object with 2 dimensions and 1 attribute</span>
<span class="co">#&gt; attribute(s):</span>
<span class="co">#&gt;       A1       </span>
<span class="co">#&gt;  Min.   :0     </span>
<span class="co">#&gt;  1st Qu.:0     </span>
<span class="co">#&gt;  Median :0     </span>
<span class="co">#&gt;  Mean   :0     </span>
<span class="co">#&gt;  3rd Qu.:0     </span>
<span class="co">#&gt;  Max.   :0     </span>
<span class="co">#&gt;  NA&#39;s   :1793  </span>
<span class="co">#&gt; dimension(s):</span>
<span class="co">#&gt;   from to  offset  delta                       refsys point values    </span>
<span class="co">#&gt; x    1 65  280741  10000 +proj=utm +zone=32 +datum... FALSE   NULL [x]</span>
<span class="co">#&gt; y    1 87 6101239 -10000 +proj=utm +zone=32 +datum... FALSE   NULL [y]</span></code></pre></div>
<p>Then, we can krige by using <code>gstat::krige</code>, with the model for the trend, the data, the prediction grid, and the variogram model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">k =<span class="st"> </span><span class="kw">krige</span>(NO2<span class="op">~</span><span class="dv">1</span>, no2.sf, grd, v.m)
<span class="co">#&gt; [using ordinary kriging]</span>
<span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_stars</span>(<span class="dt">data =</span> k, <span class="kw">aes</span>(<span class="dt">fill =</span> var1.pred, <span class="dt">x =</span> x, <span class="dt">y =</span> y)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> <span class="kw">st_cast</span>(de, <span class="st">&quot;MULTILINESTRING&quot;</span>)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> no2.sf)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-219-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="areal-means-block-kriging" class="section level2">
<h2><span class="header-section-number">16.5</span> Areal means: block kriging</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a =<span class="st"> </span><span class="kw">aggregate</span>(no2.sf[<span class="st">&quot;NO2&quot;</span>], de, mean)
b =<span class="st"> </span><span class="kw">krige</span>(NO2<span class="op">~</span><span class="dv">1</span>, no2.sf, de, v.m)
<span class="co">#&gt; [using ordinary kriging]</span>
b<span class="op">$</span>sample =<span class="st"> </span>a<span class="op">$</span>NO2
b<span class="op">$</span>kriging =<span class="st"> </span>b<span class="op">$</span>var1.pred
b <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(sample, kriging) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">gather</span>(var, NO2, <span class="op">-</span>geometry) -&gt;<span class="st"> </span>b2
<span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> b2, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">fill =</span> NO2)) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span>var) <span class="op">+</span>
<span class="st">     </span><span class="kw">scale_fill_gradientn</span>(<span class="dt">colors =</span> <span class="kw">sf.colors</span>(<span class="dv">20</span>))</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-220-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">SE =<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">sqrt</span>(<span class="kw">var</span>(x)<span class="op">/</span><span class="kw">length</span>(x))
a =<span class="st"> </span><span class="kw">aggregate</span>(no2.sf[<span class="st">&quot;NO2&quot;</span>], de, SE)
b<span class="op">$</span>sample =<span class="st"> </span>a<span class="op">$</span>NO2
b<span class="op">$</span>kriging =<span class="st"> </span><span class="kw">sqrt</span>(b<span class="op">$</span>var1.var)
b <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(sample, kriging) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">gather</span>(var, NO2, <span class="op">-</span>geometry) -&gt;<span class="st"> </span>b2
<span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> b2, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">fill =</span> NO2)) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span>var) <span class="op">+</span>
<span class="st">     </span><span class="kw">scale_fill_gradientn</span>(<span class="dt">colors =</span> <span class="kw">sf.colors</span>(<span class="dv">20</span>))</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-221-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="conditional-and-unconditional-simulation" class="section level2">
<h2><span class="header-section-number">16.6</span> Conditional and unconditional simulation</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(viridis)
s =<span class="st"> </span><span class="kw">krige</span>(NO2<span class="op">~</span><span class="dv">1</span>, no2.sf, grd, v.m, <span class="dt">nmax =</span> <span class="dv">30</span>, <span class="dt">nsim =</span> <span class="dv">10</span>)
<span class="co">#&gt; drawing 10 GLS realisations of beta...</span>
<span class="co">#&gt; [using conditional Gaussian simulation]</span>
g =<span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_equal</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_fill_viridis</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">theme_void</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_x_discrete</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_y_discrete</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>))
g <span class="op">+</span><span class="st"> </span><span class="kw">geom_stars</span>(<span class="dt">data =</span> s[,,,<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span>sample)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-222-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="trend-models" class="section level2">
<h2><span class="header-section-number">16.7</span> Trend models</h2>
<p>Kriging and conditional simulation, as used so far in this chapter, assume that all spatial variability is a random process, characterized by a spatial covariance model. In case we have other variables that are meaningfully correlated with the target variable, we can use them in a linear regression model for the trend, <span class="math display">\[
Z(s) = \sum_{j=0}^p \beta_j X_p(s) + e(s)
\]</span> with <span class="math inline">\(X_0(s) = 1\)</span> and <span class="math inline">\(\beta_0\)</span> an intercept, but with the other <span class="math inline">\(\beta_j\)</span> regression coefficients. This typically reduces both the spatial correlation in the residual <span class="math inline">\(e(s)\)</span>, as well as its variance, and leads to more accurate predictions and more similar conditional simulations.</p>
<div id="a-population-grid" class="section level3">
<h3><span class="header-section-number">16.7.1</span> A population grid</h3>
<p>As a potential predictor for NO2 in the air, we use population density. NO2 is mostly caused by traffic, and traffic is stronger in more densely populated areas. Population density is obtained from the <a href="https://www.zensus2011.de/DE/Home/Aktuelles/DemografischeGrunddaten.html">2011 census</a>, and is downloaded as a csv file with the number of inhabitants per 100 m grid cell. We can aggregate these data to the target grid cells by summing the inhabitants:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(vroom)
v =<span class="st"> </span><span class="kw">vroom</span>(<span class="st">&quot;aq/pop/Zensus_Bevoelkerung_100m-Gitter.csv&quot;</span>)
<span class="co">#&gt; Observations: 35,785,840</span>
<span class="co">#&gt; Variables: 4</span>
<span class="co">#&gt; chr [1]: Gitter_ID_100m</span>
<span class="co">#&gt; dbl [3]: x_mp_100m, y_mp_100m, Einwohner</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call `spec()` for a copy-pastable column specification</span>
<span class="co">#&gt; Specify the column types with `col_types` to quiet this message</span>
v <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(Einwohner <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(<span class="op">-</span>Gitter_ID_100m) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_as_sf</span>(<span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x_mp_100m&quot;</span>, <span class="st">&quot;y_mp_100m&quot;</span>), <span class="dt">crs =</span> <span class="dv">3035</span>) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_transform</span>(<span class="kw">st_crs</span>(grd)) -&gt;<span class="st"> </span>b
a =<span class="st"> </span><span class="kw">aggregate</span>(b, <span class="kw">st_as_sf</span>(grd, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>), sum)</code></pre></div>
<p>Now we have the population counts per grid cell in <code>a</code>. To get to population density, we need to find the area of each cell; for cells crossing the country border, this will be less than 10 x 10 km:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">grd<span class="op">$</span>ID =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">prod</span>(<span class="kw">dim</span>(grd)) <span class="co"># so we can find out later which grid cell we have</span>
ii =<span class="st"> </span><span class="kw">st_intersects</span>(grd[<span class="st">&quot;ID&quot;</span>], <span class="kw">st_cast</span>(<span class="kw">st_union</span>(de), <span class="st">&quot;MULTILINESTRING&quot;</span>))
grd_sf =<span class="st"> </span><span class="kw">st_as_sf</span>(grd[<span class="st">&quot;ID&quot;</span>], <span class="dt">na.rm =</span> <span class="ot">FALSE</span>)[<span class="kw">lengths</span>(ii) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>,]
iii =<span class="st"> </span><span class="kw">st_intersection</span>(grd_sf, <span class="kw">st_union</span>(de))
<span class="co">#&gt; Warning: attribute variables are assumed to be spatially constant</span>
<span class="co">#&gt; throughout all geometries</span>
grd<span class="op">$</span>area =<span class="st"> </span><span class="kw">st_area</span>(grd)[[<span class="dv">1</span>]] <span class="op">+</span><span class="st"> </span>units<span class="op">::</span><span class="kw">set_units</span>(grd<span class="op">$</span>A1, m<span class="op">^</span><span class="dv">2</span>) <span class="co"># NA&#39;s</span>
grd<span class="op">$</span>area[iii<span class="op">$</span>ID] =<span class="st"> </span><span class="kw">st_area</span>(iii)</code></pre></div>
<p>Instead of doing the two-stage procedure above: first finding cells that have a border crossing it, then computing its area, we could also directly use <code>st_intersection</code> on all cells, but that takes considerably longer. From the counts and areas we can compute densities, and verify totals:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">grd<span class="op">$</span>pop_dens =<span class="st"> </span>a<span class="op">$</span>Einwohner <span class="op">/</span><span class="st"> </span>grd<span class="op">$</span>area
<span class="kw">sum</span>(grd<span class="op">$</span>pop_dens <span class="op">*</span><span class="st"> </span>grd<span class="op">$</span>area, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="co"># verify</span>
<span class="co">#&gt; [1] 80323301</span>
<span class="kw">sum</span>(b<span class="op">$</span>Einwohner)
<span class="co">#&gt; [1] 80324282</span>
g <span class="op">+</span><span class="st"> </span><span class="kw">geom_stars</span>(<span class="dt">data =</span> grd, <span class="kw">aes</span>(<span class="dt">fill =</span> <span class="kw">sqrt</span>(pop_dens), <span class="dt">x =</span> x, <span class="dt">y =</span> y))</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-225-1.png" width="672" style="display: block; margin: auto;" /> We need to divide the number of inhabitants by the number of 100 m grid points contributing to it, in order to convert population counts into population density.</p>
<p>To obtain population density values at monitoring network stations, we can use</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">a =</span> <span class="kw">aggregate</span>(grd[<span class="st">&quot;pop_dens&quot;</span>], no2.sf, mean))
<span class="co">#&gt; stars object with 1 dimensions and 1 attribute</span>
<span class="co">#&gt; attribute(s):</span>
<span class="co">#&gt;    pop_dens     </span>
<span class="co">#&gt;  Min.   :0.000  </span>
<span class="co">#&gt;  1st Qu.:0.000  </span>
<span class="co">#&gt;  Median :0.000  </span>
<span class="co">#&gt;  Mean   :0.000  </span>
<span class="co">#&gt;  3rd Qu.:0.000  </span>
<span class="co">#&gt;  Max.   :0.002  </span>
<span class="co">#&gt;  NA&#39;s   :1      </span>
<span class="co">#&gt; dimension(s):</span>
<span class="co">#&gt;          from to offset delta                       refsys point</span>
<span class="co">#&gt; geometry    1 74     NA    NA +proj=utm +zone=32 +datum...  TRUE</span>
<span class="co">#&gt;                                                     values</span>
<span class="co">#&gt; geometry POINT (439814 5938977),...,POINT (456668 5436135)</span>
no2.sf<span class="op">$</span>pop_dens =<span class="st"> </span><span class="kw">st_as_sf</span>(a)[[<span class="dv">1</span>]]
<span class="kw">summary</span>(<span class="kw">lm</span>(NO2<span class="op">~</span><span class="kw">sqrt</span>(pop_dens), no2.sf))
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = NO2 ~ sqrt(pop_dens), data = no2.sf)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt;    Min     1Q Median     3Q    Max </span>
<span class="co">#&gt;  -7.87  -1.82  -0.49   1.56   8.11 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;                Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)       4.627      0.693    6.67  4.6e-09 ***</span>
<span class="co">#&gt; sqrt(pop_dens)  321.802     49.660    6.48  1.0e-08 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residual standard error: 3.13 on 71 degrees of freedom</span>
<span class="co">#&gt;   (1 observation deleted due to missingness)</span>
<span class="co">#&gt; Multiple R-squared:  0.372,  Adjusted R-squared:  0.363 </span>
<span class="co">#&gt; F-statistic:   42 on 1 and 71 DF,  p-value: 1.04e-08</span></code></pre></div>
and the corresponding scatterplot is shown in <a href="interpolation.html#fig:no2scat">16.1</a>.
<div class="figure" style="text-align: center"><span id="fig:no2scat"></span>
<img src="sds_files/figure-html/no2scat-1.png" alt="Scatter plot of 2017 annual mean NO2 concentration against population density, for rural background air quality stations" width="50%" />
<p class="caption">
Figure 16.1: Scatter plot of 2017 annual mean NO2 concentration against population density, for rural background air quality stations
</p>
</div>
<p>Prediction under this new model involves first modelling a residual variogram, by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">no2.sf =<span class="st"> </span>no2.sf[<span class="op">!</span><span class="kw">is.na</span>(no2.sf<span class="op">$</span>pop_dens),]
vr =<span class="st"> </span><span class="kw">variogram</span>(NO2<span class="op">~</span><span class="kw">sqrt</span>(pop_dens), no2.sf)
vr.m =<span class="st"> </span><span class="kw">fit.variogram</span>(vr, <span class="kw">vgm</span>(<span class="dv">1</span>, <span class="st">&quot;Exp&quot;</span>, <span class="dv">50000</span>, <span class="dv">1</span>))
<span class="kw">plot</span>(vr, vr.m, <span class="dt">plot.numbers =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-227-1.png" width="672" style="display: block; margin: auto;" /> and subsequently, kriging prediction is done by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">kr =<span class="st"> </span><span class="kw">krige</span>(NO2<span class="op">~</span><span class="kw">sqrt</span>(pop_dens), no2.sf, grd[<span class="st">&quot;pop_dens&quot;</span>], vr.m)
<span class="co">#&gt; [using universal kriging]</span>
k<span class="op">$</span>kr1 =<span class="st"> </span>k<span class="op">$</span>var1.pred
k<span class="op">$</span>kr2 =<span class="st"> </span>kr<span class="op">$</span>var1.pred
<span class="kw">st_redimension</span>(k[<span class="kw">c</span>(<span class="st">&quot;kr1&quot;</span>, <span class="st">&quot;kr2&quot;</span>)], 
    <span class="dt">along =</span> <span class="kw">list</span>(<span class="dt">what =</span> <span class="kw">c</span>(<span class="st">&quot;kriging&quot;</span>, <span class="st">&quot;residual kriging&quot;</span>))) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">setNames</span>(<span class="st">&quot;NO2&quot;</span>) -&gt;<span class="st"> </span>km
g <span class="op">+</span><span class="st"> </span><span class="kw">geom_stars</span>(<span class="dt">data =</span> km, <span class="kw">aes</span>(<span class="dt">fill =</span> NO2, <span class="dt">x =</span> x, <span class="dt">y =</span> y)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> <span class="kw">st_cast</span>(de, <span class="st">&quot;MULTILINESTRING&quot;</span>)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_sf</span>(<span class="dt">data =</span> no2.sf) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span>what)
<span class="co">#&gt; Coordinate system already present. Adding new coordinate system, which will replace the existing one.</span></code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-228-1.png" width="672" style="display: block; margin: auto;" /> where, critically, the <code>pop_dens</code> values are now available for prediction locations in object <code>grd</code>. We see some clear differences: the map with population density in the trend follows the extremes of the population density rather than those of the measurement stations, and has a range that extends that of the former. It should be taken with a large grain of salt however, since the stations used were filtered for the category “rural background”, indicating that they represent conditions of lower populations density. The scatter plot of Figure <a href="interpolation.html#fig:no2scat">16.1</a> reveals that the the population density at the locations of stations is much more limited than that in the population density map, and hence the right-hand side map is based on strongly extrapolating the relationship shown in <a href="interpolation.html#fig:no2scat">16.1</a>.</p>
</div>
</div>
<div id="multivariable-geostatistics" class="section level2">
<h2><span class="header-section-number">16.8</span> Multivariable geostatistics</h2>
<p>Multivariable geostatics involves the <em>joint</em> modelling, prediction and simulation of multiple variables, <span class="math display">\[Z_1(s) = X_1 \beta_1 + e_1(s)\]</span> <span class="math display">\[...\]</span> <span class="math display">\[Z_n(s) = X_n \beta_n + e_n(s).\]</span> In addition to having observations, trend models, and variograms for each variable, the <em>cross</em> variogram for each pair of residual variables, describing the covariance of <span class="math inline">\(e_i(s), e_j(s+h)\)</span>, is required. If this cross covariance is non-zero, knowledge of <span class="math inline">\(e_j(s+h)\)</span> may help predict (or simulate) <span class="math inline">\(e_i(s)\)</span>. This is especially true if <span class="math inline">\(Z_j(s)\)</span> is more densely sample than <span class="math inline">\(Z_i(s)\)</span>. Prediction and simulation under this model are called cokriging and cosimulation. Examples using gstat are found when running the demo scripts</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gstat)
<span class="kw">demo</span>(cokriging)
<span class="kw">demo</span>(cosimulation)</code></pre></div>
<p>and are illustrated and discussed in <span class="citation">(Bivand, Pebesma, and Gomez-Rubio <a href="#ref-asdar">2013</a>)</span>.</p>
<p>In case the different variables considered are observed at the same set of locations, for instance different air quality parameters, then the statistical <em>gain</em> of using cokriging as opposed to direct (univariable) kriging is often modest, when not negligible. A gain may however be that the prediction is truly multivariable: in addition to the prediction vector <span class="math inline">\(\hat{Z(s_0)}=(\hat{Z}_1(s_0),...,\hat{Z}_n(s_0))\)</span> we get the full covariance matrix of the prediction error <span class="citation">(Ver Hoef and Cressie <a href="#ref-ver1993multivariable">1993</a>)</span>. This means for instance that if we are interested in some linear combination of <span class="math inline">\(\hat{Z}(s_0)\)</span>, such as <span class="math inline">\(\hat{Z}_2(s_0) - \hat{Z}_1(s_0)\)</span>, that we can get the standard error of that combination because we have the correlations between the prediction errors.</p>
<p>Although sets of direct and cross variograms can be computed and fitted automatically, multivariable geostatistical modelling becomes quickly hard to manage when the number of variables gets large, because the number of direct and cross variograms required is <span class="math inline">\(n(n+1)/2\)</span>.</p>
<p>In case different variables refer to the same variable take at different time steps, one could use a multivariable (cokriging) prediction approach, but this would not allow for e.g. interpolation between two time steps. For this, and for handling the case of having data observed at many time instances, one can also model its variation as a function of continuous space <em>and</em> time, as of <span class="math inline">\(Z(s,t)\)</span>, which we will do in the next section.</p>
</div>
<div id="spatiotemporal-interpolation" class="section level2">
<h2><span class="header-section-number">16.9</span> Spatiotemporal interpolation</h2>
<p>Spatiotemporal geostatistical processes are modelled as variables having a value everywhere in space and time, <span class="math inline">\(Z(s,t)\)</span>, with <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> the continuously indext space and time index. Given observations <span class="math inline">\(Z(s_i,t_j)\)</span> and a variogram (covariance) model <span class="math inline">\(\gamma(s,t)\)</span> we can predict <span class="math inline">\(Z(s_0,t_0)\)</span> at arbitrary space/time locations <span class="math inline">\((s_0,t_0)\)</span> using standard Gaussian process theory.</p>
<p>Several books have been written recently about modern approaches to handling and modelling spatiotemporal geostatistical data, including <span class="citation">(Wikle, Zammit-Mangion, and Cressie <a href="#ref-wikle2019spatio">2019</a>)</span> and <span class="citation">(Blangiardo and Cameletti <a href="#ref-blangiardo2015spatial">2015</a>)</span>. Here, we will use <span class="citation">(Gräler, Pebesma, and Heuvelink <a href="#ref-RJ-2016-014">2016</a>)</span> and give some simple examples building upon the dataset used throughout this chapter.</p>
<div id="a-spatiotemporal-variogram-model" class="section level3">
<h3><span class="header-section-number">16.9.1</span> A spatiotemporal variogram model</h3>
<p>Starting with the spatiotemporal matrix of NO<span class="math inline">\(_2\)</span> data in <code>aq</code> constructed at the beginning of this chapter, we will first select the rural background stations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aqx =<span class="st"> </span>aq[,<span class="kw">colnames</span>(aq) <span class="op">%in%</span><span class="st"> </span>a2<span class="op">$</span>station_european_code]
sfc =<span class="st"> </span><span class="kw">st_geometry</span>(a2.sf)[<span class="kw">match</span>(<span class="kw">colnames</span>(aqx), a2.sf<span class="op">$</span>station_european_code)]
<span class="kw">st_as_stars</span>(<span class="dt">NO2 =</span> <span class="kw">as.matrix</span>(aqx)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="dt">names =</span> <span class="kw">c</span>(<span class="st">&quot;time&quot;</span>, <span class="st">&quot;station&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="st">&quot;time&quot;</span>, <span class="kw">index</span>(aqx)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="st">&quot;station&quot;</span>, sfc) -&gt;<span class="st"> </span>no2.st
v.st =<span class="st"> </span><span class="kw">variogramST</span>(NO2<span class="op">~</span><span class="dv">1</span>, no2.st[,<span class="dv">1</span><span class="op">:</span>(<span class="dv">24</span><span class="op">*</span><span class="dv">31</span>)], <span class="dt">tlags =</span> <span class="dv">0</span><span class="op">:</span><span class="dv">48</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v1 =<span class="st"> </span><span class="kw">plot</span>(v.st)
v2 =<span class="st"> </span><span class="kw">plot</span>(v.st, <span class="dt">map =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(v1, <span class="dt">split =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>), <span class="dt">more =</span> <span class="ot">TRUE</span>)
<span class="kw">print</span>(v2, <span class="dt">split =</span> <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>), <span class="dt">more =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-231-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># product-sum</span>
prodSumModel &lt;-<span class="st"> </span><span class="kw">vgmST</span>(<span class="st">&quot;productSum&quot;</span>,
    <span class="dt">space=</span><span class="kw">vgm</span>(<span class="dv">150</span>, <span class="st">&quot;Exp&quot;</span>, <span class="dv">200</span>, <span class="dv">0</span>),
    <span class="dt">time=</span> <span class="kw">vgm</span>(<span class="dv">20</span>, <span class="st">&quot;Sph&quot;</span>,   <span class="dv">40</span>, <span class="dv">0</span>),
    <span class="dt">k=</span><span class="dv">2</span>)
StAni =<span class="st"> </span><span class="kw">estiStAni</span>(v.st, <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">200000</span>))
(fitProdSumModel &lt;-<span class="st"> </span><span class="kw">fit.StVariogram</span>(v.st, prodSumModel, <span class="dt">fit.method =</span> <span class="dv">7</span>,
    <span class="dt">stAni =</span> StAni, <span class="dt">method =</span> <span class="st">&quot;L-BFGS-B&quot;</span>,
    <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">parscale =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="fl">0.1</span>,<span class="dv">1</span>,<span class="dv">10</span>)),
    <span class="dt">lower =</span> <span class="kw">rep</span>(<span class="fl">0.0001</span>, <span class="dv">7</span>)))
<span class="co">#&gt; space component: </span>
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug  26.3     0</span>
<span class="co">#&gt; 2   Exp 140.5   432</span>
<span class="co">#&gt; time component: </span>
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug  1.21   0.0</span>
<span class="co">#&gt; 2   Sph 15.99  40.1</span>
<span class="co">#&gt; k: 0.0322468133959116</span>
<span class="kw">plot</span>(v.st, fitProdSumModel, <span class="dt">wireframe=</span><span class="ot">FALSE</span>, <span class="dt">all=</span><span class="ot">TRUE</span>, <span class="dt">scales=</span><span class="kw">list</span>(<span class="dt">arrows=</span><span class="ot">FALSE</span>), <span class="dt">zlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">150</span>))</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-232-1.png" width="672" style="display: block; margin: auto;" /> which can also be plotted as wireframes, by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(v.st, <span class="dt">model=</span>fitProdSumModel, <span class="dt">wireframe=</span><span class="ot">TRUE</span>, <span class="dt">all=</span><span class="ot">TRUE</span>, <span class="dt">scales=</span><span class="kw">list</span>(<span class="dt">arrows=</span><span class="ot">FALSE</span>), <span class="dt">zlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">185</span>))</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-233-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Hints about the fitting strategy and alternative models for spatiotemporal variograms are given in <span class="citation">(Gräler, Pebesma, and Heuvelink <a href="#ref-RJ-2016-014">2016</a>)</span>.</p>
<p>With this fitted model, and given the observations, we can carry out kriging or simulation at arbitrary points in space and time. For instance, we could estimate (or simulate) values in the time series that are now missing: this occurs regularly, and in section <a href="interpolation.html#kriging">16.4</a> we used means over time series based on simply ignoring up to 25% of the observations: substituting these with estimated or simulated values based on neigbouring (in space and time) observations before computing yearly mean values seems a more reasonable approach.</p>
<p>More in general, we can estimate at arbitrary locations and time points, and we will illustrate this with predicting time series at particular locations, and and predicting spatial slices. We can create a <code>stars</code> object to denote two points and all time instances with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123</span>)
pt =<span class="st"> </span><span class="kw">st_sample</span>(de, <span class="dv">2</span>)
t =<span class="st"> </span><span class="kw">st_get_dimension_values</span>(no2.st, <span class="dv">1</span>)
<span class="kw">st_as_stars</span>(<span class="kw">list</span>(<span class="dt">pts =</span> <span class="kw">matrix</span>(<span class="dv">1</span>, <span class="kw">length</span>(t), <span class="kw">length</span>(pt)))) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="dt">names =</span> <span class="kw">c</span>(<span class="st">&quot;time&quot;</span>, <span class="st">&quot;station&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="st">&quot;time&quot;</span>, t) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="st">&quot;station&quot;</span>, pt) -&gt;<span class="st"> </span>new_pt</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">no2.st &lt;-<span class="st"> </span><span class="kw">st_transform</span>(no2.st, crs)
new_ts &lt;-<span class="st"> </span><span class="kw">krigeST</span>(NO2<span class="op">~</span><span class="dv">1</span>, <span class="dt">data =</span> no2.st[<span class="st">&quot;NO2&quot;</span>], <span class="dt">newdata =</span> new_pt,
         <span class="dt">nmax =</span> <span class="dv">50</span>, <span class="dt">stAni =</span> StAni, <span class="dt">modelList =</span> fitProdSumModel,
         <span class="dt">progress =</span> <span class="ot">FALSE</span>)
<span class="kw">plot</span>(<span class="kw">xts</span>(<span class="kw">t</span>(new_ts[[<span class="dv">2</span>]]), t), <span class="dt">type =</span> <span class="st">&#39;l&#39;</span>)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-235-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">t4 =<span class="st"> </span>t[(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span> <span class="op">-</span><span class="st"> </span><span class="fl">0.5</span>) <span class="op">*</span><span class="st"> </span>(<span class="dv">3</span><span class="op">*</span><span class="dv">24</span><span class="op">*</span><span class="dv">30</span>)]

d =<span class="st"> </span><span class="kw">dim</span>(grd)
<span class="kw">st_as_stars</span>(<span class="dt">pts =</span> <span class="kw">array</span>(<span class="dv">1</span>, <span class="kw">c</span>(d[<span class="dv">1</span>], d[<span class="dv">2</span>], <span class="dt">time=</span><span class="kw">length</span>(t4)))) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="st">&quot;time&quot;</span>, t4) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="st">&quot;x&quot;</span>, <span class="kw">st_get_dimension_values</span>(grd, <span class="st">&quot;x&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_dimensions</span>(<span class="st">&quot;y&quot;</span>, <span class="kw">st_get_dimension_values</span>(grd, <span class="st">&quot;y&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_set_crs</span>(crs) -&gt;<span class="st"> </span>grd.st
new_int &lt;-<span class="st"> </span><span class="kw">krigeST</span>(NO2<span class="op">~</span><span class="dv">1</span>, <span class="dt">data =</span> no2.st[<span class="st">&quot;NO2&quot;</span>], <span class="dt">newdata =</span> grd.st,
         <span class="dt">nmax =</span> <span class="dv">50</span>, <span class="dt">stAni =</span> StAni, <span class="dt">modelList =</span> fitProdSumModel,
         <span class="dt">progress =</span> <span class="ot">FALSE</span>)
<span class="kw">plot</span>(new_int[<span class="dv">2</span>,,,<span class="dv">1</span>], <span class="dt">reset =</span> <span class="ot">FALSE</span>)
<span class="kw">plot</span>(de, <span class="dt">col =</span> <span class="ot">NA</span>, <span class="dt">border =</span> <span class="st">&#39;red&#39;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; Warning in plot.sf(de, col = NA, border = &quot;red&quot;, add = TRUE): ignoring all</span>
<span class="co">#&gt; but the first attribute</span>
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(no2.sf), <span class="dt">col =</span> <span class="st">&#39;green&#39;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">pch =</span> <span class="dv">16</span>)</code></pre></div>
<p><img src="sds_files/figure-html/unnamed-chunk-236-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We can estimate</p>
<ul>
<li><p>have a single model for all correlations</p></li>
<li><p>predict, or simulate, missing values; better approach than taking averages while ignoring if 0-25% are missing alternative multivariate arima would have been enough/better?</p></li>
</ul>
<p>Alternative: pkg gapfill (remote sensing oriented; Florian Gerber) <a href="https://cran.r-project.org/web/packages/gapfill/" class="uri">https://cran.r-project.org/web/packages/gapfill/</a></p>
<ul>
<li><p>predict a sequence of hours</p></li>
<li><p>smooth in between, e.g. by 10-min interpolations, but note that measurements are hourly integrals, not values at time instances, which is what we assume</p></li>
</ul>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-asdar">
<p>Bivand, Roger S., Edzer Pebesma, and Virgilio Gomez-Rubio. 2013. <em>Applied Spatial Data Analysis with R, Second Edition</em>. Springer, NY. <a href="http://www.asdar-book.org/" class="uri">http://www.asdar-book.org/</a>.</p>
</div>
<div id="ref-blangiardo2015spatial">
<p>Blangiardo, Marta, and Michela Cameletti. 2015. <em>Spatial and Spatio-Temporal Bayesian Models with R-Inla</em>. John Wiley &amp; Sons.</p>
</div>
<div id="ref-RJ-2016-014">
<p>Gräler, Benedikt, Edzer Pebesma, and Gerard Heuvelink. 2016. “Spatio-Temporal Interpolation using gstat.” <em>The R Journal</em> 8 (1): 204–18. doi:<a href="https://doi.org/10.32614/RJ-2016-014">10.32614/RJ-2016-014</a>.</p>
</div>
<div id="ref-gstatcg">
<p>Pebesma, Edzer J. 2004. “Multivariable Geostatistics in S: The Gstat Package.” <em>Computers &amp; Geosciences</em> 30: 683–91.</p>
</div>
<div id="ref-R-gstat">
<p>Pebesma, Edzer, and Benedikt Graeler. 2019. <em>Gstat: Spatial and Spatio-Temporal Geostatistical Modelling, Prediction and Simulation</em>. <a href="https://github.com/r-spatial/gstat/" class="uri">https://github.com/r-spatial/gstat/</a>.</p>
</div>
<div id="ref-ver1993multivariable">
<p>Ver Hoef, Jay M, and Noel Cressie. 1993. “Multivariable Spatial Prediction.” <em>Mathematical Geology</em> 25 (2). Springer: 219–40.</p>
</div>
<div id="ref-wikle2019spatio">
<p>Wikle, Christopher K, Andrew Zammit-Mangion, and Noel Cressie. 2019. <em>Spatio-Temporal Statistics with R</em>. CRC Press.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="up-and-downscaling.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="area-data-and-spatial-autcorrelation.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/edzer/sdsr/edit/master/16-Geostatistics.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": ["sds.pdf", "sds.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
