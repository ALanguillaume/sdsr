[
["index.html", "Spatial Data Science with R Preface", " Spatial Data Science with R Edzer Pebesma, Roger Bivand 2018-09-27 Preface "],
["intro.html", "Chapter 1 Getting Started 1.1 A first map 1.2 Reading and writing 1.3 Exercises", " Chapter 1 Getting Started This chapter gives a quick start to get you going with spatial data science with R. It is easier to read when understanding R at the level of, say, R for Data Science (Wickham and Grolemund 2017). 1.1 A first map There is a lot to say about spatial data, but let us first create a map. We can create a simple map by: library(tidyverse) #&gt; ── Attaching packages ────────────────────────────────── tidyverse 1.2.1 ── #&gt; ✔ ggplot2 3.0.0 ✔ purrr 0.2.5 #&gt; ✔ tibble 1.4.2 ✔ dplyr 0.7.5 #&gt; ✔ tidyr 0.8.1 ✔ stringr 1.3.1 #&gt; ✔ readr 1.1.1 ✔ forcats 0.3.0 #&gt; ── Conflicts ───────────────────────────────────── tidyverse_conflicts() ── #&gt; ✖ dplyr::filter() masks stats::filter() #&gt; ✖ dplyr::lag() masks stats::lag() library(sf) #&gt; Linking to GEOS 3.6.2, GDAL 2.2.3, proj.4 4.9.3 system.file(&quot;gpkg/nc.gpkg&quot;, package=&quot;sf&quot;) %&gt;% read_sf() %&gt;% st_transform(32119) %&gt;% select(BIR74) %&gt;% plot(graticule = TRUE, axes = TRUE) Figure 1.1: a first map A lot went on, here. We will describe the steps in detail. First, we loaded two R packages: library(tidyverse) library(sf) where tidyverse is needed for the tidyverse functions and methods, and sf is needed for the spatial commands and spatial tidyverse methods. Package sf implements simple features, a standardised way to encode vector data (points, lines, polygons). We will say more about simple features in chapter 3. Most commands in package sf start with st_, short for spatiotemporal, a convention it shares with e.g. PostGIS. The %&gt;% (pipe) symbols should be read as then: we read a %&gt;% b() %&gt;% c() %&gt;% d(n = 10) as with a do b then c then d, and that is just alternative syntax for d(c(b(a)), n = 10) or tmp1 &lt;- b(a) tmp2 &lt;- c(tmp1) tmp3 &lt;- d(tmp2, n = 10) To many, the pipe-form is easier to read because execution order follows reading order (from left to right). Like nested function calls, it avoids the need to choose names for intermediate results. For the illustration we picked a data file that comes with sf, the location of which depends on the operating system used. The following will give a different output on your computer: (file &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package=&quot;sf&quot;)) #&gt; [1] &quot;/home/edzer/R/x86_64-pc-linux-gnu-library/3.5/sf/gpkg/nc.gpkg&quot; Never use system.file if you want to read your own data; in that case, fname should be the data source (typically file or path) name (section 1.2). (Parens around this expression are used to have the result not only stored, but also printed.) Then, we read this file into R using read_sf: (nc &lt;- file %&gt;% read_sf()) #&gt; Simple feature collection with 100 features and 14 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6 #&gt; epsg (SRID): 4267 #&gt; proj4string: +proj=longlat +datum=NAD27 +no_defs #&gt; # A tibble: 100 x 15 #&gt; AREA PERIMETER CNTY_ CNTY_ID NAME FIPS FIPSNO CRESS_ID BIR74 SID74 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.114 1.44 1825 1825 Ashe 37009 37009 5 1091 1 #&gt; 2 0.061 1.23 1827 1827 Alle… 37005 37005 3 487 0 #&gt; 3 0.143 1.63 1828 1828 Surry 37171 37171 86 3188 5 #&gt; 4 0.07 2.97 1831 1831 Curr… 37053 37053 27 508 1 #&gt; 5 0.153 2.21 1832 1832 Nort… 37131 37131 66 1421 9 #&gt; 6 0.097 1.67 1833 1833 Hert… 37091 37091 46 1452 7 #&gt; # ... with 94 more rows, and 5 more variables: NWBIR74 &lt;dbl&gt;, BIR79 &lt;dbl&gt;, #&gt; # SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt; which creates a “spatial tibble”: class(nc) #&gt; [1] &quot;sf&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; This object is transformed into a new coordinate reference system (North Carolina State Plane, with EPSG code 32119): (nc.32119 &lt;- nc %&gt;% st_transform(32119)) #&gt; Simple feature collection with 100 features and 14 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: 124000 ymin: 14700 xmax: 931000 ymax: 318000 #&gt; epsg (SRID): 32119 #&gt; proj4string: +proj=lcc +lat_1=36.16666666666666 +lat_2=34.33333333333334 +lat_0=33.75 +lon_0=-79 +x_0=609601.22 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs #&gt; # A tibble: 100 x 15 #&gt; AREA PERIMETER CNTY_ CNTY_ID NAME FIPS FIPSNO CRESS_ID BIR74 SID74 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.114 1.44 1825 1825 Ashe 37009 37009 5 1091 1 #&gt; 2 0.061 1.23 1827 1827 Alle… 37005 37005 3 487 0 #&gt; 3 0.143 1.63 1828 1828 Surry 37171 37171 86 3188 5 #&gt; 4 0.07 2.97 1831 1831 Curr… 37053 37053 27 508 1 #&gt; 5 0.153 2.21 1832 1832 Nort… 37131 37131 66 1421 9 #&gt; 6 0.097 1.67 1833 1833 Hert… 37091 37091 46 1452 7 #&gt; # ... with 94 more rows, and 5 more variables: NWBIR74 &lt;dbl&gt;, BIR79 &lt;dbl&gt;, #&gt; # SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;, geom &lt;MULTIPOLYGON [m]&gt; and a single attribute column is selected (nc.32119.bir74 &lt;- nc.32119 %&gt;% select(BIR74)) #&gt; Simple feature collection with 100 features and 1 field #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: 124000 ymin: 14700 xmax: 931000 ymax: 318000 #&gt; epsg (SRID): 32119 #&gt; proj4string: +proj=lcc +lat_1=36.16666666666666 +lat_2=34.33333333333334 +lat_0=33.75 +lon_0=-79 +x_0=609601.22 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs #&gt; # A tibble: 100 x 2 #&gt; BIR74 geom #&gt; &lt;dbl&gt; &lt;MULTIPOLYGON [m]&gt; #&gt; 1 1091 (((387345 278387, 381334 282774, 379438 282943, 373250 290553, 36… #&gt; 2 487 (((408602 292425, 408565 293985, 406643 296873, 406420 3e+05, 402… #&gt; 3 3188 (((478717 277490, 476936 278867, 471503 279173, 470806 281394, 46… #&gt; 4 508 (((878194 289128, 877381 291117, 875994 290881, 874941 292805, 87… #&gt; 5 1421 (((769835 277796, 768364 274842, 762616 274401, 763168 269009, 76… #&gt; 6 1452 (((812328 277876, 791158 277012, 789882 277579, 777724 277107, 76… #&gt; # ... with 94 more rows Finally, the result is plotted, with the command: nc.32119.bir74 %&gt;% plot(graticule = TRUE, axes = TRUE) as shown in figure 1.1. Where do these commands come from? library and system.file are base R. We can ask for help about a particular command by entering e.g. ?library The command read_sf is an alternative to the st_read, which returns a spatial tibble instead of a spatial data frame, and will be discussed in section 1.2. The st_transform method is used here to convert from the geographic coordinates (degrees longitude and latitude) into “flat” coordinates, meaning \\(x\\) and \\(y\\) coordinates in a planar system. It will be discussed in section 7.3. The plot method for sf objects chooses default colors and legends settings; we instructed it to add a graticule (the grey lines of equal longitude and latitude) and degree labels along the axes. It is described in chapter 9. As witnessed by the plot, the plot command receives county polygons as well as BIR74 values for each polygon. How is it possible that we select only the BIR74 variable, but still can plot the polygons? This is because package sf provides a select method: methods(select) #&gt; [1] select.data.frame* select.default* select.grouped_df* #&gt; [4] select.list select.sf* select.tbl_cube* #&gt; see &#39;?methods&#39; for accessing help and source code and this method (select.sf) makes the geometry (geom) sticky: nc %&gt;% select(BIR74) %&gt;% names() #&gt; [1] &quot;BIR74&quot; &quot;geom&quot; We get the “normal” select behaviour if we first coerce to a normal tibble: nc %&gt;% as_tibble(validate = TRUE) %&gt;% select(BIR74) %&gt;% names() #&gt; [1] &quot;BIR74&quot; A ggplot is created when we use geom_sf: ggplot() + geom_sf(data = nc.32119) + aes(fill = BIR74) + theme(panel.grid.major = element_line(color = &quot;white&quot;)) + scale_fill_gradientn(colors = sf.colors(20)) and a facet plot for a pair of columns in nc.32119 is obtained by gathering the columns: nc2 &lt;- nc.32119 %&gt;% select(SID74, SID79) %&gt;% gather(VAR, SID, -geom) ggplot() + geom_sf(data = nc2, aes(fill = SID)) + facet_wrap(~VAR, ncol = 1) + scale_y_continuous(breaks = 34:36) + scale_fill_gradientn(colors = sf.colors(20)) + theme(panel.grid.major = element_line(color = &quot;white&quot;)) An interactive, leaflet-type map is obtained by suppressPackageStartupMessages(library(mapview)) nc.32119 %&gt;% mapview(zcol = &quot;BIR74&quot;, legend = TRUE, col.regions = sf.colors) 1.2 Reading and writing Typical R data science tasks start with reading data from an external source; this may be a file, or a set of files like a “shapefile”, or a database, or a web service. Package sf can read from a large number of different data sources; the following command shows how many st_drivers(&quot;vector&quot;) %&gt;% nrow() # vector drivers #&gt; [1] 80 st_drivers(&quot;raster&quot;) %&gt;% nrow() # raster drivers #&gt; [1] 136 (the output you see may differ because of different operating system and configuration.) 1.2.1 GDAL st_drivers lists the drivers available to GDAL, the geospatial data abstraction library. This library can be seen as the swiss army knive of spatial data; besides for R it is used in Python, QGIS, PostGIS, and more than 100 other software projects. The dependency of sf on other R libraries and system libraries is shown in figure 1.2. Figure 1.2: sf and its dependencies Note that the C/C++ libraries used (GDAL, GEOS, Proj, liblwgeom, udunits2) are all developed, maintained and used by (data) science communities that are much larger than the R community. By using these libraries, we share how we understand what we are doing with all the other communities that use these libraries. This is not only important for resolving problems, but also for establishing which findings are facts. GDAL is a “library of libraries” – in order to read all these data sources it needs a large number of other libraries. It typically links to over 100 other libraries. Binary packages distributed by CRAN contain only statically linked code: CRAN does not want to make any assumptions about presence of third-party libraries on the host system. As a consequence, when the binary sf package is installed from CRAN, it includes a copy of all the required external libraries as well as their dependencies, which may amount to 50 or 100 Mb. 1.2.2 st_read or read_sf? The function to read vector data is st_read. Function read_sf is largely the same as `st_read, but chooses a few tidyverse-style defaults: it is silent by default, where st_read gives a short report it returns a spatial tibble instead of a spatial data frame it sets as default stringsAsFactors = FALSE, where st_read listens to the global option default.stringsAsFactors() (which is TRUE by default) it accepts list-columns as input In the same fashion, compared to st_write, function write_sf, is also silent overwrites layers (i.e., sets delete_layer = TRUE) by default, which st_write does not do. 1.2.3 reading and writing raster data Raster data can be read with function read_stars from package stars: library(stars) tif = system.file(&quot;tif/L7_ETMs.tif&quot;, package = &quot;stars&quot;) (x = tif %&gt;% read_stars()) #&gt; stars object with 3 dimensions and 1 attribute #&gt; attribute(s): #&gt; L7_ETMs.tif #&gt; Min. : 1.0 #&gt; 1st Qu.: 54.0 #&gt; Median : 69.0 #&gt; Mean : 68.9 #&gt; 3rd Qu.: 86.0 #&gt; Max. :255.0 #&gt; dimension(s): #&gt; from to offset delta refsys point values #&gt; x 1 349 288776 28.5 +proj=utm +zone=25 +south... FALSE NULL [x] #&gt; y 1 352 9120761 -28.5 +proj=utm +zone=25 +south... FALSE NULL [y] #&gt; band 1 6 NA NA NA NA NULL Plotting this object shows the six different spectral bands read, with color breaks based on quantiles of pixel values accross all bands: plot(x) Similarly, we can write raster data with st_write tif_file = paste0(tempfile(), &quot;.tif&quot;) st_write(x, tif_file) We can read back the raster metadata (its dimensions and reference system, but not the actual pixel values) by read_stars(tif_file, proxy = TRUE) #&gt; stars_proxy object with 1 attribute in file: #&gt; $file7c9e741b526d.tif #&gt; [1] &quot;/tmp/Rtmpe1Vdql/file7c9e741b526d.tif&quot; #&gt; #&gt; dimension(s): #&gt; from to offset delta refsys point values #&gt; x 1 349 288776 28.5 +proj=utm +zone=25 +south... FALSE NULL [x] #&gt; y 1 352 9120761 -28.5 +proj=utm +zone=25 +south... FALSE NULL [y] #&gt; band 1 6 NA NA NA NA NULL Raster data analysis and its integration with vector data is explained in detail in chapter 4. 1.2.4 Reading from files, and shapefiles We saw above that a spatial dataset can be read from a single file by nc &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package=&quot;sf&quot;) %&gt;% read_sf() In some cases, spatial datasets are contained in multiple files, e.g. in the case of shapefiles. A “shapefile” should be really understood as a set of files with a common prefix, or even a directory with several of such sets. Package sf comes with a couple of shapefiles packaged, a directory listing of the shape directory in the packge is obtained by list.files(system.file(&quot;shape/&quot;, package = &quot;sf&quot;)) #&gt; [1] &quot;nc.dbf&quot; &quot;nc.prj&quot; #&gt; [3] &quot;nc.shp&quot; &quot;nc.shx&quot; #&gt; [5] &quot;storms_xyz_feature.dbf&quot; &quot;storms_xyz_feature.shp&quot; #&gt; [7] &quot;storms_xyz_feature.shx&quot; &quot;storms_xyz.dbf&quot; #&gt; [9] &quot;storms_xyz.shp&quot; &quot;storms_xyz.shx&quot; #&gt; [11] &quot;storms_xyzm_feature.dbf&quot; &quot;storms_xyzm_feature.shp&quot; #&gt; [13] &quot;storms_xyzm_feature.shx&quot; &quot;storms_xyzm.dbf&quot; #&gt; [15] &quot;storms_xyzm.shp&quot; &quot;storms_xyzm.shx&quot; We can read a single shapefile by nc &lt;- system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;) %&gt;% read_sf() and it is important to know that in that case all four files starting with nc are read from this directory. We can also read the directory with shapfiles by something &lt;- system.file(&quot;shape&quot;, package=&quot;sf&quot;) %&gt;% read_sf() #&gt; Warning in evalq((function (..., call. = TRUE, immediate. = FALSE, #&gt; noBreaks. = FALSE, : automatically selected the first layer in a data #&gt; source containing more than one. but we see some warnings now, indicating that we are reading only the first layer from a multi-layer dataset (and not nc.shp!). Indeed, this directory contains multiple layers, which can be queried by system.file(&quot;shape&quot;, package=&quot;sf&quot;) %&gt;% st_layers() #&gt; Driver: ESRI Shapefile #&gt; Available layers: #&gt; layer_name geometry_type features fields #&gt; 1 storms_xyzm_feature Measured Line String 71 1 #&gt; 2 storms_xyz 3D Line String 71 0 #&gt; 3 nc Polygon 100 14 #&gt; 4 storms_xyz_feature 3D Line String 71 1 #&gt; 5 storms_xyzm Measured Line String 71 0 From this list, we could pick one, and use it as the layer argument, as in dataset &lt;- system.file(&quot;shape&quot;, package=&quot;sf&quot;) layer &lt;- &quot;nc&quot; nc &lt;- read_sf(dataset, layer) which is essentially a convoluted way of what we did before to read nc.shp. Considering shapefiles in directories as layers in a dataset is not something that sf came up with, but is the way GDAL handles this. Although it is a good idea in general to give up using shapefiles, we cannot always control the format of the spatial data we get to start with. 1.2.5 Reading from a text string In the special case of a GeoJSON (Butler et al. 2016) dataset, when the dataset is contained in a length-one character vector, it can be directly passed to read_sf and read from memory: str &lt;- &#39;{ &quot;type&quot;: &quot;FeatureCollection&quot;, &quot;features&quot;: [ { &quot;type&quot;: &quot;Feature&quot;, &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [102.0, 0.5] }, &quot;properties&quot;: { &quot;prop0&quot;: &quot;value0&quot; } }, { &quot;type&quot;: &quot;Feature&quot;, &quot;geometry&quot;: { &quot;type&quot;: &quot;LineString&quot;, &quot;coordinates&quot;: [ [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0] ] }, &quot;properties&quot;: { &quot;prop0&quot;: &quot;value0&quot;, &quot;prop1&quot;: 0.0 } }, { &quot;type&quot;: &quot;Feature&quot;, &quot;geometry&quot;: { &quot;type&quot;: &quot;Polygon&quot;, &quot;coordinates&quot;: [ [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ] ] }, &quot;properties&quot;: { &quot;prop0&quot;: &quot;value0&quot;, &quot;prop1&quot;: { &quot;this&quot;: &quot;that&quot; } } } ] }&#39; (sf_obj &lt;- read_sf(str)) #&gt; Simple feature collection with 3 features and 2 fields #&gt; geometry type: GEOMETRY #&gt; dimension: XY #&gt; bbox: xmin: 100 ymin: 0 xmax: 105 ymax: 1 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; # A tibble: 3 x 3 #&gt; prop0 prop1 geometry #&gt; &lt;chr&gt; &lt;chr&gt; &lt;GEOMETRY [°]&gt; #&gt; 1 value0 &lt;NA&gt; POINT (102 0.5) #&gt; 2 value0 0.0 LINESTRING (102 0, 103 1, 104 0, 105 1) #&gt; 3 value0 &quot;{ \\&quot;this\\&quot;: \\&quot;that\\&quot;… POLYGON ((100 0, 101 0, 101 1, 100 1, 100… 1.2.6 Database Data can be read from a spatial database directly through two paths. The first is to use the standard database interface of R (DBI), for instance with a SQLITE database: library(RSQLite) db = system.file(&quot;sqlite/meuse.sqlite&quot;, package = &quot;sf&quot;) dbcon &lt;- dbConnect(dbDriver(&quot;SQLite&quot;), db) (s = st_read(dbcon, &quot;meuse.sqlite&quot;))[1:3,] #&gt; Simple feature collection with 3 features and 13 fields #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 181000 ymin: 334000 xmax: 181000 ymax: 334000 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; ogc_fid cadmium copper lead zinc elev dist om ffreq soil lime #&gt; 1 1 11.7 85 299 1022 7.91 0.00136 13.6 1 1 1 #&gt; 2 2 8.6 81 277 1141 6.98 0.01222 14.0 1 1 1 #&gt; 3 3 6.5 68 199 640 7.80 0.10303 13.0 1 1 1 #&gt; landuse dist.m GEOMETRY #&gt; 1 Ah 50 POINT (181072 333611) #&gt; 2 Ah 30 POINT (181025 333558) #&gt; 3 Ah 150 POINT (181165 333537) dbDisconnect(dbcon) Another way is to use GDAL database drivers, e.g. by st_read(db)[1:3,] #&gt; Reading layer `meuse.sqlite&#39; from data source `/home/edzer/R/x86_64-pc-linux-gnu-library/3.5/sf/sqlite/meuse.sqlite&#39; using driver `SQLite&#39; #&gt; Simple feature collection with 155 features and 12 fields #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 179000 ymin: 330000 xmax: 181000 ymax: 334000 #&gt; epsg (SRID): 28992 #&gt; proj4string: +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +towgs84=565.4171,50.3319,465.5524,-0.398957,0.343988,-1.87740,4.0725 +units=m +no_defs #&gt; Simple feature collection with 3 features and 12 fields #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 181000 ymin: 334000 xmax: 181000 ymax: 334000 #&gt; epsg (SRID): 28992 #&gt; proj4string: +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +towgs84=565.4171,50.3319,465.5524,-0.398957,0.343988,-1.87740,4.0725 +units=m +no_defs #&gt; cadmium copper lead zinc elev dist om ffreq soil lime landuse #&gt; 1 11.7 85 299 1022 7.91 0.00136 13.6 1 1 1 Ah #&gt; 2 8.6 81 277 1141 6.98 0.01222 14.0 1 1 1 Ah #&gt; 3 6.5 68 199 640 7.80 0.10303 13.0 1 1 1 Ah #&gt; dist.m GEOMETRY #&gt; 1 50 POINT (181072 333611) #&gt; 2 30 POINT (181025 333558) #&gt; 3 150 POINT (181165 333537) An advantage of the former approach may be that any query can be passed, allowing for reading only parts of a table into R’s memory. A disadvantage is that it does not read the coordinate reference system; for other spatial databases, like PostGIS, this may work better. 1.3 Exercises Read the shapefile storms_xyz_feature from the shape directory in the sf package Copy this file to another directory on your computer, and read it from there (note: a shapefile consists of more than one file!) How many features does this dataset contain? Plot the dataset, with axes = TRUE (hint: before plotting, pipe through st_zm to drop Z and M coordinates; more about this in chapter 3). Before plotting, pipe the dataset through st_set_crs(4326). What is different in the plot obtained? References "],
["coordinate-systems.html", "Chapter 2 Coordinate systems 2.1 Cartesian and geodetic coordinates 2.2 Ellipsoidal coordinates 2.3 Distances 2.4 Bounded spaces 2.5 Time 2.6 Exercises", " Chapter 2 Coordinate systems For spatial data, the location of observations are characterised by coordinates, and coordinates are defined in a coordinate system. Different coordinate systems can be used for this, and the most important difference is whether coordinates are defined over a 2-dimensional or 3-dimensional space referenced to orthogonal axes (Cartesian coordinates), or using distance and directions (polar coordinates, spherical coordinates). Figure 2.1: Two-dimensional polar (red) and Cartesian (blue) coordinates 2.1 Cartesian and geodetic coordinates Figure 2.1 shows both polar and Cartesian coordinates for a standard two-dimensional situation. In Cartesian coordinates, the point shown is \\((x,y) = (3,4)\\), for polar coordinates it is \\((r,\\phi) = (5, \\mbox{arctan}(4/3))\\), where \\(\\mbox{arctan}(4/3)\\) is approximately \\(0.93\\) radians, or \\(53^{\\circ}\\). Note that \\(x\\), \\(y\\) and \\(r\\) all have length units, where \\(\\phi\\) is an angle (a unitless length/length ratio). Converting back and forth between Cartesian and polar coordinates is trivial, \\[x = r~\\mbox{cos} \\phi\\] \\[y = r~\\mbox{sin} \\phi\\] \\[\\phi = \\mbox{arctan}(y/x)\\] \\[r = \\sqrt{x^2 + y^2}\\] but requires care with using the right quadrant for \\(\\mbox{arctan}\\); the atan2 function is helpful here. 2.2 Ellipsoidal coordinates In three dimensions, where Cartesian coordinates are expressed as \\((x,y,z)\\), spherical coordinates are the three-dimensional equivalent of polar coordinates and can be expressed as \\((r,\\lambda,\\phi)\\), where \\(r\\) is the radius of the sphere, \\(\\lambda\\) is the longitude, measured in the \\((x,y)\\) plane counter-clockwise from positive \\(x\\), and \\(\\phi\\) is the latitude, the angle between the vector and the \\((x,y)\\) plane. \\(\\lambda\\) typically varies between \\(-180^{\\circ}\\) and \\(180^{\\circ}\\) (or alternatively from \\(0^{\\circ}\\) to \\(360^{\\circ}\\)), \\(\\phi\\) from \\(-90^{\\circ}\\) to \\(90^{\\circ}\\). When we are only interested in points on a sphere with given radius, we can drop \\(r\\): \\((\\lambda,\\phi)\\) now suffice to identify any point. It should be noted that this is just a definition, one could for instance also choose to measure polar angle, i.e. the angle between the vector and \\(z\\), instead of latitude. There is also a long tradition of specifying points as \\((\\phi,\\lambda)\\) but throughout this book we will stick to longitude-latitude, \\((\\lambda,\\phi)\\). For points on an ellipse, there are two ways in which angle can be expressed (figure 2.2): measured from the center of the ellipse (\\(\\psi\\)), or measured perpendicular to the tangent on the ellipse at the target point (\\(\\phi\\)). Figure 2.2: Angles on an ellipse: geodetic (blue) and geocentric (red) latitude The most commonly used parametric model for the Earth is an ellipsoid of revolution, an ellipsoid with two equal semi-axes (Iliffe and Lott 2008). In effect, this is a flattened sphere (or spheroid): the distance between the poles is (slightly: about 0.33%) smaller than the distance between two opposite points on the equator. Under this model, longitude is always measured along a circle, but latitude along an ellipse. If we think of figure 2.2 as a cross section of the Earth passing through the poles, the latitude measure \\(\\phi\\) is the one used when no further specification is given; it is also called geodetic latitude. The latitude measure \\(\\psi\\) is called the geocentric latitude. In addition to longitude and latitude we can add altitude to define points that are not on the spheroid, and obtain a three dimensional space again. When defining altitude, we need to choose where zero altitude is: on the ellipsoid, or on the geoid, approximating mean sea level?) which direction is positive, and which direction is “straight up”: perpendicular to the spheroid surface, or in the direction opposite to geoid? All these choices may matter, depending on the application area. 2.3 Distances Distances between two points \\(p_i\\) and \\(p_j\\) in Cartesian coordinates are computed as Euclidian distances, in two dimensions by \\[d_{ij} = \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\\] with \\(p_i = (x_i,y_i)\\) and in three dimensions by \\[d_{ij} = \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}\\] with \\(p_i = (x_i,y_i,z_i).\\) These distances represent the length of a straight line between two points \\(i\\) and \\(j\\). For two points on a circle, the length of the arc of two points \\(c_1 = (r,{\\phi}_i)\\) and \\(c_2 = (r, \\phi_2)\\) is \\[s_{ij}=r~|\\phi_1-\\phi_2| = r ~\\theta\\] with \\(\\theta\\) the angle between \\(\\phi_1\\) and \\(\\phi_2\\) in radians. For very small values of \\(\\theta\\), we will have \\(s_{ij} \\approx d_{ij}\\). For two points \\(p_1 = (\\lambda_1,\\phi_1)\\) and \\(p_2 = (\\lambda_2,\\phi_2)\\) on a sphere with radius \\(r&#39;\\), the great circle distance is the arc length between \\(p_1\\) and \\(p_2\\) on the circle that passes through \\(p_1\\) and \\(p_2\\) and has the center of the sphere as its center, and is given by \\(s_{12} = r ~ \\theta_{12}\\) with \\[\\theta_{12} = \\arccos(\\sin \\phi_1 \\cdot \\sin \\phi_2 + \\cos \\phi_1 \\cdot \\cos \\phi_2 \\cdot \\cos(|\\lambda_1-\\lambda_2|))\\] the angle in radians. Arc distances between two points on a spheroid are more complicated to compute. Details about the computation method used in package lwgeom (which, in turn, is used by package sf) are given in Karney (2013). 2.4 Bounded spaces All the above assumes pure geometric computations in spaces where there are no unexpected obstructions. When we move through space on a daily basis, we typically find constraints e.g. when we walk through a building when we cycle to work or when we drive to a shop. Distances, in such case, can be made up of a sequence of shortest (straight line or great circle) distances, but follow a more complex path than a straight line. Typical constraints come from road networks, or from the requirement for a certain habitat for movement (water for fish, forest for certain bird species). 2.5 Time When we describe over which “space” a certain phenomenon is characterised, time forms an integral component: nothing exists forever. It is tempting to think that compared to geographical “space” time is one-dimensional “linear”, and that is often the way we address time, e.g. in R where Date is represented by the number of days since 1970-01-01 (d = as.Date(&quot;1970-02-01&quot;)) #&gt; [1] &quot;1970-02-01&quot; as.numeric(d) #&gt; [1] 31 and POSIXt time by the number of seconds since that date (t = as.POSIXct(&quot;1970-01-02 00:00&quot;, tz = &quot;UTC&quot;)) #&gt; [1] &quot;1970-01-02 UTC&quot; as.numeric(t) #&gt; [1] 86400 In practical cases however, we may be interested in how certain phenomena vary over the day, or over the year, in which case it may more convenient to represent time as the tuple (year, day-of-year), or (day, time-of-day). When we study for instance traffic patterns, day of week plays a role, in which we may end up with (year, week-of-year, day-of-week, time-of-day) in order to quantify hour, day, week, and year signals. This decomposes time essentially in two or more components, with some of them having a circular character. 2.6 Exercises convert the \\((x,y)\\) points \\((10,2)\\), \\((-10,-2)\\), \\((10,-2)\\) and \\((0,10)\\) to polar coordinates convert the polar \\((r,\\phi)\\) points \\((10,45^{\\circ})\\), \\((0,100^{\\circ})\\) and \\((5,359^{\\circ})\\) to Cartesian coordinates assuming the Earth is a sphere with a radius of 6371 km, compute for \\((\\lambda,\\phi)\\) points the great circle distance between \\((10,10)\\) and \\((11,10)\\), between \\((10,80)\\) and \\((11,80)\\), between \\((10,10)\\) and \\((10,11)\\) and between \\((10,80)\\) and \\((10,81)\\) (units: degree). What are the distance units? References "],
["geometries.html", "Chapter 3 Geometries 3.1 Simple feature geometry types 3.2 Simple features in sf 3.3 Tesselations: Coverages, rasters 3.4 Networks 3.5 Geometries on the sphere", " Chapter 3 Geometries Having learned how we describe spaces, we can define how geometries can be described in these space. This chapter will mostly explain the geometries for simple features, and introduce the three classes sfg, sfc and sf for single geometries, geometry sets, and geometry sets with associated attributes. 3.1 Simple feature geometry types Simple feature geometries are a way to describe the geometries of features. By features we mean things that have a geometry, some time properties, and other attributes. The main application of simple feature geometries is to describe two-dimensional geometries by points, lines, or polygons. The “simple” adjective refers to the fact that the line or polygon geometries are represented by sequences of points connected with straight lines. Simple features access is a standard (Herring 2011, Herring (2010), ISO (2004)). for describing simple feature geometries that includes a class hierarchy a set of operations binary and text encodings We will now discuss the seven most common simple feature geometry types. Although in practice we will most often import spatial data from external sources (files, databases, web services), we will create them here from scratch using simple constructor functions. 3.1.1 The big seven The most commonly used simple features geometries, used to represent a single feature are: type description POINT single point geometry MULTIPOINT set of points LINESTRING single line MULTILINESTRING set of lines POLYGON exterior ring with zero or more inner rings, denoting holes MULTIPOLYGON set of polygons GEOMETRYCOLLECTION set of geometries Points in a geometry contain at least two coordinates: x and y, in that order. 3.1.2 Constraints The following constraints to simple feature geometries hold: lines shall not self-intersect polygon rings shall be closed (the last point equals the first) polygon holes (inner rings) shall be inside their exterior ring polygon inner rings shall maximally touch the exterior ring in single points, not over a line a polygon ring shall not repeat its own path 3.1.3 Z and M In addition to X and Y coordinates, Single points (vertices) of simple feature geometries can have a Z coordinate, denoting altitude, and/or an M value, denoting some “measure” but it should be noted that infrastructure for truly three-dimensional geometries is not available. Practically all functions available for simple feature geometries only operate on the XY dimensions. The M attribute shall be a property of the vertex. It sounds attractive to encode a time stamp in it, e.g. to pack trajectories in LINESTRINGs. These become however invalid once the trajectory self-intersects. 3.1.4 Ten further geometry types There are 10 more geometry types which are more rare, but increasingly find implementation: type description CIRCULARSTRING The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the linear world. A single segment requires three points, the start and end points (first and third) and any other point on the arc. The exception to this is for a closed circle, where the start and end points are the same. In this case the second point MUST be the center of the arc, ie the opposite side of the circle. To chain arcs together, the last point of the previous arc becomes the first point of the next arc, just like in LINESTRING. This means that a valid circular string must have an odd number of points greated than 1. COMPOUNDCURVE A compound curve is a single, continuous curve that has both curved (circular) segments and linear segments. That means that in addition to having well-formed components, the end point of every component (except the last) must be coincident with the start point of the following component. CURVEPOLYGON Example compound curve in a curve polygon: CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) ) MULTICURVE A MultiCurve is a 1-dimensional GeometryCollection whose elements are Curves, it can include linear strings, circular strings or compound strings. MULTISURFACE A MultiSurface is a 2-dimensional GeometryCollection whose elements are Surfaces, all using coordinates from the same coordinate reference system. CURVE A Curve is a 1-dimensional geometric object usually stored as a sequence of Points, with the subtype of Curve specifying the form of the interpolation between Points SURFACE A Surface is a 2-dimensional geometric object POLYHEDRALSURFACE A PolyhedralSurface is a contiguous collection of polygons, which share common boundary segments TIN A TIN (triangulated irregular network) is a PolyhedralSurface consisting only of Triangle patches. TRIANGLE A Triangle is a polygon with 3 distinct, non-collinear vertices and no interior boundary Note that CIRCULASTRING, COMPOUNDCURVE and CURVEPOLYGON are not described in the SFA standard, but in the SQL-MM part 3 standard. The descriptions above were copied from the PostGIS manual. 3.1.5 Encodings: WKT, WKB Part of the simple feature standard are two encodings: a text and a binary encoding. The text strings POINT (0 1) and so on indicate text encodings, also known as well-known text (WKT) encodings, of simple feature geometries. They are meant to be human-readable. 3.2 Simple features in sf This section describes the implementation of simple feature geometries in package sf. It will first explain how single simple feature geometries, explained in the previous section, are represented in R objects of class sfg. Next, it will explain how sets of simple feature geometry objects are collected in a list of class sfc. This list acts as a geometry list-column in data.frame objects, of class sf. 3.2.1 sfg: simple feature geometry Individual simple feature geometry objects are implemented pretty much like the arguments to their constructor function, as a numeric vector for POINT, numeric matrix for MULTIPOINT and LINESTRING list of numeric matrices for MULTILINESTRING and POLYGON list of lists of numeric matrices for MULTIPOLYGON list of typed geometries for GEOMETRYCOLLECTION All other geometry types follow this, using the simplest possible option. Objects have a class indicating their dimension, type, and a superclass (sfg for simple feature geometry), and have no other attributes than their S3 class: The superclass that holds a single simple feature geometry is sfg: (pt = st_point(c(0,1))) #&gt; POINT (0 1) attributes(pt) #&gt; $class #&gt; [1] &quot;XY&quot; &quot;POINT&quot; &quot;sfg&quot; We see that in addition to sfg it has two class attributes: XY telling the dimension of the point(s) POINT revealing the geomtry type. Some examples of XYZ and XYM and XYZM geometries are found here: system.file(&quot;shape/storms_xyz_feature.shp&quot;, package=&quot;sf&quot;) %&gt;% st_read() #&gt; Reading layer `storms_xyz_feature&#39; from data source `/home/edzer/R/x86_64-pc-linux-gnu-library/3.5/sf/shape/storms_xyz_feature.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 71 features and 1 field #&gt; geometry type: LINESTRING #&gt; dimension: XYZ #&gt; bbox: xmin: -102 ymin: 8.3 xmax: 0 ymax: 59.5 #&gt; epsg (SRID): NA #&gt; proj4string: NA system.file(&quot;shape/storms_xyzm_feature.shp&quot;, package=&quot;sf&quot;) %&gt;% # badly named! st_read() #&gt; Reading layer `storms_xyzm_feature&#39; from data source `/home/edzer/R/x86_64-pc-linux-gnu-library/3.5/sf/shape/storms_xyzm_feature.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 71 features and 1 field #&gt; geometry type: LINESTRING #&gt; dimension: XYM #&gt; bbox: xmin: -102 ymin: 8.3 xmax: 0 ymax: 59.5 #&gt; epsg (SRID): NA #&gt; proj4string: NA (pzm = st_point(c(1,2,3,4))) #&gt; POINT ZM (1 2 3 4) Points and vertices in simple feature geometries represent XY coordinates, in that order. A MULTIPOINT or a LINESTRING can be created by a matrix (m1 = rbind(c(8, 1), c(2, 5), c(3, 2))) #&gt; [,1] [,2] #&gt; [1,] 8 1 #&gt; [2,] 2 5 #&gt; [3,] 3 2 (mp = st_multipoint(m1)) #&gt; MULTIPOINT (8 1, 2 5, 3 2) (ls = st_linestring(m1)) #&gt; LINESTRING (8 1, 2 5, 3 2) Although these geometries contain the same points, they have entirely different meaning: the point set is a zero-dimensional, the line a one-dimensional geometry: st_dimension(mp) #&gt; [1] 0 st_dimension(ls) #&gt; [1] 1 A MULTILINESTRING can be constructed from a list of matrices, representing vertices: m2 = rbind(c(22,20), c(18, 15)) mls = st_multilinestring(list(m1, m2)) A POLYGON consists of an outer ring, followed by zero or more inner rings that denote holes in the outer ring: (ring1 = rbind(c(0,0), c(4,0), c(4,4), c(0,4), c(0,0))) #&gt; [,1] [,2] #&gt; [1,] 0 0 #&gt; [2,] 4 0 #&gt; [3,] 4 4 #&gt; [4,] 0 4 #&gt; [5,] 0 0 (p1 = st_polygon(list(ring1))) #&gt; POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0)) (ring2 = ring1 + 5) #&gt; [,1] [,2] #&gt; [1,] 5 5 #&gt; [2,] 9 5 #&gt; [3,] 9 9 #&gt; [4,] 5 9 #&gt; [5,] 5 5 (ring3 = (ring1[5:1,] / 4) + 6) #&gt; [,1] [,2] #&gt; [1,] 6 6 #&gt; [2,] 6 7 #&gt; [3,] 7 7 #&gt; [4,] 7 6 #&gt; [5,] 6 6 (p2 = st_polygon(list(ring2, ring3))) #&gt; POLYGON ((5 5, 9 5, 9 9, 5 9, 5 5), (6 6, 6 7, 7 7, 7 6, 6 6)) A MULTIPOLYGON can be constructed as a list of lists of matrices: (mpol = st_multipolygon(list(list(ring1), list(ring2, ring3)))) #&gt; MULTIPOLYGON (((0 0, 4 0, 4 4, 0 4, 0 0)), ((5 5, 9 5, 9 9, 5 9, 5 5), (6 6, 6 7, 7 7, 7 6, 6 6))) And finally, a GEOMETRYCOLLECTION can be constructed from a list of typed geometries: st_geometrycollection(list(pt, mp, ls, mpol)) #&gt; GEOMETRYCOLLECTION (POINT (0 1), MULTIPOINT (8 1, 2 5, 3 2), LINESTRING (8 1, 2 5, 3 2), MULTIPOLYGON (((0 0, 4 0, 4 4, 0 4, 0 0)), ((5 5, 9 5, 9 9, 5 9, 5 5), (6 6, 6 7, 7 7, 7 6, 6 6)))) 3.2.1.1 WKT, WKB encodings By default, package sf prints the same number of digits as R, but this can be manipulated: st_point(c(1/3, 2/3)) #&gt; POINT (0.333 0.667) old = options(digits = 16) st_point(c(1/3, 2/3)) #&gt; POINT (0.3333333333333333 0.6666666666666666) options(digits = 3) st_point(c(1/3, 2/3)) #&gt; POINT (0.333 0.667) options(digits = old$digits) # set back An encoding that is more useful for machine-to-machine communication is well-known binary. An example of a round-trip R \\(\\rightarrow\\) binary \\(\\rightarrow\\) R is (wkb = st_as_binary(st_point(c(1/3, 2/3)))) #&gt; [1] 01 01 00 00 00 55 55 55 55 55 55 d5 3f 55 55 55 55 55 55 e5 3f st_as_sfc(wkb)[[1]] #&gt; POINT (0.333 0.667) Object r is a raw vector, which is little useful in R. Binary conversion is used to communicate geometries to external libraries (GDAL, GEOS, liblwgeom) and and spatial databases because it is fast and lossless. Whenever there is a choice, binary encoding should be prefered over text encoding. 3.2.1.2 simple, valid, empty Methods st_is_simple and st_is_valid help detect non-simple and non-valid geometries: st_is_simple(st_linestring(rbind(c(0,0), c(1,1), c(1,0), c(0,1)))) # self-intersects #&gt; [1] FALSE st_is_valid(st_polygon(list(rbind(c(1,1), c(0,0), c(1,1), c(2,2), c(2,1), c(1,1))))) # repeats #&gt; [1] FALSE A very important concept in the feature geometry framework is that of the empty geometry. We can think of an empty geometry as similar to the NA value in vectors: it is a placeholder, but a usable value is not available. Empty geometries arise naturally when we do geometrical operations (chapter 5), for instance when we want to know where two disjoint geometries coincide: (e = st_intersection(st_point(c(0,0)), st_point(c(1,1)))) #&gt; GEOMETRYCOLLECTION EMPTY It is not entirely clear what the benefit is of having empty geometries typed, but according to the simple feature standard they are. They are detected by st_is_empty(e) #&gt; [1] TRUE 3.2.1.3 Conversion between geometry types Up to the extent that a conversion is feasible, we can convert simple feature geometries using the st_cast generic: methods(st_cast) #&gt; [1] st_cast.CIRCULARSTRING* st_cast.COMPOUNDCURVE* #&gt; [3] st_cast.CURVE* st_cast.GEOMETRYCOLLECTION* #&gt; [5] st_cast.LINESTRING* st_cast.MULTILINESTRING* #&gt; [7] st_cast.MULTIPOINT* st_cast.MULTIPOLYGON* #&gt; [9] st_cast.MULTISURFACE* st_cast.POINT* #&gt; [11] st_cast.POLYGON* st_cast.sf* #&gt; [13] st_cast.sfc* st_cast.sfc_CIRCULARSTRING* #&gt; see &#39;?methods&#39; for accessing help and source code Conversion is required e.g. to be able to plot curved geometries. CURVE, COMPOUNDCURVE and CIRCULARSTRING have st_cast methods to cast them to LINESTRING; MULTISURFACE has an st_cast method to MULTIPOLYGON. An example, needed for plotting, is (ls &lt;- st_as_sfc(&quot;CIRCULARSTRING(0 0,1 0,1 1)&quot;) %&gt;% st_cast(&quot;LINESTRING&quot;)) #&gt; Geometry set for 1 feature #&gt; geometry type: LINESTRING #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: -0.207 xmax: 1.21 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; LINESTRING (0 0, 0.0361 -0.0337, 0.0745 -0.0647... plot(ls, axes = TRUE) It is convenient in other cases to analyse the point pattern from a set of vertices in a linestring. However, rbind(c(0,0), c(1,1), c(1,0), c(0,1)) %&gt;% st_linestring() %&gt;% st_cast(&quot;POINT&quot;) #&gt; Warning in st_cast.LINESTRING(., &quot;POINT&quot;): point from first coordinate only #&gt; POINT (0 0) does not what we expect, because it will convert a single geometry into a new single geometry. We can convert to a MULTIPOINT rbind(c(0,0), c(1,1), c(1,0), c(0,1)) %&gt;% st_linestring() %&gt;% st_cast(&quot;POINT&quot;) #&gt; Warning in st_cast.LINESTRING(., &quot;POINT&quot;): point from first coordinate only #&gt; POINT (0 0) but if we want to have a set of points, we need to work with sets first, because we want a set with another cardinality: (p &lt;- rbind(c(0,0), c(1,1), c(1,0), c(0,1)) %&gt;% st_linestring() %&gt;% st_sfc() %&gt;% st_cast(&quot;POINT&quot;)) #&gt; Geometry set for 4 features #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 0 xmax: 1 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; POINT (0 0) #&gt; POINT (1 1) #&gt; POINT (1 0) #&gt; POINT (0 1) This is further explained in the next section. 3.2.1.4 GEOMETRYCOLLECTION handling Single features can have a geometry that consists of several subgeometries of different type, held in a GEOMETRYCOLLECTION. This may sound like looking for trouble, but these arise rather naturally when looking for intersections. For instance, the intersection of two LINESTRING geometries may be the combination of a LINESTRING and a POINT. Putting this intersection into a single feature geometry needs a GEOMETRYCOLLECTION. In case we end up with GEOMETRYCOLLECTION objects, the next question is often what to do with them. One thing we can do is extract elements from them: pt &lt;- st_point(c(1, 0)) ls &lt;- st_linestring(matrix(c(4, 3, 0, 0), ncol = 2)) poly1 &lt;- st_polygon(list(matrix(c(5.5, 7, 7, 6, 5.5, 0, 0, -0.5, -0.5, 0), ncol = 2))) poly2 &lt;- st_polygon(list(matrix(c(6.6, 8, 8, 7, 6.6, 1, 1, 1.5, 1.5, 1), ncol = 2))) multipoly &lt;- st_multipolygon(list(poly1, poly2)) j &lt;- st_geometrycollection(list(pt, ls, poly1, poly2, multipoly)) st_collection_extract(j, &quot;POLYGON&quot;) #&gt; Geometry set for 3 features #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: 5.5 ymin: -0.5 xmax: 8 ymax: 1.5 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; MULTIPOLYGON (((5.5 0, 7 0, 7 -0.5, 6 -0.5, 5.5... #&gt; MULTIPOLYGON (((6.6 1, 8 1, 8 1.5, 7 1.5, 6.6 1))) #&gt; MULTIPOLYGON (((5.5 0, 7 0, 7 -0.5, 6 -0.5, 5.5... st_collection_extract(j, &quot;POINT&quot;) #&gt; POINT (1 0) st_collection_extract(j, &quot;LINESTRING&quot;) #&gt; LINESTRING (4 0, 3 0) which sometimes results in a geometry set, sometimes in single geometries. 3.2.2 sfc: sets of geometries Rather than handling geometries individually, we typically handle them as sets. Package sf provides a dedicated class for this, called sfc (for simple feature geometry list column). We can create such a list with st_sfc: (sfc = st_sfc(st_point(c(0,1)), st_point(c(-3,2)), crs = 4326)) #&gt; Geometry set for 2 features #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: -3 ymin: 1 xmax: 0 ymax: 2 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; POINT (0 1) #&gt; POINT (-3 2) The default report from the print method for sfc gives the number of features geometries the feature geometry type (here: POINT) the feature geometry dimension (here: XY) the bounding box for the set the coordinate reference system for the set (epsg and proj4string: see chapter 7.2) the first few geometries, as (abbreviated) WKT The class of the geometry list-column, class(sfc) #&gt; [1] &quot;sfc_POINT&quot; &quot;sfc&quot; is again a combination of a specific class, and a superclass. In addition to a class, the object has further attributes attributes(sfc) %&gt;% names() %&gt;% setdiff(&quot;class&quot;) #&gt; [1] &quot;precision&quot; &quot;bbox&quot; &quot;crs&quot; &quot;n_empty&quot; which are used to record for the hole set: a precision value (section 5.4) the bounding box enclosing all geometries (for x and y) a coordinate reference system (section 7.2) the number of empty geometries contained in the set This means that all these properties are defined for the set, and not for geometries individually. As we’ve seen above, sets of geometries arise when we tear apart compound geometries, as in (p &lt;- rbind(c(0,0), c(1,1), c(1,0), c(0,1)) %&gt;% st_linestring() %&gt;% st_sfc() %&gt;% st_cast(&quot;POINT&quot;)) #&gt; Geometry set for 4 features #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 0 xmax: 1 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; POINT (0 0) #&gt; POINT (1 1) #&gt; POINT (1 0) #&gt; POINT (0 1) Here, st_sfc creates a set of one LINESTRING, and the resulting set has size 4: length(p) #&gt; [1] 4 Going the other way around, we need st_combine to combine geometries into one: p %&gt;% st_combine #&gt; Geometry set for 1 feature #&gt; geometry type: MULTIPOINT #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 0 xmax: 1 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; MULTIPOINT (0 0, 1 1, 1 0, 0 1) p %&gt;% st_combine %&gt;% st_cast(&quot;LINESTRING&quot;) #&gt; Geometry set for 1 feature #&gt; geometry type: LINESTRING #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 0 xmax: 1 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; LINESTRING (0 0, 1 1, 1 0, 0 1) More general, in practice we will almost always work with sets of geometries, because in spatial data we typically associate an observation with a feature, which has a geometry, and we work with sets of observations. sfc objects are lists with each entry being an sfg object: p[[2]] #&gt; POINT (1 1) and we will use these lists as list columns in data.frame or tibble objects to represent simple features with geometries in a list column. These objects are of class sf. 3.2.2.1 Feature sets with mixed geometries Sets of simple features also consist of features with heterogeneous geometries. In this case, the geometry type of the set is GEOMETRY: (g = st_sfc(st_point(c(0,0)), st_linestring(rbind(c(0,0), c(1,1))))) #&gt; Geometry set for 2 features #&gt; geometry type: GEOMETRY #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 0 xmax: 1 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; POINT (0 0) #&gt; LINESTRING (0 0, 1 1) These can be filtered by using st_is g %&gt;% st_is(&quot;LINESTRING&quot;) #&gt; [1] FALSE TRUE or, when working with sf objects, st_sf(g) %&gt;% filter(st_is(., &quot;LINESTRING&quot;)) #&gt; Simple feature collection with 1 feature and 0 fields #&gt; geometry type: LINESTRING #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 0 xmax: 1 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; g #&gt; 1 LINESTRING (0 0, 1 1) 3.2.3 sf: geometries with attributes sf objects are tibbles or data.frames with feature geometry in a list column, and an sf class added: sf = st_sf(sfc) class(sf) #&gt; [1] &quot;sf&quot; &quot;data.frame&quot; Although there is nothing against simply using data.frames or tibbles with sfc list columns, a number of methods have been written for sf objects that should make life even more convenient, including plot methods that create maps. In addition to the usual data.frame attributes, sf objects have two more attributes: sf %&gt;% attributes() %&gt;% names() %&gt;% setdiff(c(&quot;row.names&quot;, &quot;class&quot;, &quot;names&quot;)) #&gt; [1] &quot;sf_column&quot; &quot;agr&quot; They are: sf_column: a length one character vector with the name of the (active) geometry list-column. Note that sf objects may contain multiple geometry list-columns, but the one named here is used for all operations, as the ``active’’ geometry. agr: attribute-geometry relationships; this encodes for each of the attributes how it relates to the geometry (in case of a non-point geometry): is it constant throughout the geometry like a soil type, is it an aggregate over the geometry like a population count, or does it identify the geometry like a state name? Read more about this in section 6.1. 3.3 Tesselations: Coverages, rasters A common case in spatial data analysis is that an area is split (tesselated) in a number of non-overlapping regions. Although this can be modelled by a sequence of simple feature geometries (polygons), it is hard to guarantee for a set of simple feature polygons that they overlap nowhere, or that there are no gaps between them. More fundamental ways of storing such polygons use a topological model, examples of this are found in geographic information systems like GRASS GIS or ArcGIS. Topological models store every boundary between polygons only once, and register which polygon is on each side of a boundary. A simpler approach, associated with the term raster data, is to tesselate each spatial dimension \\(d\\) into regular cells, formed by left-closed and right-open intervals \\(d_i\\): \\[d_i = d_0 + [~ i \\cdot \\delta, (i+1) \\cdot \\delta~)\\] with \\(d_0\\) an offset, \\(\\delta\\) the interval (raster cell or pixel) size, and where the cell index \\(i\\) is an arbitrary but consecutive set of integers. In arbitrary polygon tesselations, assigning points to polygons when they fall on a boundary shared by two polygons is ambiguous. Using left-closed “[” and right-open “)” intervals in regular tesselations removes this ambiguity. Tesselating the time dimension in this way is very common, and the implicit assumption underlying most time series packages in R. Different models can be combined: one could use simple feature polygons to tesselate space, and combine this with a regular tesselation of time in order to cover a space-time vector datacube. Raster data and data cubes are discussed in chapter 4. 3.4 Networks Spatial networks are typically composed of linear (LINESTRING) elements, but possess further topological properties describing the network coherence: start and endpoints of a linestring may be connected to other linestring start or end points, forming a set of nodes and edges edges may be directed, and allow for connections (flow, transport) in only one way. Several R packages (osmar, stplanr) have (limited) functionality available for constructing network objects, and working with them, e.g. computing shortest or fastest routes through a network. 3.5 Geometries on the sphere 3.5.1 Straight lines? The simple feature model assumes that linestrings and polygons are formed of points connected by straight lines. When however representing the Earth surface, what does a straight line mean? The simple feature standard does not help much, here: it assumes Carthesian space. Technically speaking, a straight line between two points on a sphere exists, but it crosses the sphere, which is not very practical in most cases. The most common case is to use great circle segments to connect points: the shortest path that follows the surface of the sphere or ellipsoid. This means that (with longitude latitude coordinates) the line between POINT(0 50) and POINT(10 50) does not cross POINT(5 50). It also means that the line between points on opposite sides of the sphere is ambiguous. Also, the direction of a great circle segment, when defined as the angle it has with meridians, is not constant. 3.5.2 Ring direction for polygons The simple feature standard is not conclusive about the direction of points in a ring. It points out that exterior rings should be counter clockwise, when seen from above, and interior rings (holes) clockwise, but for instance st_is_valid does not invalidate clockwise exterior rings: st_is_valid(st_polygon(list(rbind(c(0,0), c(0,1), c(1,1), c(0,0))))) #&gt; [1] TRUE This may have several reasons: a lot of data may come with wrong ring directions, and the distinction between exterior and interior rings is already unambiguous by their order: the first is exterior, anything following is interior. On the sphere, any polygon divides the sphere surface in two finite areas, meaning there is no longer an unambiguous “inside” vs. “outside”: does the polygon with longitude latitude coordinates POLYGON((0 0, 120 0, 240 0, 0 0)) denote the northern or the southern hemisphere? One can go two directions here: assume that in practice polygons never divide the Earth in two equal halves, and take the smaller area as their “inside” (adopted by the S2 library) decide strongly about ring direction, e.g. counter-clockwise (following the ring, standing on the Earth, the left-side of the ring denotes the polygon interior) Package sf comes with a large amount of functions that work both for projected (Cartesian) data as for data defined in spherical coordinates. Whenever it makes assumptions of Cartesian coordinates for spherical coordinates it emits a warning. This is discussed further in section 5.5. References "],
["raster.html", "Chapter 4 Raster data and datacubes", " Chapter 4 Raster data and datacubes differences, correspondence; properties of rasters; arrays "],
["geommanip.html", "Chapter 5 Geometric Manipulations 5.1 Unary Operations 5.2 Binary Operations 5.3 N-ary Operations 5.4 Precision 5.5 Warnings for longitude/latitude geometries", " Chapter 5 Geometric Manipulations Simple feature geometries can be queried for properties, combined into new geometries, and combinations of geometries can be queried for properties. This chapter will give an overview of the operations offered by sf. We can categorise operations in terms of what they take as input, and what they give as output. In terms of input we have operations that take a single geometry (unary operations) a pair of geometries (binary operations) a set of geometries (n-ary operations) and in terms of what is returned, we distinguish predicates, returning a logical asserting a certain property is TRUE measures, returning a numeric value (possibly with measurement unit) operations that return a new geometry, or a set of geometries We will now go through all combinations. 5.1 Unary Operations 5.1.1 Unary predicates st_is_simple st_is_valid st_is_longlat st_is == != : st_equals 5.1.2 Unary measures st_dimension st_area st_length st_geohash st_geometry_type 5.1.3 Unary operations returning a geometry st_centroid st_buffer st_jitter st_wrap_dateline st_boundary st_convex_hull st_line_merge merges, on a per-feature basis, connecting LINESTRING elements of a MULTILINESTRING into longer LINESTRINGs. st_make_valid st_node st_point_on_surface st_polygonize st_segmentize st_simplify lwgeom::st_split st_transform st_triangulate st_voronoi st_zm st_collection_extract st_cast Ops: + - (unary, binary) Ops: * / (sfg, Matrix) 5.2 Binary Operations 5.2.1 Binary predicates st_contains st_contains_properly st_covered_by st_covers st_crosses st_disjoint st_equals st_equals_exact st_intersects st_is_within_distance st_within st_touches st_overlaps 5.2.2 Binary measures st_distance st_relate 5.2.3 Binary operations returning a geometry st_intersection &amp; st_union | st_difference ‘/’ st_sym_differenc ‘%/%’ 5.3 N-ary Operations 5.3.1 N-ary operations returning a geometry For n-ary operations, we have only two, n-ary st_intersection and st_difference, which both return geometries, in case of st_intersection along with some properties for each of the geometry. st_make_grid st_graticule 5.4 Precision Geometrical operations, such as finding out whether a certain point is on a line, may fail when coordinates are represented by highly precise floating point numbers, such as 8-byte doubles in R. A remedy might be to limit the precision of the coordinates before the operation. For this, a precision model is adopted by sf. It uses a precision value to round coordinates (X, Y, Z and M) right before they are encoded as well-known binary, and passed on to the libraries where this may have an effect (GEOS, GDAL, liblwgeom). We demonstrate this by an R - WKB - R roundtrip. Rounding can be done by three different options. With a negative precision value, 8-byte doubles get converted to 4-byte floats and back again: old = options(digits = 16) (p = st_sfc(st_point(c(1e6/3, 1e4/3)))) #&gt; Geometry set for 1 feature #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 333333.333333333 ymin: 3333.33333333333 xmax: 333333.333333333 ymax: 3333.33333333333 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; POINT (333333.3333333333 3333.333333333333) p %&gt;% st_set_precision(-1) %&gt;% st_as_binary() %&gt;% st_as_sfc() %&gt;% `[[`(1) #&gt; POINT (333333.34375 3333.333251953125) With a positive precision \\(p\\), each coordinate value \\(c\\) is replaced by \\[c&#39; = \\mbox{round}(p \\cdot c) / p\\] This implies that for instance with a precision of 1000, the number of decimal placed to round to is 1/1000: p %&gt;% st_set_precision(1000) %&gt;% st_as_binary() %&gt;% st_as_sfc() %&gt;% `[[`(1) #&gt; POINT (333333.333 3333.333) With a precision of e.g. 0.001 or 0.05, rounding to the nearest 1/precision, i.e. 1000 or 20, is obtained: p %&gt;% st_set_precision(0.001) %&gt;% st_as_binary() %&gt;% st_as_sfc() %&gt;% `[[`(1) # nearest 1000 #&gt; POINT (333000 3000) p %&gt;% st_set_precision(0.05) %&gt;% st_as_binary() %&gt;% st_as_sfc() %&gt;% `[[`(1) # nearest 20 #&gt; POINT (333340 3340) options(digits = old$digits) In essence, these rounding methods bring the coordinates to points on a regular grid, which is beneficial for geometric computations. Of course, it also affects all computations like areas and distances. Which precision values are best for which application is often a matter of trial and error. A reproducible example illustrating the need for setting precision is found here. 5.5 Warnings for longitude/latitude geometries In st_centroid.sfc(st_geometry(x), of_largest_polygon = of_largest_polygon) : st_centroid does not give correct centroids for longitude/latitude data How serious is this? "],
["featureattributes.html", "Chapter 6 Feature attributes 6.1 Attribute-geometry relationship 6.2 Spatial join 6.3 Aggregate and summarise 6.4 Intersections 6.5 Area-weighted interpolation 6.6 Exercises", " Chapter 6 Feature attributes Feature attributes refer to the properties of features (“things”) that do not describe the feature’s geometry. Feature attributes can be derived from geometry (e.g. lenght of a LINESTRING, area of a POLYGON) but they can also refer to completely different properties, such as the name of a street or a county, the number of people living in a country, the type of a road the soil type in a polygon from a soil map. the opening hours of a shop Although we believe that temporal properties of features are at no less fundamental than their spatial properties, the simple feature access standard and consequently the sf package does not give time a similar role as space; more on that in chapter 21. Most sf objects will contain both geometries and attributes for features. The geometric operations described in the previous chapter 5 operate on geometries only. When applied to an object of class sf, all unary operations will, for functions returning a predicate or a measure, ignore all attributes a geometr y, replace the object’s geometry. In all these cases, attribute values remain unmodified. At first sight, that looks rather harmless. But if we look into a simple case of replacing a county boundary with a county centroid, as in library(sf) library(dplyr) system.file(&quot;gpkg/nc.gpkg&quot;, package=&quot;sf&quot;) %&gt;% read_sf() %&gt;% st_transform(32119) %&gt;% select(BIR74, SID74, NAME) %&gt;% st_centroid() %&gt;% head(n = 1) #&gt; Warning in st_centroid.sf(.): st_centroid assumes attributes are constant #&gt; over geometries of x #&gt; Simple feature collection with 1 feature and 3 fields #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 386000 ymin: 3e+05 xmax: 386000 ymax: 3e+05 #&gt; epsg (SRID): 32119 #&gt; proj4string: +proj=lcc +lat_1=36.16666666666666 +lat_2=34.33333333333334 +lat_0=33.75 +lon_0=-79 +x_0=609601.22 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs #&gt; # A tibble: 1 x 4 #&gt; BIR74 SID74 NAME geom #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;POINT [m]&gt; #&gt; 1 1091 1 Ashe (385605 3e+05) we receive a warning. This warning is justified for the first two variables shown (total births and number of SID disease cases, 1974) which, as such, are not associated with a feature whose geometry is POINT (385605.4 300303.5). The third variable, NAME is however still the county name for the point indicated, but the point geometry no longer is the county geometry. 6.1 Attribute-geometry relationship Changing the feature geometry without changing the feature attributes does change the feature, since the feature is characterised by the combination of geometry and attributes. Can we, ahead of time, predict whether the resulting feature will still meaningfully relate to the attribute data when we for instance replaced all geometries with their convex hull or centroid? It depends. Take the example of a road, represented by a LINESTRING, which has an attribute property road width equal to 10 m. What can we say about the road width of an arbitray subsectin of this road? That depends on whether the attribute road length describes, for instance the road width everywhere, meaning that road width is constant along the road, or whether it describes an aggregate property, such as minimum or average road width. In case of the minimum, for an arbitrary subsection of the road one could still argue that the minimum road with must be at least as large as the minimum road width for the whole segment, but it is no longer the minimum for that subsection. This gives us two “types” for the attribute-geometry relationship (AGR): constant the attribute value is valid everywhere in or over the geometry aggregate the attribute is an aggregate, a summary value over the geometry For polygon data, typical examples of constant AGR are land use for a land use polygon rock units or geologic strata in a geological map soil type in a soil map elevation class in a elevation map that shows elevation as classes klimate zone in a climate zone map Typical examples for the aggregate AGR are population, either as number of persons or as population density other socio-economic data, summarised by area total emission of pollutants by region A third type of AGR is that where an attribute identifies a feature geometry. The example above is county NAME: the name identifies the county, and is still the county NAME for any sub-area. identity the attribute value uniquely identifies the geometry, there are no other geometries with the same value Arbitrary sub-areas will lose the identity property but becomes a constant attribute. An example is: any point inside a county is still part of the county and must have the same value for county name, but it does not longer represent the (total) geometry of that county. We can specify the AGR of an attribute in an sf object by st_set_agr: nc &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package=&quot;sf&quot;) %&gt;% read_sf() %&gt;% st_transform(32119) nc1 &lt;- nc %&gt;% select(BIR74, SID74, NAME) %&gt;% st_set_agr(c(BIR74 = &quot;aggregate&quot;, SID74 = &quot;aggregate&quot;, NAME = &quot;identity&quot;)) This helps to get rid of warnings that a particular attribute is assumed to be constant over a geometry, if it already is. The following no longer generates a warning nc1 %&gt;% select(NAME) %&gt;% st_centroid() %&gt;% head(1) #&gt; Simple feature collection with 1 feature and 1 field #&gt; Attribute-geometry relationship: 1 constant, 0 aggregate, 0 identity #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 386000 ymin: 3e+05 xmax: 386000 ymax: 3e+05 #&gt; epsg (SRID): 32119 #&gt; proj4string: +proj=lcc +lat_1=36.16666666666666 +lat_2=34.33333333333334 +lat_0=33.75 +lon_0=-79 +x_0=609601.22 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs #&gt; # A tibble: 1 x 2 #&gt; NAME geom #&gt; &lt;chr&gt; &lt;POINT [m]&gt; #&gt; 1 Ashe (385605 3e+05) and also changes AGR for NAME from identity to constant when replacing the geometry with the geometry’s centroid: nc1 %&gt;% select(NAME) %&gt;% st_centroid() %&gt;% st_agr() #&gt; NAME #&gt; constant #&gt; Levels: constant aggregate identity 6.2 Spatial join 6.3 Aggregate and summarise 6.4 Intersections Suppose we have two datasets with different geometries and attributes, and we want to compute their intersections: p1 = st_polygon(list(rbind(c(0,0), c(4,0), c(4,4), c(0,4), c(0,0)))) d1 = st_sf(a = c(3,1), geom = st_sfc(p1, p1 + c(4, 0))) d2 = st_sf(b = c(4), geom = st_sfc(p1 * .75 + c(3, 2))) plot(d1, xlim = c(0,8), ylim = c(0, 6), col = NA, border = 1, reset = FALSE) plot(d2, col = NA, border = &#39;red&#39;, add = TRUE, lwd = 2) What will the intersection of these two objects give? (i = st_intersection(d1, d2)) #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Simple feature collection with 2 features and 2 fields #&gt; geometry type: POLYGON #&gt; dimension: XY #&gt; bbox: xmin: 3 ymin: 2 xmax: 6 ymax: 4 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; a b geom #&gt; 1 3 4 POLYGON ((3 4, 4 4, 4 2, 3 ... #&gt; 2 1 4 POLYGON ((4 2, 4 4, 6 4, 6 ... plot(d1, xlim = c(0,8), ylim = c(0, 6), col = NA, border = 1, lwd = 2, reset = FALSE) plot(d2, col = NA, border = &#39;red&#39;, add = TRUE, lwd = 3) plot(st_geometry(i), add = TRUE, col = grey(c(.7,.9)), , border = &#39;green&#39;, lwd = 1) It gives the areas of intersection, along with the corresponding attributes of both objects, and a warning that attributes were assumed to be spatially constant. 6.5 Area-weighted interpolation Suppose we want to combine geometries and attributes of two datasets such, that we get attribute values of the first datasets summarised for the geometries of the second. There are various ways we can go for this. The simples one, building on the previous example, would be to obtain for the geometry of d2 the attribute of d1 that has the largest overlap with d2. This is obtained by st_join(d2, d1, largest = TRUE) #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Simple feature collection with 1 feature and 2 fields #&gt; geometry type: POLYGON #&gt; dimension: XY #&gt; bbox: xmin: 3 ymin: 2 xmax: 6 ymax: 5 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; b a geom #&gt; 1 4 1 POLYGON ((3 2, 6 2, 6 5, 3 ... Another option would be to summarise the attribute, e.g. taking its mean, regardless the amount of overlap. This is obtained by aggregate(d1, d2, mean) #&gt; Simple feature collection with 1 feature and 1 field #&gt; geometry type: POLYGON #&gt; dimension: XY #&gt; bbox: xmin: 3 ymin: 2 xmax: 6 ymax: 5 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; a geometry #&gt; 1 2 POLYGON ((3 2, 6 2, 6 5, 3 ... A third option is to apply area-weighted interpolation, meaning that we interpolate (average) the variable by taking into account the respective area contributions of overlap. This is done e.g. by d3 = st_sfc(p1 * .75 + c(3, 2), p1 * .75 + c(3,3)) st_interpolate_aw(d1, d3, extensive = FALSE)$a #&gt; Warning in st_interpolate_aw(d1, d3, extensive = FALSE): st_interpolate_aw #&gt; assumes attributes are constant over areas of x #&gt; [1] 1.67 1.67 st_interpolate_aw(d1, d3, extensive = TRUE)$a #&gt; Warning in st_interpolate_aw(d1, d3, extensive = TRUE): st_interpolate_aw #&gt; assumes attributes are constant over areas of x #&gt; [1] 0.625 0.312 6.5.1 Spatially intensive and extensive variables The difference between the two examples for area-weighted interpolation is how the final weighted sum (value times area of intersection) is normalised: by the target area (extensive), or by the sum of the area covered (intensive, extensive = FALSE). Spatially intensive variables are variables for which the value, when we split an area, does not principally change. An example might be temperature, elevation, or population density. Spatially extensive variables are variables for which the value is also split, according to the area. Examples are population (amount), or area. 6.6 Exercises Add a variable to the nc dataset by nc$State = &quot;North Carolina&quot;. Which value should you attach to this variable for the attribute-geometry relationship (agr)? Create a new sf object from the geometry obtained by st_union(nc), and assign &quot;North Carolina&quot; to the variable State. Which agr can you now assign to this attribute variable? Use st_area to add a variable with name area to nc. Compare the area and AREA variables in the nc dataset. What are the units of AREA? Are the two linearly related? If there are discrepancies, what could be the cause? Is the area variable intensive or extensive? Is its agr equal to constant, identity or aggregate? Find the name of the county that contains POINT(-78.34046 35.017) Find the names of all counties with boundaries that touch county Sampson. List the names of all counties that are less than 50 km away from county Sampson. "],
["rs.html", "Chapter 7 Reference Systems 7.1 Units of measurement 7.2 Coordinate Reference Systems 7.3 Coordinate transformation and conversion", " Chapter 7 Reference Systems Units of measure, reference systems, coordinate transformation and conversion 7.1 Units of measurement Measurement units: (Hand 2004); quantities (David Flater 2018), (D. Flater 2016) 7.2 Coordinate Reference Systems what is EPSG, what is proj4string; WKT, WKT2 What is a datum? 7.3 Coordinate transformation and conversion Geodesics: (Karney 2013) References "],
["plotting-spatial-data.html", "Chapter 8 Plotting spatial data", " Chapter 8 Plotting spatial data Plotting of lines, symbols, polygons (choroplets; overlapping polygons), rasters using color "],
["plot.html", "Chapter 9 Base Plot", " Chapter 9 Base Plot "],
["ggplot2.html", "Chapter 10 ggplot2", " Chapter 10 ggplot2 geom_sf examples; useful annotations and manipulations "],
["interactive-maps.html", "Chapter 11 Interactive Maps", " Chapter 11 Interactive Maps base plot: identify, locator leaflet, tmap, mapview mapedit? "],
["summarizing-geometries.html", "Chapter 12 Summarizing Geometries", " Chapter 12 Summarizing Geometries Properties: dimension, length, area, etc, if not earlier in Ch 3? counts, density, intensity (units; meaningful) "],
["point-pattern-analysis.html", "Chapter 13 Point Pattern Analysis", " Chapter 13 Point Pattern Analysis Basics PP, beyond counting; basic steps in PPA sf - spatstat interface; rasters; "],
["manipulating-attributes-summarise-aggregate-union-sample.html", "Chapter 14 Manipulating attributes: summarise, aggregate, union, sample", " Chapter 14 Manipulating attributes: summarise, aggregate, union, sample "],
["units-of-measure-revisited-attribute-units-intensive-and-extensive-variables.html", "Chapter 15 Units of measure revisited: attribute units, intensive and extensive variables", " Chapter 15 Units of measure revisited: attribute units, intensive and extensive variables "],
["up-and-downscaling.html", "Chapter 16 Up- and Downscaling", " Chapter 16 Up- and Downscaling sampling largest sub-geometry area-weighted interpolation "],
["spatial-interpolation-and-geostatistics.html", "Chapter 17 Spatial Interpolation and geostatistics", " Chapter 17 Spatial Interpolation and geostatistics intro ; variograms; gstat (needs to be sf-ed) "],
["area-data-and-spatial-correlation.html", "Chapter 18 Area Data and Spatial Correlation", " Chapter 18 Area Data and Spatial Correlation spdep stuff "],
["spatial-regression-and-autocorrelation.html", "Chapter 19 Spatial Regression and Autocorrelation", " Chapter 19 Spatial Regression and Autocorrelation intro; "],
["raster-modelling.html", "Chapter 20 Raster Modelling", " Chapter 20 Raster Modelling map algebra; ABM; SDM; Robert’s book. "],
["array.html", "Chapter 21 Array data: raster and vector data cubes", " Chapter 21 Array data: raster and vector data cubes "],
["movement-data.html", "Chapter 22 Movement data", " Chapter 22 Movement data "],
["statistical-modelling-of-spatiotemporal-data.html", "Chapter 23 Statistical modelling of spatiotemporal data", " Chapter 23 Statistical modelling of spatiotemporal data "],
["scalability.html", "Chapter 24 Scalability 24.1 Out-of-memory 24.2 Out-of-core", " Chapter 24 Scalability 24.1 Out-of-memory PostGIS; pass on hard work to db 24.2 Out-of-core sf - hive - spark - geomesa "],
["r-data-structures.html", "R data structures 24.3 Homogeneous vectors 24.4 Heterogeneous vectors: list 24.5 Attributes 24.6 various names attributes 24.7 using structure", " R data structures This chapter provides some minimal set of R basics that may make it easier to read this book. A more comprehensive book on R basics is given in (Wickham 2014), chapter 2. As pointed out by (Chambers 2016), everything that exists in R is an object. This includes objects that make things happen, such as language objects or functions, but also the more basic “things”, such as data objects. 24.3 Homogeneous vectors Data objects contain data, and possibly metadata. Data is always in the form of a vector, which can have different type. We can find the type by typeof, and vector length by length. Vectors are created by c, which combines individual elements: typeof(1:10) #&gt; [1] &quot;integer&quot; length(1:10) #&gt; [1] 10 typeof(1.0) #&gt; [1] &quot;double&quot; length(1.0) #&gt; [1] 1 typeof(c(&quot;foo&quot;, &quot;bar&quot;)) #&gt; [1] &quot;character&quot; length(c(&quot;foo&quot;, &quot;bar&quot;)) #&gt; [1] 2 typeof(c(TRUE, FALSE)) #&gt; [1] &quot;logical&quot; Vectors of this kind can only have a single type. Note that vectors can have length zero, e.g. in, i = integer(0) typeof(i) #&gt; [1] &quot;integer&quot; i #&gt; integer(0) length(i) #&gt; [1] 0 We can retrieve (or in assignments: replace) elements in a vector using [ or [[: a = c(1,2,3) a[2] #&gt; [1] 2 a[[2]] #&gt; [1] 2 a[2:3] #&gt; [1] 2 3 a[2:3] = c(5,6) a #&gt; [1] 1 5 6 a[[3]] = 10 a #&gt; [1] 1 5 10 where the difference is that [ can operate on an index range (or multiple indexes), and [[ operates on a single vector value. 24.4 Heterogeneous vectors: list An additional vector type is the list, which can combine any types in its elements: l &lt;- list(3, TRUE, &quot;foo&quot;) typeof(l) #&gt; [1] &quot;list&quot; length(l) #&gt; [1] 3 For lists, there is a further distinction between [ and [[: the single [ returns always a list, and [[ returns the contents of a list element: l[1] #&gt; [[1]] #&gt; [1] 3 l[[1]] #&gt; [1] 3 For replacement, one case use [ when providing a list, and [[ when providing a new value: l[1:2] = list(4, FALSE) l #&gt; [[1]] #&gt; [1] 4 #&gt; #&gt; [[2]] #&gt; [1] FALSE #&gt; #&gt; [[3]] #&gt; [1] &quot;foo&quot; l[[3]] = &quot;bar&quot; l #&gt; [[1]] #&gt; [1] 4 #&gt; #&gt; [[2]] #&gt; [1] FALSE #&gt; #&gt; [[3]] #&gt; [1] &quot;bar&quot; In case list elements are named, as in l = list(first = 3, second = TRUE, third = &quot;foo&quot;) l #&gt; $first #&gt; [1] 3 #&gt; #&gt; $second #&gt; [1] TRUE #&gt; #&gt; $third #&gt; [1] &quot;foo&quot; we can use names as in l[[&quot;second&quot;]] and this can be abbreviated to l$second #&gt; [1] TRUE l$second = FALSE l #&gt; $first #&gt; [1] 3 #&gt; #&gt; $second #&gt; [1] FALSE #&gt; #&gt; $third #&gt; [1] &quot;foo&quot; This is convenient, but also requires name look-up in the names attribute (see below). 24.4.1 NULL and removing list elements NULL is the null value in R; it is special in the sense that it doesn’t work in simple comparisons: 3 == NULL # not FALSE! #&gt; logical(0) NULL == NULL # not even TRUE! #&gt; logical(0) but has to be treated specially, using is.null: is.null(NULL) #&gt; [1] TRUE When we want to remove one or more list elements, we can do so by creating a new list that does not contain the elements that needed removal, as in l = l[c(1,3)] # remove second, implicitly l #&gt; $first #&gt; [1] 3 #&gt; #&gt; $third #&gt; [1] &quot;foo&quot; but we can also assign NULL to the element we want to eliminate: l$second = NULL l #&gt; $first #&gt; [1] 3 #&gt; #&gt; $third #&gt; [1] &quot;foo&quot; 24.5 Attributes We can glue arbitrary metadata objects to data objects, as in a = 1:3 attr(a, &quot;some_meta_data&quot;) = &quot;foo&quot; a #&gt; [1] 1 2 3 #&gt; attr(,&quot;some_meta_data&quot;) #&gt; [1] &quot;foo&quot; and this can be retrieved, or replaced by attr(a, &quot;some_meta_data&quot;) #&gt; [1] &quot;foo&quot; attr(a, &quot;some_meta_data&quot;) = &quot;bar&quot; attr(a, &quot;some_meta_data&quot;) #&gt; [1] &quot;bar&quot; In essence, the attribute of an object is a named list, and we can get or set the complete list by attributes(a) #&gt; $some_meta_data #&gt; [1] &quot;bar&quot; attributes(a) = list(some_meta_data = &quot;foo&quot;) attributes(a) #&gt; $some_meta_data #&gt; [1] &quot;foo&quot; A number of attributes are treated specially by R, see e.g. ?attributes. 24.5.1 object class and class attribute Every object in R “has a class”, meaning that class(obj) returns a character vector with the class of obj. Some objects have an implicit class, e.g. vectors class(1:3) #&gt; [1] &quot;integer&quot; class(c(TRUE, FALSE)) #&gt; [1] &quot;logical&quot; class(c(&quot;TRUE&quot;, &quot;FALSE&quot;)) #&gt; [1] &quot;character&quot; but we can also set the class explicit, either by using attr or by using class in the left-hand side of an expression: a = 1:3 class(a) = &quot;foo&quot; a #&gt; [1] 1 2 3 #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;foo&quot; class(a) #&gt; [1] &quot;foo&quot; attributes(a) #&gt; $class #&gt; [1] &quot;foo&quot; in which case the newly set class overrides the earlier implicit class. This way, we can add methods for class foo, e.g. by print.foo = function(x, ...) print(paste(&quot;an object of class foo with length&quot;, length(x))) print(a) #&gt; [1] &quot;an object of class foo with length 3&quot; Providing such methods are generally intended to create more usable software, but at the same time they may make the objects more opaque. It is sometimes useful to see what an object “is made of” by printing it after the class attribute is removed, as in unclass(a) #&gt; [1] 1 2 3 As a more elaborate example, consider the case where a polygon is made using package sf: library(sf) p = st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,0)))) p #&gt; POLYGON ((0 0, 1 0, 1 1, 0 0)) which prints the well-known-text form; to understand what the data structure is like, we can use unclass(p) #&gt; [[1]] #&gt; [,1] [,2] #&gt; [1,] 0 0 #&gt; [2,] 1 0 #&gt; [3,] 1 1 #&gt; [4,] 0 0 24.5.2 the dim attribute The dim attribute sets the matrix or array dimensions: a = 1:8 class(a) #&gt; [1] &quot;integer&quot; attr(a, &quot;dim&quot;) = c(2,4) # or: dim(a) = c(2,4) class(a) #&gt; [1] &quot;matrix&quot; a #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 3 5 7 #&gt; [2,] 2 4 6 8 attr(a, &quot;dim&quot;) = c(2,2,2) # or: dim(a) = c(2,2,2) class(a) #&gt; [1] &quot;array&quot; a #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 5 7 #&gt; [2,] 6 8 24.6 various names attributes Named vectors carry their names in a names attribute. We saw examples for lists above, an example for a numeric vector is: a = c(first = 3, second = 4, last = 5) a[&quot;second&quot;] #&gt; second #&gt; 4 attributes(a) #&gt; $names #&gt; [1] &quot;first&quot; &quot;second&quot; &quot;last&quot; More name attributes are e.g. dimnames of matrices or arrays: a = matrix(1:4, 2, 2) dimnames(a) = list(rows = c(&quot;row1&quot;, &quot;row2&quot;), cols = c(&quot;col1&quot;, &quot;col2&quot;)) a #&gt; cols #&gt; rows col1 col2 #&gt; row1 1 3 #&gt; row2 2 4 attributes(a) #&gt; $dim #&gt; [1] 2 2 #&gt; #&gt; $dimnames #&gt; $dimnames$rows #&gt; [1] &quot;row1&quot; &quot;row2&quot; #&gt; #&gt; $dimnames$cols #&gt; [1] &quot;col1&quot; &quot;col2&quot; Data.frame objects have rows and columns, and each have names: df = data.frame(a = 1:3, b = c(TRUE, FALSE, TRUE)) attributes(df) #&gt; $names #&gt; [1] &quot;a&quot; &quot;b&quot; #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 24.7 using structure When programming, the pattern of adding or modifying attributes before returning an object is extremely common, an example being: f = function(x) { a = create_obj(x) # call some other function attributes(a) = list(class = &quot;foo&quot;, meta = 33) a } The last two statements can be contracted in f = function(x) { a = create_obj(x) # call some other function structure(a, class = &quot;foo&quot;, meta = 33) } where function structure adds, replaces, or (in case of value NULL) removes attributes from the object in its first argument. References "],
["references.html", "References", " References "]
]
