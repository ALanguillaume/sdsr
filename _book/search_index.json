[
["area-data-and-spatial-autcorrelation.html", "Chapter 17 Area Data and Spatial Autcorrelation 17.1 Spatial autocorrelation 17.2 Spatial weights matrices 17.3 Measures of spatial autocorrelation 17.4 Spatial heterogeneity", " Chapter 17 Area Data and Spatial Autcorrelation Areal units of observation are very often used when simultaneous observations are aggregated within non-overlapping boundaries. The boundaries may be those of administrative entities, and may be related to underlying spatial processes, such as commuting flows, but are usually arbitrary. If they do not match the underlying and unobserved spatial processes in one or more variables of interest, proximate areal units will contain parts of the underlying processes, engendering spatial autocorrelation. This is at least in part because the aggregated observations are driven by factors which may or may not themselves have been observed. It is possible to represent the support of areal data by a point, despite the fact that the data have polygonal support. The centroid of the polygon may be taken as a representative point, or the centroid of the largest polygon in a multi-polygon object. When data with intrinsic point support are treated as areal data, the change of support goes the other way, from the known point to a non-overlapping tesselation such as a Voronoi diagram or Dirichlet tessellation or Theissen polygons often through a Delaunay triangulation when using a Euclidean plane. Here, different metrics may also be chosen, or distances measured on a network rather than on the plane. There is also a literature using weighted Voronoi diagrams in local spatial analysis (see for example Boots and Okabe 2007; Okabe et al. 2008; She et al. 2015). When the intrinsic support of the data is as points, but the underlying process is between proximate observations rather than driven chiefly by distance however measured between observations, the data may be aggregate counts or totals (polling stations, retail turnover) or represent a directly observed characteristic of the observation (opening hours of the polling station). Obviously, the risk of mis-representing the footprint of the underlying spatial processes remains in all of these cases, not least because the observations are taken as encompassing the entirety of the underlying process in the case of tesselation of the whole area of interest. This is distinct from the geostatistical setting in which observations are rather samples taken using some scheme within the area of interest. It is also partly distinct from the practice of taking areal sample plots within the area of interest but covering only a small proportion of the area, typically used in ecological and environmental research. This chapter then considers a subset of the methods potentially available for exploring spatial autocorrelation in areal data, or data being handled as areal, where the spatial processes are considered as working through proximity understood in the first instance as contiguity, as a graph linking observations taken as neighbours. This graph is typically undirected and unweighted, but may be directed and/or weighted in certain settings, which then lead to further issues with regard to symmetry. In principle, proximity would be expected to operate symmetrically in space, that is that the influence of \\(i\\) on \\(j\\) and of \\(j\\) on \\(i\\) based on their relative positions should be equivalent. Edge effects are not considered in standard treatments. 17.1 Spatial autocorrelation When analysing areal data, it has long been recognised that, if present, spatial autocorrelation changes how we may infer, relative to the default position of independent observations. In the presence of spatial autocorrelation, we can predict the values of observation \\(i\\) from the values observed at \\(j \\in N_i\\), the set of its proximate neighbours. Early results (Moran 1948; Geary 1954), entered into research practice gradually, for example the social sciences (Duncan, Cuzzort, and Duncan 1961). These results were then collated and extended to yield a set of basic tools of analysis (Cliff and Ord 1973, 1981). Cliff and Ord (1973) generalised and extended the expression of the spatial weights matrix representation as part of the framework for establishing the distribution theory for join count, Moran’s \\(I\\) and Geary’s \\(C\\) statistics. This development of what have become known as global measures, returning a single value of autocorrelation for the total study area, has been supplemented by local measures returning values for each areal unit (getis+ord:92; Anselin, n.d.). 17.2 Spatial weights matrices Handling spatial autocorrelation using relationships to neighbours on a graph takes the graph as given, chosen by the analyst. This differs from the geostatistical approach in which the analyst chooses the binning of the empirical variogram and function used, and then the way the fitted variogram is fitted. Both involve a priori choices, but represent the underlying correlation in different ways (Wall 2004). In Bavaud (1998) and work citing his contribution, attempts have been made to place graph-based neighbours in a broader context. One issue arising in the creation of objects representing neighbourhood relationships is that of no-neighbour areal units (Bivand and Portnov 2004). Islands or units separated by rivers may not be recognised as neighbours when the units have areal support and when using topological relationships such as shared boundaries. In some settings, for example mrf (Markov Random Field) terms in mgcv::gam() and similar model fitting functions that require undirected connected graphs, a requirement also violated when there are disconnected subgraphs. No-neighbour observations can also occur when a distance threshold is used between points, where the threshold is smaller than the maximum nearest neighbour distance. Shared boundary contiguities are not affected by using geographical, unprojected coordinates, but all point-based approaches use distance in one way or another, and need to calculate distances in an appropriate way. The spdep package provides an nb class for neighbours, a list of length equal to the number of observations, with integer vector components. No-neighbours are encoded as an integer vector with a single element 0L, and observations with neighbours as sorted integer vectors containing values in 1L:n pointing to the neighbouring observations. This is a typical row-oriented sparse representation of neighbours. spdep provides many ways of constructing nb objects, and the representation and construction functions are widely used in other packages. spdep builds on the nb representation (undirected or directed graphs) with the listw object, a list with three components, an nb object, a matching list of numerical weights, and a single element character vector containing the single letter name of the way in which the weights were calculated. The most frequently used approach in the social sciences is calculating weights by row standardization, so that all the non-zero weights for one observation will be the inverse of the cardinality of its set of neighbours (1/card(nb[[i]]). We will be using election data from the 2015 Polish Presidential election in this chapter, with 2495 municipalities and Warsaw boroughs, and complete count data from polling stations aggregated to these areal units. The data are an sf sf object: library(sf) data(pol_pres15, package=&quot;spDataLarge&quot;) head(pol_pres15[, c(1, 4, 6)]) #&gt; Simple feature collection with 6 features and 3 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: 235000 ymin: 367000 xmax: 281000 ymax: 413000 #&gt; epsg (SRID): NA #&gt; proj4string: +proj=tmerc +lat_0=0 +lon_0=18.99999999999998 +k=0.9993 +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0 +units=m +no_defs #&gt; TERYT name types geometry #&gt; 1 020101 BOLESŁAWIEC Urban MULTIPOLYGON (((261089 3855... #&gt; 2 020102 BOLESŁAWIEC Rural MULTIPOLYGON (((254150 3837... #&gt; 3 020103 GROMADKA Rural MULTIPOLYGON (((275346 3846... #&gt; 4 020104 NOWOGRODZIEC Urban/rural MULTIPOLYGON (((251770 3770... #&gt; 5 020105 OSIECZNICA Rural MULTIPOLYGON (((263424 4060... #&gt; 6 020106 WARTA BOLESŁAWIECKA Rural MULTIPOLYGON (((267031 3870... library(tmap) tm_shape(pol_pres15) + tm_fill(&quot;types&quot;) Figure 17.1: Polish municipality types 2015 Between early 2002 and April 2019, spdep contained functions for constructing and handling neighbour and spatial weights objects, tests for spatial autocorrelation, and model fitting functions. The latter have been split out into spatialreg, and will be discussed in the next chapter. spdep now accommodates objects represented using sf classes and sp classes directly, going beyond the explorations made in this vignette. library(spdep) 17.2.1 Contiguous neighbours The poly2nb() function in spdep takes the boundary points making up the polygon boundaries in the object passed as the pl= argument, and for each observation checks whether at least one (queen=TRUE, default), or at least two (rook, queen=FALSE) points are within snap= distance units of each other. The distances are planar in the raw coordinate units, ignoring geographical projections. Once the required number of sufficiently close points is found, the search is stopped. args(poly2nb) #&gt; function (pl, row.names = NULL, snap = sqrt(.Machine$double.eps), #&gt; queen = TRUE, useC = TRUE, foundInBox = NULL) #&gt; NULL The geometry column should be either of class &quot;sfc_MULTIPOLYGON&quot; or &quot;sfc_POLYGON&quot;, not &quot;sfc_GEOMETRY&quot;; if need be cast to &quot;MULTIPOLYGON&quot; if there are mixed &quot;POLYGON&quot; and &quot;MULTIPOLYGON&quot; objects. class(st_geometry(pol_pres15)) #&gt; [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot; table(sapply(st_geometry(pol_pres15), function(x) class(x)[2])) #&gt; #&gt; MULTIPOLYGON #&gt; 2495 system.time(nb_q &lt;- poly2nb(pol_pres15, queen=TRUE)) #&gt; user system elapsed #&gt; 1.140 0.012 1.157 nb_q #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 14242 #&gt; Percentage nonzero weights: 0.229 #&gt; Average number of links: 5.71 The rgeos gUnarySTRtreeQuery() function also reduces polygons to their boundary points before searching for overlapping “envelopes”, the bounding boxes of the derived multi-point objects. Here, pre-finding candidate contiguous neighbours only shaves off a little run time, but may be helpful with larger objects. system.time({ fB &lt;- rgeos::gUnarySTRtreeQuery(as(pol_pres15, &quot;Spatial&quot;)) nb_q1 &lt;- poly2nb(pol_pres15, queen=TRUE, foundInBox=fB) }) #&gt; user system elapsed #&gt; 0.880 0.000 0.882 all.equal(nb_q, nb_q1, check.attributes=FALSE) #&gt; [1] TRUE We might consider using the contiguity of the polygon boundaries, the fifth element of the DE-9IM vector, setting the first element to FALSE, to find Queen neighbours using GEOS functions in sf, but it takes longer than simply treating the boundaries as points: st_queen &lt;- function(a, b = a) st_relate(a, b, pattern = &quot;F***T****&quot;) as.nb.sgbp &lt;- function(x, ...) { attrs &lt;- attributes(x) x &lt;- lapply(x, function(i) { if(length(i) == 0L) 0L else i } ) attributes(x) &lt;- attrs class(x) &lt;- &quot;nb&quot; x } system.time(nb_sf_q &lt;- as.nb.sgbp(st_queen(pol_pres15))) #&gt; user system elapsed #&gt; 3.66 0.00 3.67 all.equal(nb_q, nb_sf_q, check.attributes=FALSE) #&gt; [1] TRUE The same effect as using rgeos::gUnarySTRtreeQuery can be obtained without the overhead of converting to the equivalent sp class and using rgeos to make the equivalent tree search using sf, by finding intersecting bounding boxes, removing self-intersections and duplicate intersections (contiguities are by definition symmetric, if i is a neighbour of j, then j is a neighbour of i). system.time({ fB1 &lt;- st_intersects(st_as_sfc(lapply(st_geometry(pol_pres15), function(x) { bb &lt;- st_bbox(x) mat &lt;- cbind(c(bb[1], bb[1], bb[3], bb[3], bb[1]), c(bb[2], bb[4], bb[4], bb[2], bb[2])) st_polygon(list(mat)) }))) fB1a &lt;- lapply(seq_along(fB1), function(i) fB1[[i]][fB1[[i]] &gt; i]) fB1a &lt;- fB1a[-length(fB1a)] nb_sf_q1 &lt;- poly2nb(pol_pres15, queen=TRUE, foundInBox=fB1a) }) #&gt; user system elapsed #&gt; 0.670 0.000 0.671 all.equal(nb_q, nb_sf_q1, check.attributes=FALSE) #&gt; [1] TRUE Much of the work involved in finding contiguous neighbours is spent on finding candidate neighbours with intersecting bounding boxes. Note that nb objects record both symmetric neighbour relationships, because these objects admit asymmetric relationships as well, but these duplications are not needed for object construction. Most of the spdep functions for constructing neighbour objects take a row.names= argument, the value of which is stored as a region.id attribute. If not given, the values are taken from row.names() of the first argument. These can be used to check that the neighbours object is in the same order as data. If nb objects are subsetted, the indices change to continue to be within 1:length(subsetted_nb), but the region.id attribute values point back to the object from which it was constructed. We can also check that this undirected graph is connected using the n.comp.nb() function: n.comp.nb(nb_q)$nc #&gt; [1] 1 17.2.2 Graph-based neighbours If areal units are an appropriate representation, but only points have been observed, contiguity relationships may be approximated using graph-based neighbours. In this case, the imputed boundaries tesselate the plane such that points closer to one observation than any other fall within its polygon. The simplest form is by using triangulation, here using the deldir() function in the deldir package. Because the function returns from and to identifiers, it is easy to construct a long representation of a listw object, as used in the S-Plus SpatialStats module and the sn2listw() function internally to construct an nb object (ragged wide representation). Alternatives often fail to return sufficient information to permit the neighbours to be identified. args(tri2nb) #&gt; function (coords, row.names = NULL) #&gt; NULL The soi.graph() function takes triangulated neighbours and prunes off neighbour relationships represented by unusually long edges, especially around the convex hull, but may render the output object asymmetric. Other graph-based approaches include relativeneigh() and gabrielneigh(). args(soi.graph) #&gt; function (tri.nb, coords, quadsegs = 10) #&gt; NULL The output of these functions is then converted to the nb representation using graph2nb(), with the possible use of the sym= argument to coerce to symmetry. args(graph2nb) #&gt; function (gob, row.names = NULL, sym = FALSE) #&gt; NULL We take the centroids of the largest component polygon for each observation as the point representation; population-weighted centroids might have been a better choice if they were available: coords &lt;- st_centroid(st_geometry(pol_pres15), of_largest_polygon=TRUE) suppressMessages(nb_tri &lt;- tri2nb(coords)) nb_tri #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 14930 #&gt; Percentage nonzero weights: 0.24 #&gt; Average number of links: 5.98 The average number of neighbours is similar to the Queen boundary contiguity case, but if we look at the distribution of edge lengths using nbdists(), we can see that although the upper quartile is about 15 km, the maximum is almost 300 km, an edge along much of one side of the convex hull. The short minimum distance is also of interest, as many centroids of urban municipalities are very close to the centroids of their surrounding rural counterparts. summary(unlist(nbdists(nb_tri, coords))) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 247 9847 12151 13485 14994 296974 Using the card() function to return a vector of neighbour counts by observation, we see that there are relatively many such surrounded urban municipalities with only one neighbour. table(pol_pres15$types, card(nb_q)) #&gt; #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 #&gt; Rural 0 5 41 183 413 465 271 105 55 16 8 0 1 #&gt; Urban 70 58 55 34 22 25 15 13 6 0 3 1 1 #&gt; Urban/rural 2 2 15 36 109 173 162 80 23 8 1 0 0 #&gt; Warsaw Borough 0 0 0 2 3 6 4 3 0 0 0 0 0 For obvious reasons, triangulated units seldom have few neighbours, not only because they are located on the convex hull: table(pol_pres15$types, card(nb_tri)) #&gt; #&gt; 3 4 5 6 7 8 9 10 11 #&gt; Rural 2 57 455 632 328 75 12 2 0 #&gt; Urban 1 41 118 93 33 11 5 1 0 #&gt; Urban/rural 0 22 116 251 158 52 10 0 2 #&gt; Warsaw Borough 0 1 5 6 5 1 0 0 0 Triangulated neighbours also yield a connected graph: n.comp.nb(nb_tri)$nc #&gt; [1] 1 The sphere of influence graph trims a neighbour object such as nb_tri to remove edges that seem long in relation to typical neighbours (Avis and Horton 1985). nb_soi &lt;- graph2nb(soi.graph(nb_tri, coords)) nb_soi #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 12792 #&gt; Percentage nonzero weights: 0.205 #&gt; Average number of links: 5.13 Unpicking the triangulated neighbours does however remove the connected character of the underlying graph: n_comp &lt;- n.comp.nb(nb_soi) n_comp$nc #&gt; [1] 16 The SoI algorithm has stripped out longer edges leading to urban and rural municpalities where their centroids are very close to each other, giving 15 pairs of neighours unconnected to the main graph: table(n_comp$comp.id) #&gt; #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #&gt; 2465 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; 16 #&gt; 2 The largest length edges along the convex hull have been removed, but “holes” have appeared where the unconnected pairs of neighbours have appeared. The differences between nb_tri and nb_soi are shown in orange in the figure. summary(unlist(nbdists(nb_soi, coords))) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 247 9507 11651 11880 14142 30005 opar &lt;- par(mar=c(0,0,0,0)+0.5) plot(st_geometry(pol_pres15), border=&quot;grey&quot;, lwd=0.5) plot(nb_soi, coords=st_coordinates(coords), add=TRUE, points=FALSE, lwd=0.5) plot(diffnb(nb_tri, nb_soi), coords=st_coordinates(coords), col=&quot;orange&quot;, add=TRUE, points=FALSE, lwd=0.5) par(opar) Figure 17.2: Triangulated and sphere of influence neighbours 17.2.3 Distance-based neighbours Distance-based neighbours can be constructed using dnearneigh(), with a distance band with lower d1= and upper d2= bounds controlled by the bounds= argument. If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid. args(dnearneigh) #&gt; function (x, d1, d2, row.names = NULL, longlat = NULL, bounds = c(&quot;GT&quot;, #&gt; &quot;LE&quot;)) #&gt; NULL The knearneigh() function for \\(k\\)-nearest neighbours returns a knn object, converted to an nb object using knn2nb(). It can also use great circle distances, not least because nearest neighbours may differ when uprojected coordinates are treated as planar. k= should be a small number. For projected coordinates, the RANN package is used to compute nearest neighbours more efficiently. Note that nb objects constructed in this way are most unlikely to be symmetric, hence knn2nb() has a sym= argument to permit the imposition of symmetry, which will mean that all units have at least k= neighbours, not that all units will have exactly k= neighbours. args(knearneigh) #&gt; function (x, k = 1, longlat = NULL, RANN = TRUE) #&gt; NULL args(knn2nb) #&gt; function (knn, row.names = NULL, sym = FALSE) #&gt; NULL The nbdists() function returns the length of neighbour relationship edges in the units of the coordinates if the coordinates are projected, in km otherwise. args(nbdists) #&gt; function (nb, coords, longlat = NULL) #&gt; NULL In order to set the upper limit for distance bands, one may first find the maximum first nearest neighbour distance, using unlist() to remove the list structure of the returned object. k1 &lt;- knn2nb(knearneigh(coords)) k1dists &lt;- unlist(nbdists(k1, coords)) summary(k1dists) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 247 6663 8538 8275 10124 17979 Here the largest first nearest neighbour distance is just under 18 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour: nb_d18 &lt;- dnearneigh(coords, 0, 18000) nb_d18 #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 20358 #&gt; Percentage nonzero weights: 0.327 #&gt; Average number of links: 8.16 However, even though there are no no-neighbour observations (their presence is reported by the print method for nb objects), the graph is not connected, as a pair of observations are each others’ only neighbours. n_comp &lt;- n.comp.nb(nb_d18) n_comp$nc #&gt; [1] 2 table(n_comp$comp.id) #&gt; #&gt; 1 2 #&gt; 2493 2 Adding 300 m to the threshold gives us a neighbour object with no no-neighbour units, and all units can be reached from all others across the graph. nb_d183 &lt;- dnearneigh(coords, 0, 18300) nb_d183 #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 21086 #&gt; Percentage nonzero weights: 0.339 #&gt; Average number of links: 8.45 n_comp &lt;- n.comp.nb(nb_d183) n_comp$nc #&gt; [1] 1 One characteristic of distance-based neighbours is that more densely settled areas, with units which are smaller in terms of area (Warsaw boroughs are much smaller on average, but have almost 30 neighbours). Having many neighbours smoothes the neighbour relationship across more neighbours: table(pol_pres15$types, card(nb_d183)) #&gt; #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #&gt; Rural 5 18 51 87 117 156 193 227 222 166 114 62 43 29 #&gt; Urban 3 6 9 12 28 27 29 21 35 30 20 12 17 11 #&gt; Urban/rural 10 30 28 47 55 62 94 89 60 45 35 10 15 7 #&gt; Warsaw Borough 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; #&gt; 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #&gt; Rural 21 12 13 9 7 7 0 1 0 1 2 0 0 0 #&gt; Urban 5 3 8 5 12 5 1 0 0 2 0 1 1 0 #&gt; Urban/rural 6 3 7 3 1 1 1 0 2 0 0 0 0 0 #&gt; Warsaw Borough 0 0 0 0 0 0 0 0 0 1 2 2 5 3 #&gt; #&gt; 29 30 31 #&gt; Rural 0 0 0 #&gt; Urban 0 0 0 #&gt; Urban/rural 0 0 0 #&gt; Warsaw Borough 1 2 2 arha &lt;- units::set_units(st_area(pol_pres15), hectare) aggregate(arha, list(pol_pres15$types), mean) #&gt; Group.1 x #&gt; 1 Rural 12500 [] #&gt; 2 Urban 4497 [] #&gt; 3 Urban/rural 16850 [] #&gt; 4 Warsaw Borough 2886 [] For use later, we also construct a neighbour object with no-neighbour units, using a threshold of 16 km: nb_d16 &lt;- dnearneigh(coords, 0, 16000) nb_d16 #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 15850 #&gt; Percentage nonzero weights: 0.255 #&gt; Average number of links: 6.35 #&gt; 7 regions with no links: #&gt; 569 1371 1522 2374 2385 2473 2474 It is possible to control the numbers of neighbours directly using \\(k\\)-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry: knn_k6 &lt;- knearneigh(coords, k=6) knn2nb(knn_k6) #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 14970 #&gt; Percentage nonzero weights: 0.24 #&gt; Average number of links: 6 #&gt; Non-symmetric neighbours list nb_k6s &lt;- knn2nb(knn_k6, sym=TRUE) nb_k6s #&gt; Neighbour list object: #&gt; Number of regions: 2495 #&gt; Number of nonzero links: 16810 #&gt; Percentage nonzero weights: 0.27 #&gt; Average number of links: 6.74 Here the size of k= is sufficient to ensure connectedness, although the graph is not planar as edges cross at locations other than nodes, which is not the case for contiguous or graph-based neighbours. n_comp &lt;- n.comp.nb(nb_k6s) n_comp$nc #&gt; [1] 1 17.2.4 Weights specification Once neighbour objects are available, further choices need to made in specifying the weights objects. The nb2listw() function is used to create a listw weights object with an nb object, a matching list of weights vectors, and a style specification. Because handling no-neighbour observations now begins to matter, the zero.policy= argument is introduced. By default, this is FALSE, indicating that no-neighbour observations will cause an error, as the spatially lagged value for an observation with no neighbours is not available. By convention, zero is substituted for the lagged value, as the cross product of a vector of zero-valued weights and a data vector, hence the name of zero.policy. args(nb2listw) #&gt; function (neighbours, glist = NULL, style = &quot;W&quot;, zero.policy = NULL) #&gt; NULL We will be using the helper function spweights.constants() below to show some consequences of varing style choices. It returns constants for a listw object, \\(n\\) is the number of observations, n1 to n3 are \\(n-1, \\ldots\\), nn is \\(n^2\\) and \\(S_0\\), \\(S_1\\) and \\(S_2\\) are constants, \\(S_0\\) being the sum of the weights. There is a full discussion of the constants in Bivand and Wong (2018). args(spweights.constants) #&gt; function (listw, zero.policy = NULL, adjust.n = TRUE) #&gt; NULL The &quot;B&quot; binary style gives a weight of unity to each neighbour relationship, and typically upweights units with no boundaries on the edge of the study area. lw_q_B &lt;- nb2listw(nb_q, style=&quot;B&quot;) unlist(spweights.constants(lw_q_B)) #&gt; n n1 n2 n3 nn S0 S1 S2 #&gt; 2495 2494 2493 2492 6225025 14242 28484 357280 The &quot;W&quot; row-standardized style upweights units around the edge of the study area that necessarily have fewer neighbours. This style first gives a weight of unity to each neighbour relationship, then divides these weights by the per unit sums of weights. Naturally this leads to division by zero where there are no neighbours, a not-a-number result, unless the chosen policy is to permit no-neighbour observations. We can see that \\(S_0\\) is now equal to \\(n\\). lw_q_W &lt;- nb2listw(nb_q, style=&quot;W&quot;) unlist(spweights.constants(lw_q_W))[c(1,6:8)] #&gt; n S0 S1 S2 #&gt; 2495 2495 958 10406 An &quot;S&quot; style attempts to balance the tendencies of the &quot;B&quot; and &quot;W&quot; styles to downweight or upweight units on the edge of the study area (Tiefelsdorf, Griffith, and Boots 1999). Other styles are variants of &quot;B&quot;, &quot;C&quot; sets the weights such that they sum (\\(S_0\\)) to \\(n\\), and &quot;U&quot; to unity. The main change in the &quot;S&quot; style is to \\(S_1\\) for this configuration of contiguities. lw_q_S &lt;- nb2listw(nb_q, style=&quot;S&quot;) unlist(spweights.constants(lw_q_S))[c(1,6:8)] #&gt; n S0 S1 S2 #&gt; 2495 2495 886 10646 Inverse distance weights are used in a number of scientific fields. Some use dense inverse distance matrices, but many of the inverse distances are close to zero, so have little practical contribution, especially as the spatial process matrix is itself dense. Inverse distance weights may be constructed by taking the lengths of edges, changing units to avoid most weights being too large or small (here from m to km), taking the inverse, and passing through the glist= argument to nb2listw(): gwts &lt;- lapply(nbdists(nb_d183, coords), function(x) 1/(x/1000)) lw_d183_idw_B &lt;- nb2listw(nb_d183, glist=gwts, style=&quot;B&quot;) unlist(spweights.constants(lw_d183_idw_B))[c(1,6:8)] #&gt; n S0 S1 S2 #&gt; 2495 1841 534 7265 No-neighbour handling is by default to prevent the construction of a weights object, making the analyst take a position on how to proceed. try(lw_d16_B &lt;- nb2listw(nb_d16, style=&quot;B&quot;)) #&gt; Error in nb2listw(nb_d16, style = &quot;B&quot;) : Empty neighbour sets found Use can be made of the zero.policy= argument to many functions used with nb and listw objects. lw_d16_B &lt;- nb2listw(nb_d16, style=&quot;B&quot;, zero.policy=TRUE) unlist(spweights.constants(lw_d16_B, zero.policy=TRUE))[c(1,6:8)] #&gt; n S0 S1 S2 #&gt; 2488 15850 31700 506480 It is also possible to store the chosen zero policy for the running session using set.ZeroPolicyOption(); the function returns the value it held before being set. If the zero.policy= argument takes its default value of NULL, the stored option value is used, initialized to FALSE at the beginning of the session. zO &lt;- set.ZeroPolicyOption(TRUE) lw_d16_B &lt;- nb2listw(nb_d16, style=&quot;B&quot;) unlist(spweights.constants(lw_d16_B))[c(1,6:8)] #&gt; n S0 S1 S2 #&gt; 2488 15850 31700 506480 invisible(set.ZeroPolicyOption(zO)) Note that by default the adjust.n= argument is set by default to TRUE, subtracting the count of no-neighbour observations from the observation count, so \\(n\\) is smaller with possible consequences for inference. The complete count can be retrieved by changing the argument. unlist(spweights.constants(lw_d16_B, zero.policy=TRUE, adjust.n=FALSE))[c(1,6:8)] #&gt; n S0 S1 S2 #&gt; 2495 15850 31700 506480 17.3 Measures of spatial autocorrelation Measures of spatial autcorrelation unfortunately pick up other mis-specifications in the way that we model data (Waller and Gotway 2004; McMillen 2003). First we test a random variable using the Moran test, here under the normality assumption (argument randomisation=FALSE, default TRUE): set.seed(1) x &lt;- rnorm(nrow(pol_pres15)) moran.test(x, lw_q_B, randomisation=FALSE)$estimate #&gt; Moran I statistic Expectation Variance #&gt; -0.004772 -0.000401 0.000140 It however fails to detect a missing trend in the data as a missing variable problem, finding spatial autocorrelation instead: beta &lt;- 0.5e-02 t &lt;- st_coordinates(coords)[,1]/1000 x_t &lt;- x + beta*t moran.test(x_t, lw_q_B, randomisation=FALSE)$estimate #&gt; Moran I statistic Expectation Variance #&gt; 0.355771 -0.000401 0.000140 If we test the residuals of a linear model including the trend, the apparent spatial autocorrelation disappears: lm.morantest(lm(x_t ~ t), lw_q_B)$estimate #&gt; Observed Moran I Expectation Variance #&gt; -0.004777 -0.000789 0.000140 A comparison of implementations of measures of spatial autocorrelation shows that a wide range of measures is available in R in a number of packages, chiefly in the spdep package, and that differences from other implementations can be attributed to design decisions (Bivand and Wong 2018). The spdep package also includes the only implementations of exact and Saddlepoint approximations to global and local Moran’s I for regression residuals (Tiefelsdorf 2002; Bivand, Müller, and Reder 2009). 17.3.1 Global measures We will begin by examining join count statistics, where joincount.test() takes a factor vector of values fx= and a listw object, and returns a list of htest (hypothesis test) objects defined in the stats package, one htest object for each level of the fx= argument. The observed counts are of neighbours with the same factor levels, known as same-colour joins. args(joincount.test) #&gt; function (fx, listw, zero.policy = NULL, alternative = &quot;greater&quot;, #&gt; sampling = &quot;nonfree&quot;, spChk = NULL, adjust.n = TRUE) #&gt; NULL The function takes an alternative= argument for hypothesis testing, a sampling= argument showing the basis for the construction of the variance of the measure, where the default &quot;nonfree&quot; choice corresponds to analytical permutation; the spChk= argument is retained for backward compatibility. For reference, the counts of factor levels for the type of municipality or Warsaw borough are: table(pol_pres15$types) #&gt; #&gt; Rural Urban Urban/rural Warsaw Borough #&gt; 1563 303 611 18 Since there are four levels, we re-arrange the list of htest objects to give a matrix of estimated results. The observed same-colour join counts are tabulated with their expectations based on the counts of levels of the input factor, so that few joins would be expected between for example Warsaw Boroughs, because there are very few of them. The variance calculation uses the underlying constants of the chosen listw object and the counts of levels of the input factor. The z-value is obtained in the usual way by dividing the difference between the observed and expected join counts by the square root of the variance. The global tests in spdep return htest objects with a print() method in the stats package. To save space here, we’ll use a glance function if the broom::tidy() method has not been updated to use estimate names. glance_htest &lt;- function(ht) c(ht$estimate, &quot;Std deviate&quot;=unname(ht$statistic)) jcl &lt;- joincount.test(pol_pres15$types, listw=lw_q_B) broom_ok &lt;- FALSE if (names(broom::tidy(jcl[[1]]))[1] == &quot;Same colour statistic&quot;) broom_ok &lt;- TRUE if (broom_ok) { nm &lt;- tibble::enframe(sapply(jcl, function(t) { nm &lt;- substring(names(t$statistic), 18) paste0(nm, &quot;:&quot;, nm) })) mat &lt;- cbind(nm, do.call(&quot;rbind&quot;, (lapply(jcl, broom::tidy)))) names(mat)[3] &lt;- &quot;Joincount&quot; names(mat)[6] &lt;- &quot;Std.deviate&quot; names(mat)[2] &lt;- &quot;&quot; mat[,2:6] } else { mat &lt;- t(sapply(jcl, glance_htest)) colnames(mat)[1] &lt;- &quot;Joincount&quot; rownames(mat) &lt;- sapply(jcl, function(t) { nm &lt;- substring(names(t$statistic), 18) paste0(nm, &quot;:&quot;, nm) }) mat } #&gt; Joincount Expectation Variance Std.deviate #&gt; 1 Rural:Rural 3087 2793.92 1126.534 8.732 #&gt; 2 Urban:Urban 110 104.72 93.299 0.547 #&gt; 3 Urban/rural:Urban/rural 656 426.53 331.759 12.599 #&gt; 4 Warsaw Borough:Warsaw Borough 41 0.35 0.347 68.965 The join count test was subsequently adapted for multi-colour join counts (Upton and Fingleton 1985). The implementation as joincount.mult() in spdep returns a table based on nonfree sampling, and does not report p-values. args(joincount.multi) #&gt; function (fx, listw, zero.policy = FALSE, spChk = NULL, adjust.n = TRUE) #&gt; NULL The first four lines of results for same-colour join counts are the same as those from jointcount.test() above, also under nonfree sampling. The remaining lines report results for multi-colour join counts on the same basis, and finally the “Jtot” statistic summarising the totality of join counts for the variable and listw object chosen. joincount.multi(pol_pres15$types, listw=lw_q_B) #&gt; Joincount Expected Variance z-value #&gt; Rural:Rural 3087.000 2793.920 1126.534 8.73 #&gt; Urban:Urban 110.000 104.719 93.299 0.55 #&gt; Urban/rural:Urban/rural 656.000 426.526 331.759 12.60 #&gt; Warsaw Borough:Warsaw Borough 41.000 0.350 0.347 68.96 #&gt; Urban:Rural 668.000 1083.941 708.209 -15.63 #&gt; Urban/rural:Rural 2359.000 2185.769 1267.131 4.87 #&gt; Urban/rural:Urban 171.000 423.729 352.190 -13.47 #&gt; Warsaw Borough:Rural 12.000 64.393 46.460 -7.69 #&gt; Warsaw Borough:Urban 9.000 12.483 11.758 -1.02 #&gt; Warsaw Borough:Urban/rural 8.000 25.172 22.354 -3.63 #&gt; Jtot 3227.000 3795.486 1496.398 -14.70 So far, we have used binary weights, so the sum of join counts multiplied by the weight on that join remains integer. If we change to row standardised weights, where the weights are not unity in all cases, the counts, expectations and variances change, but there are few major changes in the z-values. joincount.multi(pol_pres15$types, listw=lw_q_W) #&gt; Joincount Expected Variance z-value #&gt; Rural:Rural 521.6476 489.4559 22.8856 6.73 #&gt; Urban:Urban 20.9023 18.3452 2.8822 1.51 #&gt; Urban/rural:Urban/rural 106.1765 74.7213 9.3498 10.29 #&gt; Warsaw Borough:Warsaw Borough 6.7363 0.0613 0.0116 61.89 #&gt; Urban:Rural 165.2283 189.8913 18.2987 -5.77 #&gt; Urban/rural:Rural 389.6002 382.9162 36.1501 1.11 #&gt; Urban/rural:Urban 32.5048 74.2314 10.6416 -12.79 #&gt; Warsaw Borough:Rural 1.8554 11.2807 1.1075 -8.96 #&gt; Warsaw Borough:Urban 1.6171 2.1868 0.3775 -0.93 #&gt; Warsaw Borough:Urban/rural 1.2315 4.4098 0.6810 -3.85 #&gt; Jtot 592.0373 664.9162 43.1245 -11.10 Using an inverse distance based listw object does, however, change the z-values markedly, because closer centroids are upweighted relatively strongly: joincount.multi(pol_pres15$types, listw=lw_d183_idw_B) #&gt; Joincount Expected Variance z-value #&gt; Rural:Rural 3.46e+02 3.61e+02 4.93e+01 -2.10 #&gt; Urban:Urban 2.90e+01 1.35e+01 2.23e+00 10.39 #&gt; Urban/rural:Urban/rural 4.65e+01 5.51e+01 9.61e+00 -2.79 #&gt; Warsaw Borough:Warsaw Borough 1.68e+01 4.53e-02 6.61e-03 206.38 #&gt; Urban:Rural 2.02e+02 1.40e+02 2.36e+01 12.73 #&gt; Urban/rural:Rural 2.25e+02 2.83e+02 3.59e+01 -9.59 #&gt; Urban/rural:Urban 3.65e+01 5.48e+01 8.86e+00 -6.14 #&gt; Warsaw Borough:Rural 5.65e+00 8.33e+00 1.73e+00 -2.04 #&gt; Warsaw Borough:Urban 9.18e+00 1.61e+00 2.54e-01 15.01 #&gt; Warsaw Borough:Urban/rural 3.27e+00 3.25e+00 5.52e-01 0.02 #&gt; Jtot 4.82e+02 4.91e+02 4.16e+01 -1.38 The implementation of Moran’s \\(I\\) in spdep in the moran.test() function has similar arguments to those of joincount.test(), but sampling= is replaced by randomisation= to indicate the underlying analytical approach used for calculating the variance of the measure. It is also possible to use ranks rather than numerical values (Cliff and Ord 1981, 46). The drop.EI2= agrument may be used to reproduce results where the final component of the variance term is omitted. args(moran.test) #&gt; function (x, listw, randomisation = TRUE, zero.policy = NULL, #&gt; alternative = &quot;greater&quot;, rank = FALSE, na.action = na.fail, #&gt; spChk = NULL, adjust.n = TRUE, drop.EI2 = FALSE) #&gt; NULL The default for the randomisation= argument is TRUE, but here we will simply show that the test under normality is the same as a test of least squares residuals with only the intercept used in the mean model. The spelling of randomisation is that of Cliff and Ord (1973). mt &lt;- moran.test(pol_pres15$I_turnout, listw=lw_q_B, randomisation=FALSE) if (broom_ok) broom::tidy(mt)[,1:4] else glance_htest(mt) #&gt; # A tibble: 1 x 4 #&gt; `Moran I statistic` Expectation Variance statistic #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.691 -0.000401 0.000140 58.5 The lm.morantest() function also takes a resfun= argument to set the function used to extract the residuals used for testing, and clearly lets us model other salient features of the response variable (Cliff and Ord 1981, 203). args(lm.morantest) #&gt; function (model, listw, zero.policy = NULL, alternative = &quot;greater&quot;, #&gt; spChk = NULL, resfun = weighted.residuals, naSubset = TRUE) #&gt; NULL To compare with the standard test, we are only using the intercept here, and as can be seen, the results are the same. ols &lt;- lm(I_turnout ~ 1, pol_pres15) lmt &lt;- lm.morantest(ols, listw=lw_q_B) if (broom_ok) broom::tidy(lmt)[,1:4] else glance_htest(lmt) #&gt; # A tibble: 1 x 4 #&gt; `Observed Moran I` Expectation Variance statistic[,1] #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.691 -0.000401 0.000140 58.5 Following the elaboration of the global Moran’s I test for least squares residuals, further work was done to develop an exact test (Tiefelsdorf and Boots 1995, 1997; Hepple 1998). The lm.morantest.sad() function implements a Saddlepoint approximation, and lm.morantest.exact() the exact test, using dense matrix calculations unsuitable for large \\(n\\) (Tiefelsdorf 2002; Bivand, Müller, and Reder 2009). The additional arguments are used in the computation of the exact standard deviate. args(lm.morantest.exact) #&gt; function (model, listw, zero.policy = NULL, alternative = &quot;greater&quot;, #&gt; spChk = NULL, resfun = weighted.residuals, zero.tol = 1e-07, #&gt; Omega = NULL, save.M = NULL, save.U = NULL, useTP = FALSE, #&gt; truncErr = 1e-06, zeroTreat = 0.1) #&gt; NULL We can easily see that the exact standard deviate is an order of magnitude smaller for this response, mean model and spatial weights specification, compared to the standard deviate based on the variance calculated using the normality assumption. suppressWarnings(lmte &lt;- lm.morantest.exact(ols, listw=lw_q_B)) names(lmte$estimate) &lt;- &quot;Moran I statistic&quot; class(lmte) &lt;- c(class(lmte), &quot;htest&quot;) if (broom_ok) broom::tidy(lmte)[,1:2] else glance_htest(lmte) #&gt; # A tibble: 1 x 2 #&gt; estimate statistic #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.691 5.83 The only difference between tests under normality and randomisation is that an extra term is added if the kurtosis of the variable of interest indicates a flatter or more peaked distribution, where the measure used is the classical measure of kurtosis. all.equal(3+e1071::kurtosis(pol_pres15$I_turnout, type=1), moran(pol_pres15$I_turnout, listw=lw_q_B, n=nrow(pol_pres15), S0=Szero(lw_q_B))$K) #&gt; [1] TRUE Under the default randomisation assumption of analytical randomisation, the results are largely unchanged. mtr &lt;- moran.test(pol_pres15$I_turnout, listw=lw_q_B) if (broom_ok) broom::tidy(mtr)[,1:4] else glance_htest(mtr) #&gt; # A tibble: 1 x 4 #&gt; `Moran I statistic` Expectation Variance statistic #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.691 -0.000401 0.000140 58.5 Of course, from the very beginning, interest was shown in Monte Carlo testing, also known as a Hope-type test and as a permutation bootstrap. By default, moran.mc() retrurns a &quot;htest&quot; object, but may simply use boot::boot() internally and return a &quot;boot&quot; object when return_boot=TRUE. args(moran.mc) #&gt; function (x, listw, nsim, zero.policy = NULL, alternative = &quot;greater&quot;, #&gt; na.action = na.fail, spChk = NULL, return_boot = FALSE, adjust.n = TRUE) #&gt; NULL In addition the number of simulations of the variable of interest by permutation, that is shuffling the values across the observations at random, needs to be given as nsim=. set.seed(1) mmc &lt;- moran.mc(pol_pres15$I_turnout, listw=lw_q_B, nsim=999, return_boot = TRUE) The bootstrap permutation retains the outcomes of each of the random permutations, reporting the observed value of the statistic, here Moran’s \\(I\\), the difference between this value and the mean of the simulations under randomisation (equivalent to \\(E(I)\\)), and the standard deviation of the simulations under randomisation. glance_boot &lt;- function(bt) c(original=bt$t0, bias=mean(bt$t)-bt$t0, std.error=sd(bt$t), zvalue=(bt$t0-mean(bt$t))/sd(bt$t)) if (broom_ok) broom::tidy(mmc) else glance_boot(mmc) #&gt; # A tibble: 1 x 3 #&gt; statistic bias std.error #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.691 -0.692 0.0118 If we compare the Monte Carlo and analytical variances of \\(I\\) under randomisation, we typically see few differences, arguably rendering Monte Carlo testing unnecessary. c(&quot;Permutation bootstrap&quot;=var(mmc$t), &quot;Analytical randomisation&quot;=unname(mtr$estimate[3])) #&gt; Permutation bootstrap Analytical randomisation #&gt; 0.000138 0.000140 There is also a permutation bootstrap approach to the approximate profile likelihood estimator (APLE) measure (Li, Calder, and Cressie 2007, 2012) using row-standardised weights, in which the variable of interest must be centred on zero first: apmc &lt;- aple.mc(c(scale(pol_pres15$I_turnout, scale=FALSE)), listw=lw_q_W, nsim=999) if (broom_ok) broom::tidy(apmc) else glance_boot(apmc) #&gt; # A tibble: 1 x 3 #&gt; statistic bias std.error #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.785 -0.786 0.0324 Geary’s global \\(C\\) is implemented in geary.test() largely following the same argument structure as moran.test(). args(geary.test) #&gt; function (x, listw, randomisation = TRUE, zero.policy = NULL, #&gt; alternative = &quot;greater&quot;, spChk = NULL, adjust.n = TRUE) #&gt; NULL Because \\(C\\) is based on the similarity of neighbouring values, small values of \\(C\\) indicate small differences, here much smaller than the expected standardised difference of unity. gt &lt;- geary.test(pol_pres15$I_turnout, listw=lw_q_B) if (broom_ok) broom::tidy(gt)[,1:4] else glance_htest(gt) #&gt; # A tibble: 1 x 4 #&gt; `Geary C statistic` Expectation Variance statistic #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.304 1 0.000214 47.6 The Getis-Ord \\(G\\) test includes extra arguments to accommodate differences between implementations, as Bivand and Wong (2018) found multiple divergences from the original definitions, often to omit no-neighbour observations generated when using distance band neighbours. args(globalG.test) #&gt; function (x, listw, zero.policy = NULL, alternative = &quot;greater&quot;, #&gt; spChk = NULL, adjust.n = TRUE, B1correct = TRUE, adjust.x = TRUE, #&gt; Arc_all_x = FALSE) #&gt; NULL With contiguity neighbours, global \\(G\\) yields a much smaller standard deviate than when using a 16 km distance band neighbour definition: ggt &lt;- globalG.test(pol_pres15$I_turnout, listw=lw_q_B) if (broom_ok) broom::tidy(ggt)[,1:4] else glance_htest(ggt) #&gt; # A tibble: 1 x 4 #&gt; `Global G statistic` Expectation Variance statistic[,1] #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.00231 0.00229 1.73e-11 5.08 Because this neighbour definition leaves a few observations without neighbours, we need to use the zero.policy= argument. ggt &lt;- globalG.test(pol_pres15$I_turnout, listw=lw_d16_B, zero.policy=TRUE) if (broom_ok) broom::tidy(ggt)[,1:4] else glance_htest(ggt) #&gt; # A tibble: 1 x 4 #&gt; `Global G statistic` Expectation Variance statistic[,1] #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.00279 0.00256 5.51e-11 30.5 The Mantel test is implemented without its analytical variance as sp.mantel.mc(), rather using permutation bootstrap like moran.mc(). It takes a type= argument, which can be set to &quot;moran&quot;, &quot;geary&quot; or &quot;sokal&quot;. The output is scaled differently, but gives similar inferences. set.seed(1) mamc &lt;- sp.mantel.mc(pol_pres15$I_turnout, listw=lw_q_B, nsim=999, type=&quot;moran&quot;, return_boot = TRUE) if (broom_ok) broom::tidy(mamc) else glance_boot(mamc) #&gt; # A tibble: 1 x 3 #&gt; statistic bias std.error #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 9843. -9849. 167. Finally, the empirical Bayes Moran’s \\(I\\) takes account of the denominator in assessing spatial autocorrelation in rates data (Assunção and Reis 1999). Until now, we have considered the proportion of valid votes cast in relation to the numbers entitled to vote by spatial entity, but using EBImoran.mc() we can try to accommodate uncertainty in extreme rates in entities with small numbers entitled to vote. There is, however, little impact on the outcome in this case. set.seed(1) suppressMessages(ebimc &lt;- EBImoran.mc(n=pol_pres15$I_valid_votes, x=pol_pres15$I_entitled_to_vote, listw=lw_q_B, nsim=999, return_boot=TRUE)) if (broom_ok) broom::tidy(ebimc) else glance_boot(ebimc) #&gt; # A tibble: 1 x 3 #&gt; statistic bias std.error #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.693 -0.694 0.0118 A similar measure may also be achieved using global empirical Bayes estimators with EBest() to calculate a numerical vector of empirical Bayes estimates, but both are only limited ways of handling mis-specification in the mean model. Global measures of spatial autocorrelation using spatial weights objects based on graphs of neighbours are, as we have seen, rather blunt tools, which for interpretation depend critically on a reasoned mean model of the variable in question. If the mean model is just the intercept, the global measures will respond to all kinds of mis-specification, not only spatial autocorrelation. A key source of mis-specification will typically also include the choice of entities for aggregation of data. 17.3.2 Local measures Building on insights from the weaknesses of global measures, local indicators of spatial association began to appear in the first half of the 1990s (Anselin, n.d.; Getis and Ord 1992, 1996). In addition, the Moran plot was introduced, plotting the values of the variable of interest against their spatially lagged values, typically using row-standardised weights to make the axes more directly comparable (Anselin 1996). The moran.plot() function also returns an influence measures object used to label observations exerting more than propotional influence on the slope of the line representing global Moran’s \\(I\\). In this case, we can see that there are many spatial entities exerting such influence. These pairs of observed and lagged observed values make up in aggregate the global measure, but can also be explored in detail. The quadrants of the Moran plot also show low-low pairs in the lower left quadrant, high-high in the upper right quadrant, and fewer low-high and high-low pairs in the upper left and lower right quadrants. infl_W &lt;- moran.plot(pol_pres15$I_turnout, listw=lw_q_W, labels=pol_pres15$TERYT, cex=1, pch=&quot;.&quot;, xlab=&quot;I round turnout&quot;, ylab=&quot;lagged turnout&quot;) (#fig:moran_plot)Moran plot of I round turnout, row standardised weights If we extract the hat value influence measure from the returned object, a map suggests that some edge entities exert more than proportional influence, as do entities in or near larger urban areas. pol_pres15$hat_value &lt;- infl_W$infmat[,6] tm_shape(pol_pres15) + tm_fill(&quot;hat_value&quot;) (#fig:moran_hat)Moran plot hat values, row standardised neighbours Bivand and Wong (2018) discuss issues impacting the use of local indicators, such as local Moran’s \\(I\\) and local Getis-Ord \\(G\\). Some issues affect the calculation of the local indicators, others inference from their values. Because \\(n\\) statistics may be being calculated from the same number of observations, there are multiple comparison problems that need to be addressed. Although the apparent detection of hotspots from values of local indicators has been quite widely adopted, it remains fraught with difficulty because adjustment of the inferential basis to accommodate multiple comparisons is not often chosen, and as in the global case, mis-specification also remains a source of confusion. Further, interpreting local spatial autocorrelation in the presence of global spatial autocorrelation is challenging (Ord and Getis 2001; Tiefelsdorf 2002; Bivand, Müller, and Reder 2009). The mlvar= and adjust.x= arguments to localmoran() are discussed in Bivand and Wong (2018), and permit matching with other implementations. The p.adjust.method= argument uses an untested speculation that adjustment should only take into account the cardinality of the neighbour set of each observation when adjusting for multiple comparisons; using stats::p.adjust() is preferable. args(localmoran) #&gt; function (x, listw, zero.policy = NULL, na.action = na.fail, #&gt; alternative = &quot;greater&quot;, p.adjust.method = &quot;none&quot;, mlvar = TRUE, #&gt; spChk = NULL, adjust.x = FALSE) #&gt; NULL Taking &quot;two.sided&quot; p-values because these local indicators when summed and divided by the sum of the spatial weights, and thus positive and negative local spatial autocorrelation may be present, we obtain: locm &lt;- localmoran(pol_pres15$I_turnout, listw=lw_q_B, alternative=&quot;two.sided&quot;) all.equal(sum(locm[,1])/Szero(lw_q_B), unname(moran.test(pol_pres15$I_turnout, lw_q_B)$estimate[1])) #&gt; [1] TRUE Using stats::p.adjust() to adjust for multiple comparisons, we see that almost 29% of the local measures have p-values of less than \\(0.05\\) if no adjustment is applied, but only 12% using Bonferroni correction. pvs &lt;- cbind(locm[,5], p.adjust(locm[,5], &quot;bonferroni&quot;), p.adjust(locm[,5],&quot;fdr&quot;), p.adjust(locm[,5], &quot;BY&quot;)) colnames(pvs) &lt;- c(&quot;none&quot;, &quot;bonferroni&quot;, &quot;fdr&quot;, &quot;BY&quot;) apply(pvs, 2, function(x) sum(x &lt; 0.05)) #&gt; none bonferroni fdr BY #&gt; 715 297 576 424 The localmoran.sad() and localmoran.exact() functions take a fitted linear model, a select= argument to specify which observations to test (choosing only one removes the need to adjust for multiple comparisons), arguments like nb2listw() to build single observation star graphs of neighbours and their weights, and arguments needed for numerical estimation internally. They return lists of objects like &quot;htest&quot; objects, which may be coerced to data.frame objects. args(localmoran.sad) #&gt; function (model, select, nb, glist = NULL, style = &quot;W&quot;, zero.policy = NULL, #&gt; alternative = &quot;greater&quot;, spChk = NULL, resfun = weighted.residuals, #&gt; save.Vi = FALSE, tol = .Machine$double.eps^0.5, maxiter = 1000, #&gt; tol.bounds = 1e-04, save.M = FALSE, Omega = NULL) #&gt; NULL If we use localmoran.sad() to make saddlepoint approximations of the standard deviates of the local measures, and make the same corrections, we drop from 26% of the p-values under \\(0.05\\) with no correction to under 2% using Bonferroni correction: locms &lt;- localmoran.sad(ols, nb=nb_q, style=&quot;B&quot;, alternative=&quot;two.sided&quot;) locms &lt;- as.data.frame(locms) pvss &lt;- cbind(locms[,5], p.adjust(locms[,5], &quot;bonferroni&quot;), p.adjust(locms[,5], &quot;fdr&quot;), p.adjust(locms[,5], &quot;BY&quot;)) colnames(pvss) &lt;- c(&quot;none&quot;, &quot;bonferroni&quot;, &quot;fdr&quot;, &quot;BY&quot;) apply(pvss, 2, function(x) sum(x &lt; 0.05)) #&gt; none bonferroni fdr BY #&gt; 646 44 314 87 Should we think it appropriate to take possible global spatial autocorrelation into account, we may fit a spatial regression model first. We can find the interval for the line search for the spatial coefficient \\(\\lambda\\) from the inverse of the extreme eigenvalues of the spatial weights, here using spatialreg::lextrB(): ints &lt;- 1/c(spatialreg::lextrB(lw_q_B)) ints #&gt; lambda_n lambda_1 #&gt; -0.293 0.157 From the output of a simultaneous autoregressive spatial error model, we see that the coefficient is close to its upper bound: SEM &lt;- spatialreg::errorsarlm(I_turnout ~ 1, data=pol_pres15, listw=lw_q_B, method=&quot;Matrix&quot;, interval=ints) spatialreg::coef.sarlm(SEM) #&gt; lambda (Intercept) #&gt; 0.139 0.459 The spatial error model is clearly a better description of the data than a mean model with just the intercept using a likelihood ratio test for comparison: spatialreg::LR1.sarlm(SEM) #&gt; #&gt; Likelihood Ratio diagnostics for spatial dependence #&gt; #&gt; data: #&gt; Likelihood ratio = 2000, df = 1, p-value &lt;2e-16 #&gt; sample estimates: #&gt; Log likelihood of spatial error model #&gt; 4386 #&gt; Log likelihood of OLS fit y #&gt; 3330 Reconstructing a linear model after filtering out the global spatial autocorrelation \\((I - \\lambda W)\\) as lm.target, we can also construct \\((I - \\lambda W)^{-1}\\) representing the global spatial process as input to the Omega= argument. This is used internally to re-balance the matrix products of the per-observation star weights matrices, so involves substantial amounts of numerical linear algebra, including solving a dense matrix eigeneproblem, for each chosen observation. So if we take global autocorrelation into account, in this case the no-adjustment count of observations with p-values of less than \\(0.05\\) is under 7%, and using Bonferroni correction, we drop to 0.2%. lm.target &lt;- lm(SEM$tary ~ SEM$tarX - 1) Omega &lt;- invIrW(lw_q_B, rho=SEM$lambda) locmsO &lt;- localmoran.sad(lm.target, nb=nb_q, style=&quot;B&quot;, alternative=&quot;two.sided&quot;, Omega=Omega) locmsO &lt;- as.data.frame(locmsO) pvssO &lt;- cbind(locmsO[,5], p.adjust(locmsO[,5], &quot;bonferroni&quot;), p.adjust(locmsO[,5], &quot;fdr&quot;), p.adjust(locmsO[,5], &quot;BY&quot;)) colnames(pvssO) &lt;- c(&quot;none&quot;, &quot;bonferroni&quot;, &quot;fdr&quot;, &quot;BY&quot;) apply(pvssO, 2, function(x) sum(x &lt; 0.05)) #&gt; none bonferroni fdr BY #&gt; 167 5 13 4 In the global measure case, bootstrap permutations could be used as an alternative to analytical methods for possible inference. In the local case, conditional permutation may be used, retaining the value at observation \\(i\\) and randomly sampling from the remaining \\(n-1\\) values to find randomised values at neighbours. x &lt;- pol_pres15$I_turnout lw &lt;- lw_q_B xx &lt;- mean(x) z &lt;- x - xx s2 &lt;- sum(z^2)/length(x) crd &lt;- card(lw$neighbours) nsim &lt;- 999 res_p &lt;- numeric(nsim) mns &lt;- numeric(length(x)) sds &lt;- numeric(length(x)) set.seed(1) for (i in seq(along=x)) { wtsi &lt;- lw$weights[[i]] zi &lt;- z[i] z_i &lt;- z[-i] crdi &lt;- crd[i] if (crdi &gt; 0) { for (j in 1:nsim) { sz_i &lt;- sample(z_i, size=crdi) lz_i &lt;- sum(sz_i*wtsi) res_p[j] &lt;- (zi/s2)*lz_i } mns[i] &lt;- mean(res_p) sds[i] &lt;- sd(res_p) } else { mns[i] &lt;- as.numeric(NA) sds[i] &lt;- as.numeric(NA) } } This approach is not provided as a function in spdep. The outcome is that almost 32% of observations have two sided p-values under \\(0.05\\) without multiple comparison correction, and under 3% with Bonferroni correction. Since it is not advisable to use conditional permutation with regression residuals in the presence of spatial autocorrelation, localmoran.sad() and localmoran.exact() provide wys of calculating more robust standard deviates with the added flexibility of a possibly richer mean model. perm_Zi &lt;- (locm[,1] - mns)/sds pv &lt;- 2 * pnorm(abs(perm_Zi), lower.tail = FALSE) pvsp &lt;- cbind(pv, p.adjust(pv, &quot;bonferroni&quot;), p.adjust(pv, &quot;fdr&quot;), p.adjust(pv, &quot;BY&quot;)) colnames(pvsp) &lt;- c(&quot;none&quot;, &quot;bonferroni&quot;, &quot;fdr&quot;, &quot;BY&quot;) apply(pvsp, 2, function(x) sum(x &lt; 0.05)) #&gt; none bonferroni fdr BY #&gt; 789 68 477 160 The figure shows the breadth of the density distribution of the standard deviates calculated using the analytical randomisation approach, compared with those of Saddlepoint approximation with and without the accommodation of global spatial autocorrelation, and with conditional permutation. plot(density(locm[,4]), lwd=1.5, ylim=c(0, 0.75), xlab=&quot;standard deviates&quot;, main=&quot;&quot;) lines(density(locms[,4]), lwd=1.5, col=&quot;darkblue&quot;, lty=2) lines(density(locmsO[,4]), lwd=1.5, col=&quot;red&quot;, lty=3) lines(density(perm_Zi), lwd=1.5, col=&quot;brown&quot;, lty=4) abline(v=0, h=0) legend(&quot;topright&quot;, legend=c(&quot;Analytical randomisation&quot;, &quot;Saddlepoint approximation&quot;, &quot;Saddlepoint approximation (Omega)&quot;, &quot;Conditional permutation&quot;), col=c(&quot;black&quot;, &quot;darkblue&quot;, &quot;red&quot;, &quot;brown&quot;), lwd=1.5, lty=1:4, bty=&quot;n&quot;) (#fig:localmoran_Zi)Local Moran’s I dtandard deviates 17.4 Spatial heterogeneity (McMillen 2003) 17.4.1 Local spatial heteroscedasticity ({LOSH}) statistic (Ord and Getis 2012; Xu, Mei, and Yan 2014; Westerholt et al. 2018; Westerholt, Resch, and Zipf 2015) 17.4.2 Moran eigenvectors References "]
]
