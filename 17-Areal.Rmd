# Area Data and Spatial Autcorrelation

Areal units of observation are very often used when simultaneous observations are aggregated within non-overlapping boundaries. The boundaries may be those of administrative entities, and may be related to underlying spatial processes, such as commuting flows, but are usually arbitrary. If they do not match the underlying and unobserved spatial processes in one or more variables of interest, proximate areal units will contain parts of the underlying processes, engendering spatial autocorrelation. This is at least in part because the aggregated observations are driven by factors which may or may not themselves have been observed.

It is possible to represent the support of areal data by a point, despite the fact that the data have polygonal support. The centroid of the polygon may be taken as a representative point, or the centroid of the largest polygon in a multi-polygon object. When data with intrinsic point support are treated as areal data, the change of support goes the other way, from the known point to a non-overlapping tesselation such as a Voronoi diagram or Dirichlet tessellation or Theissen polygons often through a Delaunay triangulation when using a Euclidean plane. Here, different metrics may also be chosen, or distances measured on a network rather than on the plane. There is also a literature using weighted Voronoi diagrams in local spatial analysis [see for example @doi:10.1080/13658810601034267; @doi:10.1080/13658810701587891; @SHE201570].

When the intrinsic support of the data is as points, but the underlying process is between proximate observations rather than driven chiefly by distance however measured between observations, the data may be aggregate counts or totals (polling stations, retail turnover) or represent a directly observed characteristic of the observation (opening hours of the polling station). Obviously, the risk of mis-representing the footprint of the underlying spatial processes remains in all of these cases, not least because the observations are taken as encompassing the entirety of the underlying process in the case of tesselation of the whole area of interest. This is distinct from the geostatistical setting in which observations are rather samples taken using some scheme within the area of interest. It is also partly distinct from the practice of taking areal sample plots within the area of interest but covering only a small proportion of the area, typically used in ecological and environmental research.

This chapter then considers a subset of the methods potentially available for exploring spatial autocorrelation in areal data, or data being handled as areal, where the spatial processes are considered as working through proximity understood in the first instance as contiguity, as a graph linking observations taken as neighbours. This graph is typically undirected and unweighted, but may be directed and/or weighted in certain settings, which then lead to further issues with regard to symmetry. In principle, proximity would be expected to operate symmetrically in space, that is that the influence of $i$ on $j$ and of $j$ on $i$ based on their relative positions should be equivalent. Edge effects are not considered in standard treatments.


## Spatial autocorrelation

When analysing areal data, it has long been recognised that, if present, spatial autocorrelation changes how we may infer, relative to the default position of independent observations. In the presence of spatial autocorrelation, we can predict the values of observation $i$ from the values observed at $j \in N_i$, the set of its proximate neighbours. Early results [@moran48; @geary:54], entered into research practice gradually, for example the social sciences [@duncanetal61]. These results were then collated and extended to yield a set of basic tools of analysis [@cliff+ord:73; @cliff+ord:81]. 

Cliff and Ord [-@cliff+ord:73] generalised and extended the expression of the spatial weights matrix representation as part of the framework for establishing the distribution theory for join count, Moran's $I$ and Geary's $C$ statistics. This development of what have become known as global measures, returning a single value of autocorrelation for the total study area, has been supplemented by local measures returning values for each areal unit [getis+ord:92; @anselin:95].


## Spatial weights matrices

Handling spatial autocorrelation using relationships to neighbours on a graph takes the graph as given, chosen by the analyst. This differs from the geostatistical approach in which the analyst chooses the binning of the empirical variogram and function used, and then the way the fitted variogram is fitted. Both involve a priori choices, but represent the underlying correlation in different ways [@wall:04]. In Bavaud [-@bavaud:98] and work citing his contribution, attempts have been made to place graph-based neighbours in a broader context.

One issue arising in the creation of objects representing neighbourhood relationships is that of no-neighbour areal units [@bivand+portnov:04]. Islands or units separated by rivers may not be recognised as neighbours when the units have areal support and when using topological relationships such as shared boundaries. In some settings, for example `mrf` (Markov Random Field) terms in `mgcv::gam()` and similar model fitting functions that require undirected connected graphs, a requirement also violated when there are disconnected subgraphs. 

No-neighbour observations can also occur when a distance threshold is used between points, where the threshold is smaller than the maximum nearest neighbour distance. Shared boundary contiguities are not affected by using geographical, unprojected coordinates, but all point-based approaches use distance in one way or another, and need to calculate distances in an appropriate way.

The **spdep** package provides an `nb` class for neighbours, a list of length equal to the number of observations, with integer vector components. No-neighbours are encoded as an integer vector with a single element `0L`, and observations with neighbours as sorted integer vectors containing values in `1L:n` pointing to the neighbouring observations. This is a typical row-oriented sparse representation of neighbours. **spdep** provides many ways of constructing `nb` objects, and the representation and construction functions are widely used in other packages. 

**spdep** builds on the `nb` representation (undirected or directed graphs) with the `listw` object, a list with three components, an `nb` object, a matching list of numerical weights, and a single element character vector containing the single letter name of the way in which the weights were calculated. The most frequently used approach in the social sciences is calculating weights by row standardization, so that all the non-zero weights for one observation will be the inverse of the cardinality of its set of neighbours (`1/card(nb[[i]])`.

We will be using election data from the 2015 Polish Presidential election in this chapter, with 2495 municipalities and Warsaw boroughs, and complete count data from polling stations aggregated to these areal units. The data are an **sf** `sf` object:

```{r}
library(sf)
```

```{r}
data(pol_pres15, package="spDataLarge")
head(pol_pres15[, c(1, 4, 6)])
```

```{r}
library(tmap)
tm_shape(pol_pres15) + tm_fill("types")
```

Between early 2002 and April 2019, **spdep** contained functions for constructing and handling neighbour and spatial weights objects, tests for spatial autocorrelation, and model fitting functions. The latter have been split out into **spatialreg**, and will be discussed in the next chapter. **spdep** now accommodates objects represented using **sf** classes and **sp** classes directly, going beyond the explorations made in [this vignette](https://cran.r-project.org/web/packages/spdep/vignettes/nb_sf.html).

```{r}
library(spdep)
```

### Contiguous neighbours

The `poly2nb()` function in **spdep** takes the boundary points making up the polygon boundaries in the object passed as the `pl=` argument, and for each observation checks whether at least one (`queen=TRUE`, default), or at least two (rook, `queen=FALSE`) points are within `snap=` distance units of each other. The distances are planar in the raw coordinate units, ignoring geographical projections. Once the required number of sufficiently close points is found, the search is stopped.

```{r}
args(poly2nb)
```

The geometry column should be either of class `"sfc_MULTIPOLYGON"` or `"sfc_POLYGON"`, not `"sfc_GEOMETRY"`; if need be cast to `"MULTIPOLYGON"` if there are mixed `"POLYGON"` and `"MULTIPOLYGON"` objects.

```{r}
class(st_geometry(pol_pres15))
```

```{r}
table(sapply(st_geometry(pol_pres15), function(x) class(x)[2]))
```

```{r}
system.time(nb_q <- poly2nb(pol_pres15, queen=TRUE))
```

```{r}
nb_q
```

The **rgeos** `gUnarySTRtreeQuery()` function also reduces polygons to their boundary points before searching for overlapping "envelopes", the bounding boxes of the derived multi-point objects. Here, pre-finding candidate contiguous neighbours only shaves off a little run time, but may be helpful with larger objects.

```{r}
system.time({
  fB <- rgeos::gUnarySTRtreeQuery(as(pol_pres15, "Spatial"))
  nb_q1 <- poly2nb(pol_pres15, queen=TRUE, foundInBox=fB)
})
```
```{r}
all.equal(nb_q, nb_q1, check.attributes=FALSE)
```

We might consider using the contiguity of the polygon boundaries, the fifth element of the DE-9IM vector, setting the first element to FALSE, to find Queen neighbours using GEOS functions in **sf**, but it takes longer than simply treating the boundaries as points:

```{r}
st_queen <- function(a, b = a) st_relate(a, b, pattern = "F***T****")
as.nb.sgbp <- function(x, ...) {
  attrs <- attributes(x)
  x <- lapply(x, function(i) { if(length(i) == 0L) 0L else i } )
  attributes(x) <- attrs
  class(x) <- "nb"
  x
}
system.time(nb_sf_q <- as.nb.sgbp(st_queen(pol_pres15)))
```
```{r}
all.equal(nb_q, nb_sf_q, check.attributes=FALSE)
```

The same effect as using `rgeos::gUnarySTRtreeQuery` can be obtained without the overhead of converting to the equivalent **sp** class and using **rgeos** to make the equivalent tree search using **sf**, by finding intersecting bounding boxes, removing self-intersections and duplicate intersections (contiguities are by definition symmetric, if `i` is a neighbour of `j`, then `j` is a neighbour of `i`).

```{r}
system.time({
  fB1 <- st_intersects(st_as_sfc(lapply(st_geometry(pol_pres15), function(x) {
    bb <- st_bbox(x)
    mat <- cbind(c(bb[1], bb[1], bb[3], bb[3], bb[1]), c(bb[2], bb[4], bb[4], bb[2], bb[2]))
    st_polygon(list(mat))
  })))
  fB1a <- lapply(seq_along(fB1), function(i) fB1[[i]][fB1[[i]] > i])
  fB1a <- fB1a[-length(fB1a)]
  nb_sf_q1 <- poly2nb(pol_pres15, queen=TRUE, foundInBox=fB1a)
})
```
```{r}
all.equal(nb_q, nb_sf_q1, check.attributes=FALSE)
```

Much of the work involved in finding contiguous neighbours is spent on finding candidate neighbours with intersecting bounding boxes. Note that `nb` objects record both symmetric neighbour relationships, because these objects admit asymmetric relationships as well, but these duplications are not needed for object construction.

Most of the **spdep** functions for constructing neighbour objects take a `row.names=` argument, the value of which is stored as a `region.id` attribute. If not given, the values are taken from `row.names()` of the first argument. These can be used to check that the neighbours object is in the same order as data. If `nb` objects are subsetted, the indices change to continue to be within `1:length(subsetted_nb)`, but the `region.id` attribute values point back to the object from which it was constructed.

### Graph-based neighbours

If areal units are an appropriate representation, but only points have been observed, contiguity relationships may be approximated using graph-based neighbours. In this case, the imputed boundaries tesselate the plane such that points closer to one observation than any other fall within its polygon. The simplest form is by using triangulation, here using the `deldir()` function in the **deldir** package. Because the function returns from and to identifiers, it is easy to construct a long representation of a `listw` object, as used in the S-Plus SpatialStats module and the `sn2listw()` function internally to construct an `nb` object (ragged wide representation). Alternatives often fail to return sufficient information to permit the neighbours to be identified.

```{r}
args(tri2nb)
```

The `soi.graph()` function takes triangulated neighbours and prunes off neighbour relationships represented by unusually long edges, but may render the output object asymmetric. Other graph-based approaches include `relativeneigh()` and `gabrielneigh()`.

```{r}
args(soi.graph)
```
The output of these functions is then converted to the `nb` representation using `graph2nb()`, with the possible use of the `sym=` argument to coerce to symmetry.

```{r}
args(graph2nb)
```


```{r}
coords <- st_centroid(st_geometry(pol_pres15), of_largest_polygon=TRUE)
```

### Distance-based neighbours

```{r}
args(dnearneigh)
```

```{r}
args(knearneigh)
```


```{r}
args(knn2nb)
```

```{r}

```


### Weight standardization

[@tiefelsdorfatal:99]

```{r}
args(nb2listw)
```


## Measures of spatial autcorrelation

[@WallerGotway:2004; @McMillen:2003]

[@Bivand2018]

[@tiefelsdorf:02; @bivandetal:09]

### Global measures

[@TiefelsdorfBoots1995; @TiefelsdorfBoots1997; @Hepple1998]

[@assuncao+reis:99]

[@anselin:96]

### Local measures

[@anselin:95; @getis+ord:92; @getis+ord:96]

[@ord+getis:01; @tiefelsdorf:02; @bivandetal:09]



## Spatial heterogeneity

[@McMillen:2003]

### Local spatial heteroscedasticity ({LOSH}) statistic

[@ord+getis12; @xuetal14; @westerholtetal18; @westerholtetal15]

### Moran eigenvectors



## Spatially structured random effects


